{"ast":null,"code":"/**\n * Bundle of @devexpress/dx-chart-core\n * Generated: 2018-11-07\n * Version: 1.9.0\n * License: https://js.devexpress.com/Licensing\n */\nimport { extent } from 'd3-array';\nimport { scaleLinear, scaleBand, scaleOrdinal } from 'd3-scale';\nimport { symbol, symbolCircle, line, curveMonotoneX, area, arc, pie, stack } from 'd3-shape';\nvar HORIZONTAL = 'horizontal';\nvar VERTICAL = 'vertical';\nvar TOP = 'top';\nvar BOTTOM = 'bottom';\nvar LEFT = 'left';\nvar RIGHT = 'right';\nvar MIDDLE = 'middle';\nvar END = 'end';\nvar START = 'start';\nvar LINEAR = 'linear';\nvar BAND = 'band';\nvar ARGUMENT_DOMAIN = 'argument-domain';\nvar VALUE_DOMAIN = 'value-domain';\nvar HOVERED = 'hovered';\nvar SELECTED = 'selected';\n\nvar createScale = function createScale(_ref, width, height, constructor) {\n  var domain = _ref.domain,\n      orientation = _ref.orientation;\n  var scale = constructor();\n  return scale.domain(domain).range(orientation === HORIZONTAL ? [0, width] : [height, 0]);\n};\n\nvar getWidth = function getWidth(scale) {\n  return scale.bandwidth ? scale.bandwidth() : 0;\n};\n\nvar getValueDomainName = function getValueDomainName(name) {\n  return name || VALUE_DOMAIN;\n};\n\nvar defineProperty = function defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar objectWithoutProperties = function objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar toConsumableArray = function toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nvar isDefined = function isDefined(item) {\n  return item !== undefined;\n}; // TODO: Property name should not contain \"axis\" part as it actually means domain.\n\n\nvar getSeriesValueDomainName = function getSeriesValueDomainName(series) {\n  return getValueDomainName(series.axisName);\n};\n\nvar calculateDomainField = function calculateDomainField(items, domain, type) {\n  return type === BAND ? [].concat(toConsumableArray(domain), toConsumableArray(items)) : extent([].concat(toConsumableArray(domain), toConsumableArray(extent(items))));\n};\n\nvar getArgument = function getArgument(point) {\n  return point.argument;\n};\n\nvar getValue = function getValue(point) {\n  return point.value;\n};\n\nvar getCorrectAxisType = function getCorrectAxisType(type, points, getItem) {\n  return type || points.length && typeof getItem(points[0]) === 'string' && BAND || LINEAR;\n};\n\nvar calculateDomains = function calculateDomains(domains, seriesList) {\n  seriesList.forEach(function (seriesItem) {\n    var valueDomainName = getSeriesValueDomainName(seriesItem);\n    var points = seriesItem.points;\n    var argumentDomain = domains[ARGUMENT_DOMAIN];\n    var valueDomain = domains[valueDomainName];\n    var valueType = getCorrectAxisType(valueDomain.type, points, getValue);\n    var argumentType = getCorrectAxisType(argumentDomain.type, points, getArgument); // TODO: This is a temporary workaround for Stack plugin.\n    // Once scales (or domains) are exposed for modification Stack will modify scale and\n    // this code will be removed.\n\n    var valueDomainItems = seriesItem.getValueDomain ? seriesItem.getValueDomain(points) : points.map(getValue);\n    valueDomain.domain = calculateDomainField(valueDomainItems, valueDomain.domain, valueType);\n    valueDomain.type = valueType;\n    argumentDomain.domain = calculateDomainField(points.map(getArgument), argumentDomain.domain, argumentType);\n    argumentDomain.type = argumentType;\n  });\n};\n\nvar computeExtension = function computeExtension(extension) {\n  var defaultExtension = [{\n    type: LINEAR,\n    constructor: scaleLinear\n  }, {\n    type: BAND,\n    constructor: function constructor() {\n      return scaleBand().paddingInner(0.3).paddingOuter(0.15);\n    }\n  }];\n  return extension.concat(defaultExtension);\n};\n\nvar collectDomains = function collectDomains(seriesList) {\n  var domains = defineProperty({}, ARGUMENT_DOMAIN, {\n    domain: [],\n    orientation: HORIZONTAL\n  });\n  seriesList.forEach(function (seriesItem) {\n    var name = getSeriesValueDomainName(seriesItem);\n    var domain = domains[name] || {\n      domain: [],\n      orientation: VERTICAL\n    };\n    domains[name] = domain;\n\n    if (seriesItem.isStartedFromZero && domain.domain.length === 0) {\n      domain.domain = [0];\n    }\n  });\n  return domains;\n};\n\nvar takeTypeFromAxesOptions = function takeTypeFromAxesOptions(domains, axes) {\n  axes.forEach(function (_ref) {\n    var name = _ref.name,\n        type = _ref.type;\n    var domain = domains[name];\n\n    if (domain) {\n      domain.type = type;\n    }\n  });\n};\n\nvar takeRestAxesOptions = function takeRestAxesOptions(domains, axes) {\n  axes.forEach(function (_ref2) {\n    var name = _ref2.name,\n        tickFormat = _ref2.tickFormat,\n        min = _ref2.min,\n        max = _ref2.max;\n    var domain = domains[name];\n\n    if (!domain) {\n      return;\n    }\n\n    domain.tickFormat = tickFormat;\n\n    if (domain.type !== BAND) {\n      domain.domain = [isDefined(min) ? min : domain.domain[0], isDefined(max) ? max : domain.domain[1]];\n    }\n  });\n};\n\nvar computeDomains = function computeDomains(axes, series) {\n  var result = collectDomains(series); // Axes options are taken in two steps because *type* is required for domains calculation\n  // and other options must be applied after domains are calculated.\n\n  takeTypeFromAxesOptions(result, axes);\n  calculateDomains(result, series);\n  takeRestAxesOptions(result, axes);\n  return result;\n};\n\nvar buildScales = function buildScales(domains, scaleExtension, _ref3) {\n  var width = _ref3.width,\n      height = _ref3.height;\n  var scales = {};\n  Object.entries(domains).forEach(function (_ref4) {\n    var _ref5 = slicedToArray(_ref4, 2),\n        name = _ref5[0],\n        domain = _ref5[1];\n\n    var _scaleExtension$find = scaleExtension.find(function (item) {\n      return item.type === domain.type;\n    }),\n        constructor = _scaleExtension$find.constructor;\n\n    scales[name] = createScale(domain, width, height, constructor);\n  });\n  return scales;\n};\n\nvar isEqual = function isEqual(_ref, _ref2) {\n  var firstWidth = _ref.width,\n      firstHeight = _ref.height;\n  var secondWidth = _ref2.width,\n      secondHeight = _ref2.height;\n  return firstWidth === secondWidth && firstHeight === secondHeight;\n};\n\nvar bBoxes = function bBoxes(prevBBoxes, _ref3) {\n  var bBox = _ref3.bBox,\n      placeholder = _ref3.placeholder;\n  if (isEqual(prevBBoxes[placeholder] || {}, bBox)) return prevBBoxes;\n  return _extends({}, prevBBoxes, defineProperty({}, placeholder, bBox));\n};\n\nvar getTicks = function getTicks(scale) {\n  return scale.ticks ? scale.ticks() : scale.domain();\n};\n\nvar getDominantBaseline = function getDominantBaseline(orientation, position) {\n  if (orientation === HORIZONTAL) {\n    return position === TOP ? 'baseline' : 'hanging';\n  }\n\n  return MIDDLE;\n};\n\nvar getTextAnchor = function getTextAnchor(orientation, position) {\n  if (orientation === HORIZONTAL) {\n    return MIDDLE;\n  }\n\n  return position === LEFT ? END : START;\n};\n\nvar getFormat = function getFormat(scale, tickFormat) {\n  if (scale.tickFormat) {\n    return tickFormat ? tickFormat(scale) : scale.tickFormat();\n  }\n\n  return function (tick) {\n    return tick;\n  };\n}; // It is called for grid (which do not have labels) - how is it handled here?\n\n\nvar calculateAxisCoordinates = function calculateAxisCoordinates(scale, orientation, position, tickSize, indentFromAxis, tickFormat) {\n  var ticks = getTicks(scale);\n  var offset = getWidth(scale) / 2;\n  var dominantBaseline = getDominantBaseline(orientation, position);\n  var textAnchor = getTextAnchor(orientation, position);\n\n  var getTickCoordinates = function getTickCoordinates(tick, index) {\n    var coordinates = scale(tick) + offset;\n\n    if (orientation === HORIZONTAL) {\n      return {\n        dominantBaseline: dominantBaseline,\n        textAnchor: textAnchor,\n        x1: coordinates,\n        x2: coordinates,\n        y1: position === TOP ? -tickSize : 0,\n        y2: position === TOP ? 0 : tickSize,\n        text: getFormat(scale, tickFormat)(tick),\n        xText: coordinates,\n        yText: position === TOP ? -indentFromAxis : indentFromAxis,\n        key: index\n      };\n    }\n\n    return {\n      dominantBaseline: dominantBaseline,\n      textAnchor: textAnchor,\n      y1: coordinates,\n      y2: coordinates,\n      x1: position === LEFT ? -tickSize : 0,\n      x2: position === LEFT ? 0 : tickSize,\n      text: getFormat(scale, tickFormat)(tick),\n      xText: position === LEFT ? -indentFromAxis : indentFromAxis,\n      yText: coordinates,\n      key: index\n    };\n  };\n\n  return {\n    ticks: ticks.map(getTickCoordinates)\n  };\n};\n\nvar axisCoordinates = function axisCoordinates(domain, scale, position, tickSize, indentFromAxis) {\n  return calculateAxisCoordinates(scale, domain.orientation, position, tickSize, indentFromAxis, // TODO: *tickFormat* belongs to axis rather then domain - take it from axis.\n  domain.tickFormat);\n};\n\nvar axesData = function axesData(axes, axisProps) {\n  return [].concat(toConsumableArray(axes), [axisProps]);\n};\n\nvar getX = function getX(_ref) {\n  var x = _ref.x;\n  return x;\n};\n\nvar getY = function getY(_ref2) {\n  var y = _ref2.y;\n  return y;\n};\n\nvar getY1 = function getY1(_ref3) {\n  var y1 = _ref3.y1;\n  return y1;\n};\n\nvar DEFAULT_POINT_SIZE = 7;\nvar dArea = area().x(getX).y1(getY).y0(getY1);\nvar dLine = line().x(getX).y(getY);\nvar dSpline = line().x(getX).y(getY).curve(curveMonotoneX);\n\nvar getPiePointTransformer = function getPiePointTransformer(_ref4) {\n  var _ref4$innerRadius = _ref4.innerRadius,\n      innerRadius = _ref4$innerRadius === undefined ? 0 : _ref4$innerRadius,\n      _ref4$outerRadius = _ref4.outerRadius,\n      outerRadius = _ref4$outerRadius === undefined ? 1 : _ref4$outerRadius,\n      argumentScale = _ref4.argumentScale,\n      valueScale = _ref4.valueScale,\n      palette = _ref4.palette,\n      points = _ref4.points;\n  var x = Math.max.apply(Math, toConsumableArray(argumentScale.range())) / 2;\n  var y = Math.max.apply(Math, toConsumableArray(valueScale.range())) / 2;\n  var radius = Math.min(x, y);\n  var pieData = pie().sort(null).value(function (d) {\n    return d.value;\n  })(points);\n  var inner = innerRadius * radius;\n  var outer = outerRadius * radius;\n  var gen = arc().innerRadius(inner).outerRadius(outer);\n  var colorScale = scaleOrdinal().range(palette);\n  return function (point) {\n    var _pieData$point$index = pieData[point.index],\n        startAngle = _pieData$point$index.startAngle,\n        endAngle = _pieData$point$index.endAngle;\n    return _extends({}, point, {\n      // TODO: It should be calculated in *pointComponent*.\n      d: gen.startAngle(startAngle).endAngle(endAngle)(),\n      color: point.color || colorScale(point.index),\n      x: x,\n      y: y,\n      innerRadius: inner,\n      outerRadius: outer,\n      startAngle: startAngle,\n      endAngle: endAngle\n    });\n  };\n};\n\nvar getAreaPointTransformer = function getAreaPointTransformer(_ref5) {\n  var argumentScale = _ref5.argumentScale,\n      valueScale = _ref5.valueScale;\n  var y1 = valueScale(0);\n  var offset = getWidth(argumentScale) / 2;\n  return function (point) {\n    return _extends({}, point, {\n      x: argumentScale(point.argument) + offset,\n      y: valueScale(point.value),\n      y1: y1\n    });\n  };\n};\n\nvar getBarPointTransformer = function getBarPointTransformer(_ref6) {\n  var argumentScale = _ref6.argumentScale,\n      valueScale = _ref6.valueScale,\n      barWidth = _ref6.barWidth;\n  var y1 = valueScale(0);\n  var categoryWidth = getWidth(argumentScale);\n  var offset = categoryWidth * (1 - barWidth) / 2;\n  var width = categoryWidth * barWidth;\n  return function (point) {\n    return _extends({}, point, {\n      x: argumentScale(point.argument) + offset,\n      y: valueScale(point.value),\n      y1: y1,\n      width: width\n    });\n  };\n}; // Used for Bar grouping.\n\n\ngetBarPointTransformer.isBroad = true;\n\nvar findSeriesByName = function findSeriesByName(name, series) {\n  return series.find(function (seriesItem) {\n    return seriesItem.symbolName === name;\n  });\n};\n\nvar dBar = function dBar(_ref7) {\n  var x = _ref7.x,\n      y = _ref7.y,\n      y1 = _ref7.y1,\n      width = _ref7.width;\n  return {\n    x: x,\n    y: Math.min(y, y1),\n    width: width || 2,\n    height: Math.abs(y1 - y)\n  };\n};\n\nvar pointAttributes = function pointAttributes(_ref8) {\n  var _ref8$size = _ref8.size,\n      size = _ref8$size === undefined ? DEFAULT_POINT_SIZE : _ref8$size;\n  var dPoint = symbol().size([Math.pow(size, 2)]).type(symbolCircle)();\n  return function (item) {\n    return {\n      // TODO: It should be calculated in *pointComponent*.\n      d: dPoint,\n      x: item.x,\n      y: item.y\n    };\n  };\n};\n\nvar createNewUniqueName = function createNewUniqueName(name) {\n  return name.replace(/\\d*$/, function (str) {\n    return str ? +str + 1 : 0;\n  });\n};\n\nvar addItem = function addItem(list, item) {\n  return list.find(function (obj) {\n    return obj.uniqueName === item.uniqueName;\n  }) ? addItem(list, _extends({}, item, {\n    uniqueName: createNewUniqueName(item.uniqueName)\n  })) : list.concat(item);\n}; // TODO: Memoization is much needed here.\n// Though \"series\" list never persists, single \"series\" item most often does.\n\n\nvar createPoints = function createPoints(argumentField, valueField, data) {\n  var points = [];\n  data.forEach(function (dataItem, index) {\n    var argument = dataItem[argumentField];\n    var value = dataItem[valueField];\n\n    if (argument !== undefined && value !== undefined) {\n      points.push({\n        argument: argument,\n        value: value,\n        index: index\n      });\n    }\n  });\n  return points;\n};\n\nvar addSeries = function addSeries(series, data, palette, props) {\n  var points = createPoints(props.argumentField, props.valueField, data); // It is used to generate unique series dependent attribute names for patterns.\n  // *symbolName* cannot be used as it cannot be part of DOM attribute name.\n  // TODO: Consider making *name* unique and then use it instead of *index*.\n\n  var index = series.length;\n  return addItem(series, _extends({}, props, {\n    index: index,\n    points: points,\n    uniqueName: props.name,\n    palette: palette,\n    // TODO: For Pie only. Find a better place for it.\n    color: props.color || palette[index % palette.length]\n  }));\n}; // TODO: Memoization is much needed here by the same reason as in \"createPoints\".\n// Make \"scales\" persistent first.\n\n\nvar scalePoints = function scalePoints(series, scales) {\n  var getPointTransformer = series.getPointTransformer,\n      rest = objectWithoutProperties(series, ['getPointTransformer']);\n  var transform = getPointTransformer(_extends({}, series, {\n    argumentScale: scales[ARGUMENT_DOMAIN],\n    valueScale: scales[getValueDomainName(series.axisName)]\n  }));\n  return _extends({}, rest, {\n    points: series.points.map(transform)\n  });\n};\n\nvar scaleSeriesPoints = function scaleSeriesPoints(series, scales) {\n  return series.map(function (seriesItem) {\n    return scalePoints(seriesItem, scales);\n  });\n}; // \"Stack\" plugin relies on \"data\" and \"series\" getters and\n// knowledge about \"getPointTransformer\" and \"path\" functions behavior.\n\n\nvar buildSeriesToStackMap = function buildSeriesToStackMap(stacks) {\n  var result = {};\n  stacks.forEach(function (_ref, i) {\n    var series = _ref.series;\n    series.forEach(function (name) {\n      result[name] = i;\n    });\n  });\n  return result;\n};\n\nvar getStackedPointTransformer = function getStackedPointTransformer(getPointTransformer) {\n  var wrapper = function wrapper(series) {\n    var transform = getPointTransformer(series);\n    var valueScale = series.valueScale;\n    return function (point) {\n      var ret = transform(point);\n      ret.y1 = valueScale(point.value0);\n      return ret;\n    };\n  }; // Preserve static fields of original transformer.\n\n\n  Object.assign(wrapper, getPointTransformer);\n  return wrapper;\n}; // TODO: Temporary - see corresponding note in *computeDomains*.\n\n\nvar getValueDomain = function getValueDomain(points) {\n  var items = [];\n  points.forEach(function (point) {\n    items.push(point.value, point.value0);\n  });\n  return items;\n};\n\nvar collectStacks = function collectStacks(seriesList, seriesToStackMap) {\n  var stacksKeys = {};\n  var seriesPositions = {};\n  seriesList.forEach(function (_ref2) {\n    var name = _ref2.name,\n        valueField = _ref2.valueField;\n    var stackId = seriesToStackMap[name];\n\n    if (stackId === undefined) {\n      return;\n    }\n\n    if (!stacksKeys[stackId]) {\n      stacksKeys[stackId] = [];\n    }\n\n    seriesPositions[name] = stacksKeys[stackId].length;\n    stacksKeys[stackId].push(valueField);\n  }); // Stack cannot consist of single series.\n\n  Object.keys(stacksKeys).forEach(function (stackId) {\n    if (stacksKeys[stackId].length === 1) {\n      delete stacksKeys[stackId];\n    }\n  });\n  return [stacksKeys, seriesPositions];\n};\n\nvar getStackedData = function getStackedData(stacksKeys, dataItems, offset, order) {\n  var result = {};\n  Object.keys(stacksKeys).forEach(function (stackId) {\n    result[stackId] = stack().keys(stacksKeys[stackId]).order(order).offset(offset)(dataItems);\n  });\n  return result;\n};\n\nvar buildStackedSeries = function buildStackedSeries(series, dataItems) {\n  var points = series.points.map(function (point) {\n    var _dataItems$point$inde = slicedToArray(dataItems[point.index], 2),\n        value0 = _dataItems$point$inde[0],\n        value = _dataItems$point$inde[1];\n\n    return _extends({}, point, {\n      value: value,\n      value0: value0\n    });\n  });\n\n  var stackedSeries = _extends({}, series, {\n    points: points\n  });\n\n  if (series.isStartedFromZero) {\n    stackedSeries.getPointTransformer = getStackedPointTransformer(series.getPointTransformer);\n    stackedSeries.getValueDomain = getValueDomain;\n  }\n\n  return stackedSeries;\n};\n\nvar applyStacking = function applyStacking(seriesList, dataItems, seriesToStackMap, offset, order) {\n  var _collectStacks = collectStacks(seriesList, seriesToStackMap),\n      _collectStacks2 = slicedToArray(_collectStacks, 2),\n      stacksKeys = _collectStacks2[0],\n      seriesPositions = _collectStacks2[1];\n\n  if (Object.keys(stacksKeys).length === 0) {\n    return seriesList;\n  }\n\n  var stackedData = getStackedData(stacksKeys, dataItems, offset, order);\n  return seriesList.map(function (seriesItem) {\n    var stackId = seriesToStackMap[seriesItem.name];\n    var stackData = stackedData[stackId];\n\n    if (!stackData) {\n      return seriesItem;\n    }\n\n    var position = seriesPositions[seriesItem.name];\n    return buildStackedSeries(seriesItem, stackData[position]);\n  });\n};\n\nvar getGroupName = function getGroupName(series, i, seriesToStackMap) {\n  var stackId = seriesToStackMap[series.name];\n  return stackId >= 0 ? String(stackId) : 'group-' + i;\n};\n\nvar getGroupedPointTransformer = function getGroupedPointTransformer(getPointTransformer, groupCount, groupOffset) {\n  var wrapper = function wrapper(series) {\n    var transform = getPointTransformer(series);\n    var barWidth = series.barWidth;\n    var widthCoeff = 1 / groupCount;\n    var offsetCoeff = -(1 - barWidth) / 2 + groupOffset + widthCoeff * (1 - barWidth) / 2;\n    return function (point) {\n      var ret = transform(point);\n      ret.x += ret.width / barWidth * offsetCoeff;\n      ret.width *= widthCoeff;\n      return ret;\n    };\n  }; // Preserve static fields of original transformer.\n\n\n  Object.assign(wrapper, getPointTransformer);\n  return wrapper;\n};\n\nvar applyGrouping = function applyGrouping(seriesList, seriesToStackMap) {\n  var groups = new Set();\n  seriesList.forEach(function (seriesItem, i) {\n    if (seriesItem.getPointTransformer.isBroad) {\n      groups.add(getGroupName(seriesItem, i, seriesToStackMap));\n    }\n  }); // There cannot be single group.\n\n  if (groups.size < 2) {\n    return seriesList;\n  }\n\n  var scale = scaleBand().domain(Array.from(groups)).range([0, 1]);\n  return seriesList.map(function (seriesItem, i) {\n    if (!seriesItem.getPointTransformer.isBroad) {\n      return seriesItem;\n    }\n\n    var getPointTransformer = getGroupedPointTransformer(seriesItem.getPointTransformer, groups.size, scale(getGroupName(seriesItem, i, seriesToStackMap)));\n    return _extends({}, seriesItem, {\n      getPointTransformer: getPointTransformer\n    });\n  });\n};\n\nvar getStackedSeries = function getStackedSeries(seriesList, dataItems, _ref3) {\n  var stacks = _ref3.stacks,\n      offset = _ref3.offset,\n      order = _ref3.order;\n  var map = buildSeriesToStackMap(stacks);\n  var stackedSeriesList = applyStacking(seriesList, dataItems, map, offset, order);\n  var groupedSeriesList = applyGrouping(stackedSeriesList, map);\n  return groupedSeriesList;\n};\n\nvar ANIMATIONS = Symbol('animation');\n\nvar addKeyframe = function addKeyframe(name, def) {\n  if (typeof document === 'undefined') {\n    return;\n  }\n\n  var head = document.getElementsByTagName('head')[0]; // eslint-disable-line no-undef\n\n  var style = Array.from(head.getElementsByTagName('style')).find(function (node) {\n    return node.dataset[ANIMATIONS];\n  });\n\n  if (!style) {\n    style = document.createElement('style'); // eslint-disable-line no-undef\n\n    style.type = 'text/css';\n    style.dataset[ANIMATIONS] = true;\n    head.appendChild(style);\n  }\n\n  var content = style.textContent;\n\n  if (!content.includes(name)) {\n    style.textContent += '\\n@keyframes ' + name + ' ' + def + '\\n';\n  }\n};\n\nvar getAreaAnimationName = function getAreaAnimationName() {\n  var name = 'animation_transform';\n  addKeyframe(name, '{ from { transform: scaleY(0); } }');\n  return name;\n};\n\nvar getScatterAnimationName = function getScatterAnimationName() {\n  var name = 'animation_scatter';\n  addKeyframe(name, '{ 0% { opacity: 0; } 50% { opacity: 0; } 100% { opacity: 1 } }');\n  return name;\n};\n\nvar getPieAnimationName = function getPieAnimationName() {\n  var name = 'animation_pie';\n  addKeyframe(name, '{ from { transform: scale(0); } }');\n  return name;\n};\n\nvar getDefaultAreaAnimationOptions = function getDefaultAreaAnimationOptions() {\n  return '1s';\n};\n\nvar getDefaultPieAnimationOptions = function getDefaultPieAnimationOptions(_ref) {\n  var index = _ref.index;\n  return 0.7 + index * 0.1 + 's';\n};\n\nvar getAreaAnimationStyle = function getAreaAnimationStyle(scales) {\n  var animationStyle = {\n    transformOrigin: '0px ' + scales.yScale.copy().clamp(true)(0) + 'px'\n  };\n  var options = getDefaultAreaAnimationOptions();\n  return _extends({\n    animation: getAreaAnimationName() + ' ' + options\n  }, animationStyle);\n};\n\nvar getPieAnimationStyle = function getPieAnimationStyle(scales, point) {\n  var options = getDefaultPieAnimationOptions(point);\n  return {\n    animation: getPieAnimationName() + ' ' + options\n  };\n};\n\nvar getScatterAnimationStyle = function getScatterAnimationStyle() {\n  var options = getDefaultAreaAnimationOptions();\n  return {\n    animation: getScatterAnimationName() + ' ' + options\n  };\n};\n\nvar buildAnimatedStyleGetter = function buildAnimatedStyleGetter(style, getAnimationStyle, scales, point) {\n  var animationStyle = getAnimationStyle(scales, point);\n  return _extends({}, animationStyle, style);\n};\n\nvar isPointInRect = function isPointInRect(x, y, x1, x2, y1, y2) {\n  return x1 <= x && x <= x2 && y1 <= y && y <= y2;\n};\n\nvar LINE_TOLERANCE = 10; // This function is called from event handlers (when DOM is available) -\n// *window.document* can be accessed safely.\n\nvar createContext = function createContext() {\n  return document.createElement('canvas').getContext('2d');\n}; // eslint-disable-line no-undef\n// For a start using browser canvas will suffice.\n// However a better and more clean solution should be found.\n// Can't d3 perform hit testing?\n\n\nvar createCanvasAbusingHitTesterCreator = function createCanvasAbusingHitTesterCreator(makePath) {\n  return function (coordinates) {\n    var ctx = createContext();\n    var path = makePath();\n    path.context(ctx);\n    path(coordinates);\n    return function (_ref) {\n      var _ref2 = slicedToArray(_ref, 2),\n          px = _ref2[0],\n          py = _ref2[1];\n\n      var hit = ctx.isPointInPath(px, py) ? {} : null;\n\n      if (hit) {\n        var point = coordinates.find(function (_ref3) {\n          var x = _ref3.x,\n              y = _ref3.y;\n          return isPointInRect(px, py, x - LINE_TOLERANCE, x + LINE_TOLERANCE, y - LINE_TOLERANCE, y + LINE_TOLERANCE);\n        });\n\n        if (point) {\n          hit.point = point.index;\n        }\n      }\n\n      return hit;\n    };\n  };\n};\n\nvar createAreaHitTester = createCanvasAbusingHitTesterCreator(function () {\n  var path = area();\n  path.x(dArea.x());\n  path.y1(dArea.y1());\n  path.y0(dArea.y0());\n  return path;\n});\nvar createLineHitTester = createCanvasAbusingHitTesterCreator(function () {\n  var path = area();\n  var getY = dLine.y();\n  path.x(dLine.x());\n  path.y1(function (point) {\n    return getY(point) - LINE_TOLERANCE;\n  });\n  path.y0(function (point) {\n    return getY(point) + LINE_TOLERANCE;\n  });\n  return path;\n});\nvar createSplineHitTester = createCanvasAbusingHitTesterCreator(function () {\n  var path = area();\n  var getY = dSpline.y();\n  path.x(dSpline.x());\n  path.y1(function (point) {\n    return getY(point) - LINE_TOLERANCE;\n  });\n  path.y0(function (point) {\n    return getY(point) + LINE_TOLERANCE;\n  });\n  path.curve(dSpline.curve());\n  return path;\n});\n\nvar createBarHitTester = function createBarHitTester(coordinates) {\n  return function (_ref4) {\n    var _ref5 = slicedToArray(_ref4, 2),\n        px = _ref5[0],\n        py = _ref5[1];\n\n    var point = coordinates.find(function (_ref6) {\n      var x = _ref6.x,\n          width = _ref6.width,\n          y = _ref6.y,\n          y1 = _ref6.y1;\n      return isPointInRect(px, py, x, x + width, Math.min(y, y1), Math.max(y, y1));\n    });\n    return point ? {\n      point: point.index\n    } : null;\n  };\n}; // TODO: Use actual point size here!\n\n\nvar createScatterHitTester = function createScatterHitTester(coordinates) {\n  return function (_ref7) {\n    var _ref8 = slicedToArray(_ref7, 2),\n        px = _ref8[0],\n        py = _ref8[1];\n\n    var point = coordinates.find(function (_ref9) {\n      var x = _ref9.x,\n          y = _ref9.y;\n      return isPointInRect(px, py, x - 10, x + 10, y - 10, y + 10);\n    });\n    return point ? {\n      point: point.index\n    } : null;\n  };\n};\n\nvar mapAngleTod3 = function mapAngleTod3(angle) {\n  var ret = angle + Math.PI / 2;\n  return ret >= 0 ? ret : ret + Math.PI * 2;\n};\n\nvar createPieHitTester = function createPieHitTester(coordinates) {\n  return function (_ref10) {\n    var _ref11 = slicedToArray(_ref10, 2),\n        px = _ref11[0],\n        py = _ref11[1];\n\n    var point = coordinates.find(function (_ref12) {\n      var x = _ref12.x,\n          y = _ref12.y,\n          innerRadius = _ref12.innerRadius,\n          outerRadius = _ref12.outerRadius,\n          startAngle = _ref12.startAngle,\n          endAngle = _ref12.endAngle;\n      var dx = px - x;\n      var dy = py - y;\n      var r = Math.sqrt(dx * dx + dy * dy);\n\n      if (r < innerRadius || r > outerRadius) {\n        return null;\n      }\n\n      var angle = mapAngleTod3(Math.atan2(dy, dx));\n      return startAngle <= angle && angle <= endAngle;\n    });\n    return point ? {\n      point: point.index\n    } : null;\n  };\n};\n\nvar buildFilter = function buildFilter(targets) {\n  var result = {};\n  targets.forEach(function (_ref13) {\n    var series = _ref13.series,\n        point = _ref13.point;\n    result[series] = result[series] || {\n      points: {}\n    };\n\n    if (point >= 0) {\n      result[series].points[point] = true;\n    } else {\n      result[series].self = true;\n    }\n  });\n  return result;\n};\n\nvar changeSeriesState = function changeSeriesState(seriesList, targets, state) {\n  if (targets.length === 0) {\n    return seriesList;\n  }\n\n  var filter = buildFilter(targets);\n  var matches = 0;\n  var result = seriesList.map(function (seriesItem) {\n    var obj = filter[seriesItem.name];\n\n    if (!obj) {\n      return seriesItem;\n    }\n\n    matches += 1;\n    var props = {};\n\n    if (obj.self) {\n      props.state = state;\n    }\n\n    if (Object.keys(obj.points).length) {\n      props.points = seriesItem.points.map(function (point) {\n        return obj.points[point.index] ? _extends({}, point, {\n          state: state\n        }) : point;\n      });\n    }\n\n    return _extends({}, seriesItem, props);\n  }); // This is to prevent false rerenders.\n\n  return matches > 0 ? result : seriesList;\n};\n\nvar getDefaultLegendItems = function getDefaultLegendItems(series) {\n  return series.map(function (_ref) {\n    var text = _ref.uniqueName,\n        color = _ref.color;\n    return {\n      text: text,\n      color: color\n    };\n  });\n};\n\nvar getPieLegendItems = function getPieLegendItems(series) {\n  return series[0].points.map(function (_ref2) {\n    var text = _ref2.id,\n        color = _ref2.color;\n    return {\n      text: text,\n      color: color\n    };\n  });\n}; // The function supports special case when there is single Pie series.\n// There is no commom way to tell if series is of Pie type -\n// checking `seriesComponent` function name will suffice for now.\n\n\nvar isSinglePieSeriesCase = function isSinglePieSeriesCase(series) {\n  return series.length === 1 && series[0].seriesComponent.name === 'SliceCollection';\n};\n\nvar getLegendItems = function getLegendItems(series) {\n  return (isSinglePieSeriesCase(series) ? getPieLegendItems : getDefaultLegendItems)(series);\n}; // This function is called from event handlers (when DOM is available) -\n// *window* can be accessed safely.\n\n\nvar getEventCoords = function getEventCoords(e) {\n  var _window = window,\n      pageXOffset = _window.pageXOffset,\n      pageYOffset = _window.pageYOffset; // eslint-disable-line no-undef\n\n  var _e$currentTarget$getB = e.currentTarget.getBoundingClientRect(),\n      left = _e$currentTarget$getB.left,\n      top = _e$currentTarget$getB.top;\n\n  return [e.clientX - left - pageXOffset, e.clientY - top - pageYOffset];\n};\n\nvar buildEventHandler = function buildEventHandler(seriesList, handlers) {\n  var hitTesters = null;\n\n  var createHitTesters = function createHitTesters() {\n    var obj = {};\n    seriesList.forEach(function (seriesItem) {\n      obj[seriesItem.symbolName] = seriesItem.createHitTester(seriesItem.points);\n    });\n    return obj;\n  };\n\n  return function (e) {\n    var location = getEventCoords(e);\n    hitTesters = hitTesters || createHitTesters();\n    var targets = [];\n    seriesList.forEach(function (seriesItem) {\n      var status = hitTesters[seriesItem.symbolName](location);\n\n      if (status) {\n        targets.push(_extends({\n          series: seriesItem.name\n        }, status));\n      }\n    });\n    var arg = {\n      location: location,\n      targets: targets\n    };\n    handlers.forEach(function (handler) {\n      return handler(arg);\n    });\n  };\n};\n\nvar buildLeaveEventHandler = function buildLeaveEventHandler(handlers) {\n  return function (e) {\n    var location = getEventCoords(e);\n    var arg = {\n      location: location,\n      targets: []\n    };\n    handlers.forEach(function (handler) {\n      return handler(arg);\n    });\n  };\n};\n\nvar buildEventHandlers = function buildEventHandlers(seriesList, _ref) {\n  var clickHandlers = _ref.clickHandlers,\n      pointerMoveHandlers = _ref.pointerMoveHandlers;\n  var handlers = {};\n\n  if (clickHandlers.length) {\n    handlers.click = buildEventHandler(seriesList, clickHandlers);\n  }\n\n  if (pointerMoveHandlers.length) {\n    handlers.pointermove = buildEventHandler(seriesList, pointerMoveHandlers);\n    handlers.pointerleave = buildLeaveEventHandler(pointerMoveHandlers);\n  }\n\n  return handlers;\n};\n\nvar selectTarget = function selectTarget(targets) {\n  return targets.length > 0 ? targets[targets.length - 1] : null;\n}; // Comparing by reference is not an option as Tracker always sends new objects.\n// On the other side Tracker cannot persist references as it actually operates with simple scalars\n// and constructs objects to provide info in a slightly more suitable way.\n\n\nvar compareTargets = function compareTargets(target1, target2) {\n  return target1 && target2 && target1.series === target2.series && target1.point === target2.point || !target1 && !target2;\n};\n\nvar processPointerMove = function processPointerMove(targets, currentTarget, notify) {\n  var nextTarget = selectTarget(targets);\n\n  if (compareTargets(currentTarget, nextTarget)) {\n    return undefined;\n  }\n\n  if (notify) {\n    notify(nextTarget);\n  }\n\n  return nextTarget;\n}; // It handles the case when point is hovered and series does not contain visual points.\n// Series then knows that it is also hovered and can represent the changed state.\n\n\nvar getHoverTargets = function getHoverTargets(hover) {\n  if (!hover) {\n    return [];\n  }\n\n  return hover.point >= 0 ? [{\n    series: hover.series\n  }, hover] : [hover];\n};\n\nexport { computeExtension, computeDomains, buildScales, bBoxes, axisCoordinates, axesData, dArea, dLine, dSpline, getPiePointTransformer, getAreaPointTransformer, getBarPointTransformer, findSeriesByName, dBar, pointAttributes, addSeries, scaleSeriesPoints, getStackedSeries, getAreaAnimationStyle, getPieAnimationStyle, getScatterAnimationStyle, buildAnimatedStyleGetter, createAreaHitTester, createLineHitTester, createSplineHitTester, createBarHitTester, createScatterHitTester, createPieHitTester, changeSeriesState, createScale, getWidth, getValueDomainName, getLegendItems, buildEventHandlers, processPointerMove, getHoverTargets, HORIZONTAL, VERTICAL, TOP, BOTTOM, LEFT, RIGHT, MIDDLE, END, START, LINEAR, BAND, ARGUMENT_DOMAIN, VALUE_DOMAIN, HOVERED, SELECTED };","map":null,"metadata":{},"sourceType":"module"}