{"ast":null,"code":"/**\n * Bundle of @devexpress/dx-react-chart\n * Generated: 2018-11-07\n * Version: 1.9.0\n * License: https://js.devexpress.com/Licensing\n */\nimport { createElement, PureComponent, Fragment, Component, isValidElement } from 'react';\nimport { array, func, number, node, string, arrayOf, shape, object, oneOfType } from 'prop-types';\nimport { Plugin, Getter, Template, TemplatePlaceholder, TemplateConnector, Sizer, Action, createStateHelper, PluginHost } from '@devexpress/dx-react-core';\nimport { computeDomains, buildScales, scaleSeriesPoints, TOP, BOTTOM, LEFT, RIGHT, bBoxes, findSeriesByName, addSeries, getValueDomainName, ARGUMENT_DOMAIN, getLegendItems, computeExtension, getStackedSeries, buildAnimatedStyleGetter, getAreaAnimationStyle, HOVERED, SELECTED, dArea, getAreaPointTransformer, createAreaHitTester, dBar, getBarPointTransformer, createBarHitTester, dLine, createLineHitTester, getPieAnimationStyle, getPiePointTransformer, createPieHitTester, pointAttributes, getScatterAnimationStyle, createScatterHitTester, dSpline, createSplineHitTester, axisCoordinates, HORIZONTAL, axesData, buildEventHandlers, changeSeriesState, processPointerMove, getHoverTargets } from '@devexpress/dx-chart-core';\nimport { stackOrderNone, stackOffsetDiverging } from 'd3-shape';\n\nvar BasicData = function BasicData(_ref) {\n  var data = _ref.data;\n  return createElement(Plugin, {\n    name: 'Basis'\n  }, createElement(Getter, {\n    name: 'data',\n    value: data\n  }), createElement(Getter, {\n    name: 'series',\n    value: []\n  }), createElement(Getter, {\n    name: 'axes',\n    value: []\n  }), createElement(Getter, {\n    name: 'getAnimatedStyle',\n    value: function value(style) {\n      return style;\n    }\n  }));\n};\n\nprocess.env.NODE_ENV !== \"production\" ? BasicData.propTypes = {\n  data: array.isRequired\n} : void 0;\n\nvar getDomains = function getDomains(_ref) {\n  var axes = _ref.axes,\n      series = _ref.series;\n  return computeDomains(axes, series);\n};\n\nvar getScales = function getScales(_ref2) {\n  var domains = _ref2.domains,\n      layouts = _ref2.layouts,\n      scaleExtension = _ref2.scaleExtension;\n  return buildScales(domains, scaleExtension, layouts.pane);\n};\n\nvar getSeries = function getSeries(_ref3) {\n  var series = _ref3.series,\n      scales = _ref3.scales,\n      stacks = _ref3.stacks,\n      scaleExtension = _ref3.scaleExtension;\n  return scaleSeriesPoints(series, scales, stacks, scaleExtension);\n};\n\nvar ChartCore = function ChartCore() {\n  return createElement(Plugin, null, createElement(Getter, {\n    name: 'domains',\n    computed: getDomains\n  }), createElement(Getter, {\n    name: 'scales',\n    computed: getScales\n  }), createElement(Getter, {\n    name: 'series',\n    computed: getSeries\n  }));\n};\n\nvar AxesLayout = function AxesLayout() {\n  return createElement(Plugin, null, createElement(Template, {\n    name: 'canvas'\n  }, createElement('div', {\n    id: 'center-center',\n    style: {\n      display: 'flex',\n      flexDirection: 'column',\n      flexGrow: 1\n    }\n  }, createElement('div', {\n    id: TOP + '-axis-container',\n    style: {\n      display: 'flex',\n      flexDirection: 'row'\n    }\n  }, createElement(TemplatePlaceholder, {\n    name: TOP + '-' + LEFT + '-axis'\n  }), createElement(TemplatePlaceholder, {\n    name: TOP + '-axis'\n  }), createElement(TemplatePlaceholder, {\n    name: TOP + '-' + RIGHT + '-axis'\n  })), createElement('div', {\n    id: 'center-axis-container',\n    style: {\n      display: 'flex',\n      flexDirection: 'row',\n      flexGrow: 1\n    }\n  }, createElement(TemplatePlaceholder, {\n    name: LEFT + '-axis'\n  }), createElement(TemplatePlaceholder, null), createElement(TemplatePlaceholder, {\n    name: RIGHT + '-axis'\n  })), createElement('div', {\n    id: BOTTOM + '-axis-container',\n    style: {\n      display: 'flex',\n      flexDirection: 'row'\n    }\n  }, createElement(TemplatePlaceholder, {\n    name: BOTTOM + '-' + LEFT + '-axis'\n  }), createElement(TemplatePlaceholder, {\n    name: BOTTOM + '-axis'\n  }), createElement(TemplatePlaceholder, {\n    name: BOTTOM + '-' + RIGHT + '-axis'\n  })))));\n};\n\nvar classCallCheck = function classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar defineProperty = function defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar objectWithoutProperties = function objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar toConsumableArray = function toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nvar SpaceFillingRects = function (_React$PureComponent) {\n  inherits(SpaceFillingRects, _React$PureComponent);\n\n  function SpaceFillingRects() {\n    classCallCheck(this, SpaceFillingRects);\n    return possibleConstructorReturn(this, (SpaceFillingRects.__proto__ || Object.getPrototypeOf(SpaceFillingRects)).apply(this, arguments));\n  }\n\n  createClass(SpaceFillingRects, [{\n    key: 'render',\n    value: function render() {\n      var placeholders = this.props.placeholders;\n      return createElement(Plugin, {\n        name: 'SpaceFillingRects'\n      }, placeholders.map(function (name) {\n        return createElement(Template, {\n          name: name,\n          key: name\n        }, createElement(TemplateConnector, null, function (_ref) {\n          var positions = _ref.layouts;\n\n          var _name$split = name.split('-'),\n              _name$split2 = slicedToArray(_name$split, 3),\n              horizontal = _name$split2[1],\n              postfix = _name$split2[2];\n\n          var _ref2 = positions[horizontal + (postfix ? '-' + postfix : '')] || {},\n              width = _ref2.width;\n\n          return createElement('div', {\n            id: name,\n            style: {\n              width: width\n            }\n          });\n        }));\n      }));\n    }\n  }]);\n  return SpaceFillingRects;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? SpaceFillingRects.propTypes = {\n  placeholders: arrayOf(string).isRequired\n} : void 0;\n/* eslint-disable-next-line react/prefer-stateless-function */\n\nvar PaneLayout = function (_React$PureComponent) {\n  inherits(PaneLayout, _React$PureComponent);\n\n  function PaneLayout(props) {\n    classCallCheck(this, PaneLayout);\n\n    var _this = possibleConstructorReturn(this, (PaneLayout.__proto__ || Object.getPrototypeOf(PaneLayout)).call(this, props));\n\n    _this.state = {\n      width: 800,\n      height: 600\n    };\n    return _this;\n  }\n\n  createClass(PaneLayout, [{\n    key: 'handleSizeUpdate',\n    value: function handleSizeUpdate(_ref, changeBBox) {\n      var width = _ref.width,\n          height = _ref.height;\n      this.setState({\n        width: width,\n        height: height\n      });\n      changeBBox({\n        placeholder: 'pane',\n        bBox: {\n          width: width,\n          height: height\n        }\n      });\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var _state = this.state,\n          width = _state.width,\n          height = _state.height;\n      return createElement(Plugin, {\n        name: 'PaneLayout'\n      }, createElement(Template, {\n        name: 'canvas'\n      }, function (params) {\n        return createElement(TemplateConnector, null, function (_, _ref2) {\n          var changeBBox = _ref2.changeBBox;\n          return createElement(Sizer, {\n            style: {\n              flex: 1,\n              zIndex: 1\n            },\n            onSizeChange: function onSizeChange(size) {\n              return _this2.handleSizeUpdate(size, changeBBox);\n            }\n          }, createElement('div', {\n            style: {\n              width: '100%'\n            }\n          }, createElement('svg', _extends({}, params, {\n            width: width,\n            height: height,\n            style: {\n              position: 'absolute',\n              left: 0,\n              top: 0,\n              overflow: 'visible'\n            }\n          }), createElement(TemplatePlaceholder, {\n            name: 'series'\n          }))));\n        });\n      }));\n    }\n  }]);\n  return PaneLayout;\n}(PureComponent);\n\nvar LayoutManager = function (_React$Component) {\n  inherits(LayoutManager, _React$Component);\n\n  function LayoutManager(props) {\n    classCallCheck(this, LayoutManager);\n\n    var _this = possibleConstructorReturn(this, (LayoutManager.__proto__ || Object.getPrototypeOf(LayoutManager)).call(this, props));\n\n    var _this$props = _this.props,\n        width = _this$props.width,\n        height = _this$props.height;\n    _this.state = {\n      bBoxes: {\n        pane: {\n          width: width,\n          height: height\n        }\n      }\n    };\n    var stateHelper = createStateHelper(_this);\n    _this.changeBBox = stateHelper.applyFieldReducer.bind(stateHelper, 'bBoxes', bBoxes);\n    return _this;\n  }\n\n  createClass(LayoutManager, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          width = _props.width,\n          height = _props.height,\n          Root = _props.rootComponent,\n          restProps = objectWithoutProperties(_props, ['width', 'height', 'rootComponent']);\n      var stateBBoxes = this.state.bBoxes;\n      return createElement(Plugin, null, createElement(Getter, {\n        name: 'layouts',\n        value: stateBBoxes\n      }), createElement(Action, {\n        name: 'changeBBox',\n        action: this.changeBBox\n      }), createElement(Template, {\n        name: 'root'\n      }, createElement(Root, _extends({\n        height: height,\n        width: width\n      }, restProps), createElement(TemplatePlaceholder, {\n        name: 'canvas'\n      }))));\n    }\n  }]);\n  return LayoutManager;\n}(Component);\n\nprocess.env.NODE_ENV !== \"production\" ? LayoutManager.propTypes = {\n  width: number,\n  height: number.isRequired,\n  rootComponent: func.isRequired\n} : void 0;\nLayoutManager.defaultProps = {\n  width: 0\n};\n\nvar ComponentLayout = function ComponentLayout() {\n  return createElement(Plugin, {\n    name: 'ComponentLayout'\n  }, createElement(Template, {\n    name: 'canvas'\n  }, createElement('div', {\n    id: TOP + '-container',\n    style: {\n      display: 'flex',\n      flexDirection: 'row'\n    }\n  }, createElement(TemplatePlaceholder, {\n    name: TOP + '-' + LEFT\n  }), createElement(TemplatePlaceholder, {\n    name: TOP\n  }), createElement(TemplatePlaceholder, {\n    name: TOP + '-' + LEFT\n  })), createElement('div', {\n    id: 'center-container',\n    style: {\n      display: 'flex',\n      flexDirection: 'row',\n      flexGrow: 1\n    }\n  }, createElement(TemplatePlaceholder, {\n    name: LEFT\n  }), createElement(TemplatePlaceholder, null), createElement(TemplatePlaceholder, {\n    name: RIGHT\n  })), createElement('div', {\n    id: BOTTOM + '-container',\n    style: {\n      display: 'flex',\n      flexDirection: 'row'\n    }\n  }, createElement(TemplatePlaceholder, {\n    name: BOTTOM + '-' + LEFT\n  }), createElement(TemplatePlaceholder, {\n    name: BOTTOM\n  }))));\n}; // TODO: Remove \"palette\" getter from BasicData and add Palette to Chart\n// when \"paletteComputing\" is removed.\n\n\nvar Palette = function (_React$PureComponent) {\n  inherits(Palette, _React$PureComponent);\n\n  function Palette() {\n    classCallCheck(this, Palette);\n    return possibleConstructorReturn(this, (Palette.__proto__ || Object.getPrototypeOf(Palette)).apply(this, arguments));\n  }\n\n  createClass(Palette, [{\n    key: 'render',\n    value: function render() {\n      var scheme = this.props.scheme;\n      return createElement(Plugin, {\n        name: 'Palette'\n      }, createElement(Getter, {\n        name: 'palette',\n        value: scheme\n      }));\n    }\n  }]);\n  return Palette;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? Palette.propTypes = {\n  scheme: array.isRequired\n} : void 0;\n\nvar Root = function (_React$PureComponent) {\n  inherits(Root, _React$PureComponent);\n\n  function Root() {\n    classCallCheck(this, Root);\n    return possibleConstructorReturn(this, (Root.__proto__ || Object.getPrototypeOf(Root)).apply(this, arguments));\n  }\n\n  createClass(Root, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          children = _props.children,\n          width = _props.width,\n          height = _props.height,\n          style = _props.style,\n          restProps = objectWithoutProperties(_props, ['children', 'width', 'height', 'style']);\n      return createElement('div', _extends({\n        style: _extends({}, style, {\n          height: height + 'px'\n        }, width ? {\n          width: width + 'px'\n        } : null)\n      }, restProps), children);\n    }\n  }]);\n  return Root;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? Root.propTypes = {\n  children: node,\n  width: number.isRequired,\n  height: number.isRequired,\n  style: object\n} : void 0;\nRoot.defaultProps = {\n  children: undefined,\n  style: undefined\n};\n\nvar Label = function (_React$PureComponent) {\n  inherits(Label, _React$PureComponent);\n\n  function Label() {\n    classCallCheck(this, Label);\n    return possibleConstructorReturn(this, (Label.__proto__ || Object.getPrototypeOf(Label)).apply(this, arguments));\n  }\n\n  createClass(Label, [{\n    key: 'render',\n    value: function render() {\n      return createElement('text', this.props);\n    }\n  }]);\n  return Label;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? Label.propTypes = {\n  children: oneOfType([string, number]).isRequired,\n  x: number.isRequired,\n  y: number.isRequired\n} : void 0;\n\nvar makeBoundComponent = function makeBoundComponent(Target, components, exposed) {\n  var Component$$1 = function (_React$PureComponent) {\n    inherits(Component$$1, _React$PureComponent);\n\n    function Component$$1() {\n      classCallCheck(this, Component$$1);\n      return possibleConstructorReturn(this, (Component$$1.__proto__ || Object.getPrototypeOf(Component$$1)).apply(this, arguments));\n    }\n\n    createClass(Component$$1, [{\n      key: 'render',\n      value: function render() {\n        return createElement(Target, _extends({}, components, this.props));\n      }\n    }]);\n    return Component$$1;\n  }(PureComponent);\n\n  Component$$1.components = Target.components;\n  Object.assign(Component$$1, exposed);\n  return Component$$1;\n};\n\nvar withComponents = function withComponents(components) {\n  return function (Target) {\n    var props = {};\n    var exposed = {};\n    Object.entries(Target.components).forEach(function (_ref) {\n      var _ref2 = slicedToArray(_ref, 2),\n          fieldName = _ref2[0],\n          componentName = _ref2[1];\n\n      var component = components[componentName];\n\n      if (component && component !== Target[componentName]) {\n        props[fieldName] = component;\n      }\n\n      exposed[componentName] = component || Target[componentName];\n    });\n    return Object.keys(props).length > 0 ? makeBoundComponent(Target, props, exposed) : Target;\n  };\n}; // May be it is better to say what props are passed along rather then what are NOT passed?\n\n\nvar getRenderProps = function getRenderProps(series) {\n  var name = series.name,\n      uniqueName = series.uniqueName,\n      axisName = series.axisName,\n      argumentField = series.argumentField,\n      valueField = series.valueField,\n      palette = series.palette,\n      symbolName = series.symbolName,\n      isStartedFromZero = series.isStartedFromZero,\n      getValueDomain = series.getValueDomain,\n      createHitTester = series.createHitTester,\n      restProps = objectWithoutProperties(series, ['name', 'uniqueName', 'axisName', 'argumentField', 'valueField', 'palette', 'symbolName', 'isStartedFromZero', 'getValueDomain', 'createHitTester']);\n  return restProps;\n};\n\nvar declareSeries = function declareSeries(pluginName, _ref) {\n  var components = _ref.components,\n      parameters = objectWithoutProperties(_ref, ['components']);\n\n  var Component$$1 = function (_React$PureComponent) {\n    inherits(Component$$1, _React$PureComponent);\n\n    function Component$$1() {\n      classCallCheck(this, Component$$1);\n      return possibleConstructorReturn(this, (Component$$1.__proto__ || Object.getPrototypeOf(Component$$1)).apply(this, arguments));\n    }\n\n    createClass(Component$$1, [{\n      key: 'render',\n      value: function render() {\n        var name = this.props.name;\n        var symbolName = Symbol(name);\n\n        var seriesItem = _extends({}, parameters, this.props, {\n          symbolName: symbolName\n        });\n\n        var getSeries = function getSeries(_ref2) {\n          var series = _ref2.series,\n              data = _ref2.data,\n              palette = _ref2.palette;\n          return addSeries(series, data, palette, seriesItem);\n        };\n\n        return createElement(Plugin, {\n          name: pluginName\n        }, createElement(Getter, {\n          name: 'series',\n          computed: getSeries\n        }), createElement(Template, {\n          name: 'series'\n        }, createElement(TemplatePlaceholder, null), createElement(TemplateConnector, null, function (_ref3) {\n          var series = _ref3.series,\n              scales = _ref3.scales,\n              getAnimatedStyle = _ref3.getAnimatedStyle;\n          var currentSeries = findSeriesByName(symbolName, series);\n          var currentScales = {\n            xScale: scales[ARGUMENT_DOMAIN],\n            yScale: scales[getValueDomainName(currentSeries.axisName)]\n          };\n\n          var _getRenderProps = getRenderProps(currentSeries),\n              Series = _getRenderProps.seriesComponent,\n              points = _getRenderProps.points,\n              props = objectWithoutProperties(_getRenderProps, ['seriesComponent', 'points']);\n\n          return createElement(Series, _extends({\n            coordinates: points,\n            scales: currentScales,\n            getAnimatedStyle: getAnimatedStyle\n          }, props));\n        })));\n      }\n    }]);\n    return Component$$1;\n  }(PureComponent);\n\n  process.env.NODE_ENV !== \"production\" ? Component$$1.propTypes = {\n    name: string,\n\n    /* eslint-disable react/no-unused-prop-types */\n    valueField: string.isRequired,\n    argumentField: string.isRequired\n    /* eslint-enable react/no-unused-prop-types */\n\n  } : void 0;\n  Component$$1.defaultProps = {\n    name: 'defaultSeriesName'\n  };\n  Component$$1.components = {};\n\n  if (components.Path) {\n    Component$$1.components.seriesComponent = 'Path';\n  }\n\n  if (components.Point) {\n    Component$$1.components.pointComponent = 'Point';\n  }\n\n  return withComponents(components)(Component$$1);\n};\n\nvar withPatchedProps = function withPatchedProps(patch) {\n  return function (Target) {\n    var Component$$1 = function (_React$PureComponent) {\n      inherits(Component$$1, _React$PureComponent);\n\n      function Component$$1() {\n        classCallCheck(this, Component$$1);\n        return possibleConstructorReturn(this, (Component$$1.__proto__ || Object.getPrototypeOf(Component$$1)).apply(this, arguments));\n      }\n\n      createClass(Component$$1, [{\n        key: 'render',\n        value: function render() {\n          var props = patch(this.props);\n          return createElement(Target, props);\n        }\n      }]);\n      return Component$$1;\n    }(PureComponent);\n\n    return Component$$1;\n  };\n};\n\nvar RawChart = function (_React$PureComponent) {\n  inherits(RawChart, _React$PureComponent);\n\n  function RawChart() {\n    classCallCheck(this, RawChart);\n    return possibleConstructorReturn(this, (RawChart.__proto__ || Object.getPrototypeOf(RawChart)).apply(this, arguments));\n  }\n\n  createClass(RawChart, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          data = _props.data,\n          width = _props.width,\n          height = _props.height,\n          children = _props.children,\n          rootComponent = _props.rootComponent,\n          restProps = objectWithoutProperties(_props, ['data', 'width', 'height', 'children', 'rootComponent']);\n      return createElement(PluginHost, null, createElement(BasicData, {\n        data: data\n      }), createElement(Palette, {\n        scheme: []\n      }), createElement(LayoutManager, _extends({\n        width: width,\n        height: height,\n        rootComponent: rootComponent\n      }, restProps)), createElement(PaneLayout, null), createElement(AxesLayout, null), createElement(ComponentLayout, null), createElement(SpaceFillingRects, {\n        placeholders: [TOP + '-' + LEFT, TOP + '-' + RIGHT, BOTTOM + '-' + LEFT, BOTTOM + '-' + RIGHT, TOP + '-' + LEFT + '-axis', TOP + '-' + RIGHT + '-axis', BOTTOM + '-' + LEFT + '-axis', BOTTOM + '-' + RIGHT + '-axis']\n      }), children, createElement(ChartCore, null));\n    }\n  }]);\n  return RawChart;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? RawChart.propTypes = {\n  data: array.isRequired,\n  rootComponent: func.isRequired,\n  width: number,\n  height: number,\n  children: node\n} : void 0;\nRawChart.defaultProps = {\n  height: 500,\n  width: undefined,\n  children: null\n};\nRawChart.components = {\n  rootComponent: 'Root'\n};\nvar Chart = withComponents({\n  Root: Root\n})(RawChart);\nChart.Label = Label;\n\nvar Marker = function (_React$PureComponent) {\n  inherits(Marker, _React$PureComponent);\n\n  function Marker() {\n    classCallCheck(this, Marker);\n    return possibleConstructorReturn(this, (Marker.__proto__ || Object.getPrototypeOf(Marker)).apply(this, arguments));\n  }\n\n  createClass(Marker, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          color = _props.color,\n          restProps = objectWithoutProperties(_props, ['color']);\n      return createElement('svg', _extends({\n        fill: color,\n        width: '10',\n        height: '10'\n      }, restProps), createElement('circle', _extends({\n        r: 5,\n        cx: 5,\n        cy: 5\n      }, restProps)));\n    }\n  }]);\n  return Marker;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? Marker.propTypes = {\n  color: string\n} : void 0;\nMarker.defaultProps = {\n  color: undefined\n};\n\nvar RawLegend = function (_React$PureComponent) {\n  inherits(RawLegend, _React$PureComponent);\n\n  function RawLegend() {\n    classCallCheck(this, RawLegend);\n    return possibleConstructorReturn(this, (RawLegend.__proto__ || Object.getPrototypeOf(RawLegend)).apply(this, arguments));\n  }\n\n  createClass(RawLegend, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          MarkerComponent = _props.markerComponent,\n          Label = _props.labelComponent,\n          Root = _props.rootComponent,\n          Item = _props.itemComponent,\n          position = _props.position,\n          getItems = _props.getItems;\n      var placeholder = position;\n      return createElement(Plugin, {\n        name: 'Legend'\n      }, createElement(Template, {\n        name: placeholder\n      }, createElement(TemplatePlaceholder, null), createElement(TemplateConnector, null, function (getters) {\n        return createElement(Root, {\n          name: 'legend-' + placeholder\n        }, getItems(getters).map(function (_ref) {\n          var text = _ref.text,\n              color = _ref.color;\n          return createElement(Item, {\n            key: text\n          }, createElement(MarkerComponent, {\n            name: text,\n            color: color\n          }), createElement(Label, {\n            text: text\n          }));\n        }));\n      })));\n    }\n  }]);\n  return RawLegend;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? RawLegend.propTypes = {\n  markerComponent: func.isRequired,\n  labelComponent: func.isRequired,\n  rootComponent: func.isRequired,\n  itemComponent: func.isRequired,\n  position: string,\n  getItems: func\n} : void 0;\nRawLegend.defaultProps = {\n  position: 'right',\n  getItems: function getItems(_ref2) {\n    var series = _ref2.series;\n    return getLegendItems(series);\n  }\n};\nRawLegend.components = {\n  rootComponent: 'Root',\n  itemComponent: 'Item',\n  markerComponent: 'Marker',\n  labelComponent: 'Label'\n};\nvar Legend = withComponents({\n  Marker: Marker\n})(RawLegend);\n\nvar Title = function (_React$PureComponent) {\n  inherits(Title, _React$PureComponent);\n\n  function Title() {\n    classCallCheck(this, Title);\n    return possibleConstructorReturn(this, (Title.__proto__ || Object.getPrototypeOf(Title)).apply(this, arguments));\n  }\n\n  createClass(Title, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          Text = _props.textComponent,\n          text = _props.text,\n          position = _props.position,\n          restProps = objectWithoutProperties(_props, ['textComponent', 'text', 'position']);\n      var placeholder = position;\n      return createElement(Plugin, {\n        name: 'Title'\n      }, createElement(Template, {\n        name: placeholder\n      }, createElement(TemplatePlaceholder, null), createElement(Text, _extends({\n        text: text\n      }, restProps))));\n    }\n  }]);\n  return Title;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? Title.propTypes = {\n  textComponent: func.isRequired,\n  text: string.isRequired,\n  position: string\n} : void 0;\nTitle.defaultProps = {\n  position: 'top'\n};\nTitle.components = {\n  textComponent: 'Text'\n};\n\nvar Scale = function (_React$PureComponent) {\n  inherits(Scale, _React$PureComponent);\n\n  function Scale() {\n    classCallCheck(this, Scale);\n    return possibleConstructorReturn(this, (Scale.__proto__ || Object.getPrototypeOf(Scale)).apply(this, arguments));\n  }\n\n  createClass(Scale, [{\n    key: 'render',\n    value: function render() {\n      var extensions = this.props.extensions;\n      return createElement(Plugin, {\n        name: 'Scale'\n      }, createElement(Getter, {\n        name: 'scaleExtension',\n        value: computeExtension(extensions)\n      }));\n    }\n  }]);\n  return Scale;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? Scale.propTypes = {\n  extensions: arrayOf(shape({\n    type: string,\n    constructor: func\n  }))\n} : void 0;\nScale.defaultProps = {\n  extensions: []\n};\n\nvar Stack = function (_React$PureComponent) {\n  inherits(Stack, _React$PureComponent);\n\n  function Stack() {\n    classCallCheck(this, Stack);\n    return possibleConstructorReturn(this, (Stack.__proto__ || Object.getPrototypeOf(Stack)).apply(this, arguments));\n  }\n\n  createClass(Stack, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          stacks = _props.stacks,\n          offset = _props.offset,\n          order = _props.order;\n      var params = {\n        stacks: stacks,\n        offset: offset,\n        order: order\n      };\n\n      var getSeries = function getSeries(_ref) {\n        var series = _ref.series,\n            data = _ref.data;\n        return getStackedSeries(series, data, params);\n      };\n\n      return createElement(Plugin, {\n        name: 'Stack'\n      }, createElement(Getter, {\n        name: 'series',\n        computed: getSeries\n      }));\n    }\n  }]);\n  return Stack;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? Stack.propTypes = {\n  stacks: arrayOf(shape({\n    series: arrayOf(string).isRequired\n  })),\n  offset: func,\n  order: func\n} : void 0;\nStack.defaultProps = {\n  stacks: [],\n  offset: stackOffsetDiverging,\n  order: stackOrderNone\n};\n/* eslint-disable-next-line react/prefer-stateless-function */\n\nvar Animation = function (_React$PureComponent) {\n  inherits(Animation, _React$PureComponent);\n\n  function Animation() {\n    classCallCheck(this, Animation);\n    return possibleConstructorReturn(this, (Animation.__proto__ || Object.getPrototypeOf(Animation)).apply(this, arguments));\n  }\n\n  createClass(Animation, [{\n    key: 'render',\n    value: function render() {\n      return createElement(Plugin, {\n        name: 'Animation'\n      }, createElement(Getter, {\n        name: 'getAnimatedStyle',\n        value: buildAnimatedStyleGetter\n      }));\n    }\n  }]);\n  return Animation;\n}(PureComponent);\n\nvar withStates = function withStates(states) {\n  return function (Component$$1) {\n    var ComponentWithStates = function (_React$PureComponent) {\n      inherits(ComponentWithStates, _React$PureComponent);\n\n      function ComponentWithStates() {\n        classCallCheck(this, ComponentWithStates);\n        return possibleConstructorReturn(this, (ComponentWithStates.__proto__ || Object.getPrototypeOf(ComponentWithStates)).apply(this, arguments));\n      }\n\n      createClass(ComponentWithStates, [{\n        key: 'render',\n        value: function render() {\n          var _props = this.props,\n              state = _props.state,\n              restProps = objectWithoutProperties(_props, ['state']);\n          var stateFunc = states[state];\n          var result = stateFunc ? stateFunc(restProps) : restProps;\n          return isValidElement(result) ? result : createElement(Component$$1, result);\n        }\n      }]);\n      return ComponentWithStates;\n    }(PureComponent);\n\n    process.env.NODE_ENV !== \"production\" ? ComponentWithStates.propTypes = {\n      state: string\n    } : void 0;\n    ComponentWithStates.defaultProps = {\n      state: undefined\n    };\n    return ComponentWithStates;\n  };\n};\n\nvar Pattern = function (_React$PureComponent) {\n  inherits(Pattern, _React$PureComponent);\n\n  function Pattern() {\n    classCallCheck(this, Pattern);\n    return possibleConstructorReturn(this, (Pattern.__proto__ || Object.getPrototypeOf(Pattern)).apply(this, arguments));\n  }\n\n  createClass(Pattern, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          id = _props.id,\n          size = _props.size,\n          color = _props.color,\n          opacity = _props.opacity;\n      return createElement('defs', null, createElement('pattern', {\n        id: id,\n        width: size,\n        height: size,\n        patternUnits: 'userSpaceOnUse'\n      }, createElement('rect', {\n        x: 0,\n        y: 0,\n        width: size,\n        height: size,\n        fill: color,\n        opacity: opacity\n      }), createElement('path', {\n        d: 'M ' + size / 2 + ' ' + -size / 2 + ' L ' + -size / 2 + ' ' + size / 2 + ' M 0 ' + size + ' L ' + size + ' 0 M ' + size * 1.5 + ' ' + size / 2 + ' L ' + size / 2 + ' ' + size * 1.5,\n        strokeWidth: 2,\n        stroke: color\n      })));\n    }\n  }]);\n  return Pattern;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? Pattern.propTypes = {\n  id: string.isRequired,\n  size: number,\n  color: string.isRequired,\n  opacity: number\n} : void 0;\nPattern.defaultProps = {\n  size: 6,\n  opacity: 0.75\n}; // Function is returned (not PureComponent descendant) because\n// result is invoked as function (not as React component).\n\nvar withPattern = function withPattern(getPatternId, props) {\n  return function (Target) {\n    return function (_ref) {\n      var color = _ref.color,\n          restProps = objectWithoutProperties(_ref, ['color']);\n      var patternId = getPatternId(restProps);\n      return createElement(Fragment, null, createElement(Target, _extends({\n        fill: 'url(#' + patternId + ')'\n      }, restProps)), createElement(Pattern, _extends({\n        id: patternId,\n        color: color\n      }, props)));\n    };\n  };\n};\n\nvar _withStates;\n\nvar RawArea = function (_React$PureComponent) {\n  inherits(RawArea, _React$PureComponent);\n\n  function RawArea() {\n    classCallCheck(this, RawArea);\n    return possibleConstructorReturn(this, (RawArea.__proto__ || Object.getPrototypeOf(RawArea)).apply(this, arguments));\n  }\n\n  createClass(RawArea, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          path = _props.path,\n          coordinates = _props.coordinates,\n          color = _props.color,\n          index = _props.index,\n          style = _props.style,\n          getAnimatedStyle = _props.getAnimatedStyle,\n          scales = _props.scales,\n          restProps = objectWithoutProperties(_props, ['path', 'coordinates', 'color', 'index', 'style', 'getAnimatedStyle', 'scales']);\n      return createElement('path', _extends({\n        d: path(coordinates),\n        fill: color,\n        opacity: 0.5,\n        style: getAnimatedStyle(style, getAreaAnimationStyle, scales)\n      }, restProps));\n    }\n  }]);\n  return RawArea;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? RawArea.propTypes = {\n  path: func.isRequired,\n  coordinates: array.isRequired,\n  color: string,\n  style: object\n} : void 0;\nRawArea.defaultProps = {\n  color: undefined,\n  style: undefined\n};\nvar Area = withStates((_withStates = {}, defineProperty(_withStates, HOVERED, withPattern(function (_ref) {\n  var index = _ref.index;\n  return 'series-' + index + '-hover';\n}, {\n  opacity: 0.75\n})(RawArea)), defineProperty(_withStates, SELECTED, withPattern(function (_ref2) {\n  var index = _ref2.index;\n  return 'series-' + index + '-selection';\n}, {\n  opacity: 0.5\n})(RawArea)), _withStates))(RawArea);\nvar AreaSeries = declareSeries('AreaSeries', {\n  components: {\n    Path: Area\n  },\n  path: dArea,\n  isStartedFromZero: true,\n  getPointTransformer: getAreaPointTransformer,\n  createHitTester: createAreaHitTester\n});\n\nvar BarCollection = function (_React$PureComponent) {\n  inherits(BarCollection, _React$PureComponent);\n\n  function BarCollection() {\n    classCallCheck(this, BarCollection);\n    return possibleConstructorReturn(this, (BarCollection.__proto__ || Object.getPrototypeOf(BarCollection)).apply(this, arguments));\n  }\n\n  createClass(BarCollection, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          Point = _props.pointComponent,\n          path = _props.path,\n          coordinates = _props.coordinates,\n          index = _props.index,\n          style = _props.style,\n          scales = _props.scales,\n          getAnimatedStyle = _props.getAnimatedStyle,\n          state = _props.state,\n          restProps = objectWithoutProperties(_props, ['pointComponent', 'path', 'coordinates', 'index', 'style', 'scales', 'getAnimatedStyle', 'state']);\n      return coordinates.map(function (item) {\n        return createElement(Point, _extends({\n          key: item.index.toString(),\n          style: getAnimatedStyle(style, getAreaAnimationStyle, scales),\n          seriesIndex: index\n        }, restProps, dBar(item), item));\n      });\n    }\n  }]);\n  return BarCollection;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? BarCollection.propTypes = {\n  pointComponent: func.isRequired,\n  style: object\n} : void 0;\nBarCollection.defaultProps = {\n  style: undefined\n};\n\nvar _withStates$1;\n\nvar RawBar = function (_React$PureComponent) {\n  inherits(RawBar, _React$PureComponent);\n\n  function RawBar() {\n    classCallCheck(this, RawBar);\n    return possibleConstructorReturn(this, (RawBar.__proto__ || Object.getPrototypeOf(RawBar)).apply(this, arguments));\n  }\n\n  createClass(RawBar, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          argument = _props.argument,\n          value = _props.value,\n          index = _props.index,\n          seriesIndex = _props.seriesIndex,\n          barWidth = _props.barWidth,\n          color = _props.color,\n          restProps = objectWithoutProperties(_props, ['argument', 'value', 'index', 'seriesIndex', 'barWidth', 'color']);\n      return createElement('rect', _extends({\n        fill: color\n      }, restProps));\n    }\n  }]);\n  return RawBar;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? RawBar.propTypes = {\n  x: number.isRequired,\n  y: number.isRequired,\n  width: number.isRequired,\n  height: number.isRequired,\n  value: number.isRequired,\n  color: string\n} : void 0;\nRawBar.defaultProps = {\n  color: undefined\n};\nvar Bar = withStates((_withStates$1 = {}, defineProperty(_withStates$1, HOVERED, withPattern(function (_ref) {\n  var seriesIndex = _ref.seriesIndex,\n      index = _ref.index;\n  return 'series-' + seriesIndex + '-point-' + index + '-hover';\n}, {\n  opacity: 0.75\n})(RawBar)), defineProperty(_withStates$1, SELECTED, withPattern(function (_ref2) {\n  var seriesIndex = _ref2.seriesIndex,\n      index = _ref2.index;\n  return 'series-' + seriesIndex + '-point-' + index + '-selection';\n}, {\n  opacity: 0.5\n})(RawBar)), _withStates$1))(RawBar);\nvar BarSeries = declareSeries('BarSeries', {\n  components: {\n    Path: BarCollection,\n    Point: Bar\n  },\n  isStartedFromZero: true,\n  getPointTransformer: getBarPointTransformer,\n  createHitTester: createBarHitTester\n});\nBarSeries.defaultProps = {\n  barWidth: 0.9\n};\n\nvar _withStates$2;\n\nvar RawPath = function (_React$PureComponent) {\n  inherits(RawPath, _React$PureComponent);\n\n  function RawPath() {\n    classCallCheck(this, RawPath);\n    return possibleConstructorReturn(this, (RawPath.__proto__ || Object.getPrototypeOf(RawPath)).apply(this, arguments));\n  }\n\n  createClass(RawPath, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          path = _props.path,\n          coordinates = _props.coordinates,\n          color = _props.color,\n          index = _props.index,\n          style = _props.style,\n          getAnimatedStyle = _props.getAnimatedStyle,\n          scales = _props.scales,\n          restProps = objectWithoutProperties(_props, ['path', 'coordinates', 'color', 'index', 'style', 'getAnimatedStyle', 'scales']);\n      return createElement('path', _extends({\n        d: path(coordinates),\n        fill: 'none',\n        strokeWidth: 2,\n        stroke: color,\n        style: getAnimatedStyle(style, getAreaAnimationStyle, scales)\n      }, restProps));\n    }\n  }]);\n  return RawPath;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? RawPath.propTypes = {\n  path: func.isRequired,\n  coordinates: array.isRequired,\n  color: string,\n  style: object\n} : void 0;\nRawPath.defaultProps = {\n  color: undefined,\n  style: undefined\n};\nvar Path = withStates((_withStates$2 = {}, defineProperty(_withStates$2, HOVERED, function (props) {\n  return _extends({\n    strokeWidth: 4\n  }, props);\n}), defineProperty(_withStates$2, SELECTED, function (props) {\n  return _extends({\n    strokeWidth: 4\n  }, props);\n}), _withStates$2))(RawPath);\nvar LineSeries = declareSeries('LineSeries', {\n  components: {\n    Path: Path\n  },\n  path: dLine,\n  getPointTransformer: getAreaPointTransformer,\n  createHitTester: createLineHitTester\n}); // TODO: Is it fine to have it hard coded or should there be `path` property?\n\nvar SliceCollection = function (_React$PureComponent) {\n  inherits(SliceCollection, _React$PureComponent);\n\n  function SliceCollection() {\n    classCallCheck(this, SliceCollection);\n    return possibleConstructorReturn(this, (SliceCollection.__proto__ || Object.getPrototypeOf(SliceCollection)).apply(this, arguments));\n  }\n\n  createClass(SliceCollection, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          Point = _props.pointComponent,\n          path = _props.path,\n          coordinates = _props.coordinates,\n          index = _props.index,\n          uniqueName = _props.uniqueName,\n          style = _props.style,\n          getAnimatedStyle = _props.getAnimatedStyle,\n          scales = _props.scales,\n          innerRadius = _props.innerRadius,\n          outerRadius = _props.outerRadius,\n          state = _props.state,\n          restProps = objectWithoutProperties(_props, ['pointComponent', 'path', 'coordinates', 'index', 'uniqueName', 'style', 'getAnimatedStyle', 'scales', 'innerRadius', 'outerRadius', 'state']);\n      return createElement('g', {\n        transform: 'translate(' + coordinates[0].x + ' ' + coordinates[0].y + ')'\n      }, coordinates.map(function (item) {\n        return createElement(Point, _extends({\n          key: item.index.toString(),\n          style: getAnimatedStyle(style, getPieAnimationStyle, scales, item),\n          seriesIndex: index\n        }, restProps, item));\n      }));\n    }\n  }]);\n  return SliceCollection;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? SliceCollection.propTypes = {\n  pointComponent: func.isRequired,\n  style: object\n} : void 0;\nSliceCollection.defaultProps = {\n  style: undefined\n};\n\nvar _withStates$3;\n\nvar RawSlice = function (_React$PureComponent) {\n  inherits(RawSlice, _React$PureComponent);\n\n  function RawSlice() {\n    classCallCheck(this, RawSlice);\n    return possibleConstructorReturn(this, (RawSlice.__proto__ || Object.getPrototypeOf(RawSlice)).apply(this, arguments));\n  }\n\n  createClass(RawSlice, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          argument = _props.argument,\n          value = _props.value,\n          index = _props.index,\n          seriesIndex = _props.seriesIndex,\n          innerRadius = _props.innerRadius,\n          outerRadius = _props.outerRadius,\n          startAngle = _props.startAngle,\n          endAngle = _props.endAngle,\n          x = _props.x,\n          y = _props.y,\n          d = _props.d,\n          color = _props.color,\n          restProps = objectWithoutProperties(_props, ['argument', 'value', 'index', 'seriesIndex', 'innerRadius', 'outerRadius', 'startAngle', 'endAngle', 'x', 'y', 'd', 'color']);\n      return createElement('path', _extends({\n        fill: color,\n        stroke: 'none',\n        d: d\n      }, restProps));\n    }\n  }]);\n  return RawSlice;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? RawSlice.propTypes = {\n  x: number.isRequired,\n  y: number.isRequired,\n  d: string.isRequired,\n  value: number.isRequired,\n  style: object,\n  color: string\n} : void 0;\nRawSlice.defaultProps = {\n  style: {},\n  color: undefined\n};\nvar Slice = withStates((_withStates$3 = {}, defineProperty(_withStates$3, HOVERED, withPattern(function (_ref) {\n  var seriesIndex = _ref.seriesIndex,\n      index = _ref.index;\n  return 'series-' + seriesIndex + '-point-' + index + '-hover';\n}, {\n  opacity: 0.75\n})(RawSlice)), defineProperty(_withStates$3, SELECTED, withPattern(function (_ref2) {\n  var seriesIndex = _ref2.seriesIndex,\n      index = _ref2.index;\n  return 'series-' + seriesIndex + '-point-' + index + '-selection';\n}, {\n  opacity: 0.5\n})(RawSlice)), _withStates$3))(RawSlice);\nvar PieSeries = declareSeries('PieSeries', {\n  components: {\n    Path: SliceCollection,\n    Point: Slice\n  },\n  getPointTransformer: getPiePointTransformer,\n  createHitTester: createPieHitTester\n});\n\nvar PointCollection = function (_React$PureComponent) {\n  inherits(PointCollection, _React$PureComponent);\n\n  function PointCollection() {\n    classCallCheck(this, PointCollection);\n    return possibleConstructorReturn(this, (PointCollection.__proto__ || Object.getPrototypeOf(PointCollection)).apply(this, arguments));\n  }\n\n  createClass(PointCollection, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          Point = _props.pointComponent,\n          path = _props.path,\n          coordinates = _props.coordinates,\n          _props$point = _props.point,\n          point = _props$point === undefined ? {} : _props$point,\n          style = _props.style,\n          getAnimatedStyle = _props.getAnimatedStyle,\n          scales = _props.scales,\n          state = _props.state,\n          restProps = objectWithoutProperties(_props, ['pointComponent', 'path', 'coordinates', 'point', 'style', 'getAnimatedStyle', 'scales', 'state']);\n      var getAttributes = pointAttributes(point);\n      return coordinates.map(function (item) {\n        return createElement(Point, _extends({\n          key: item.index.toString(),\n          style: getAnimatedStyle(style, getScatterAnimationStyle, scales)\n        }, restProps, getAttributes(item), item));\n      });\n    }\n  }]);\n  return PointCollection;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? PointCollection.propTypes = {\n  pointComponent: func.isRequired,\n  style: object\n} : void 0;\nPointCollection.defaultProps = {\n  style: undefined\n};\n\nvar _withStates$4;\n\nvar RawPoint = function (_React$PureComponent) {\n  inherits(RawPoint, _React$PureComponent);\n\n  function RawPoint() {\n    classCallCheck(this, RawPoint);\n    return possibleConstructorReturn(this, (RawPoint.__proto__ || Object.getPrototypeOf(RawPoint)).apply(this, arguments));\n  }\n\n  createClass(RawPoint, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          argument = _props.argument,\n          value = _props.value,\n          index = _props.index,\n          x = _props.x,\n          y = _props.y,\n          color = _props.color,\n          restProps = objectWithoutProperties(_props, ['argument', 'value', 'index', 'x', 'y', 'color']); // *d* attribute is calculated during points scaling.\n      // TODO: Do it here - d={path().size(size).type(type)()}\n\n      return createElement('path', _extends({\n        fill: color,\n        stroke: 'none',\n        transform: 'translate(' + x + ' ' + y + ')'\n      }, restProps));\n    }\n  }]);\n  return RawPoint;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? RawPoint.propTypes = {\n  x: number.isRequired,\n  y: number.isRequired,\n  value: number.isRequired,\n  color: string\n} : void 0;\nRawPoint.defaultProps = {\n  color: undefined\n};\nvar Point = withStates((_withStates$4 = {}, defineProperty(_withStates$4, HOVERED, function (_ref) {\n  var color = _ref.color,\n      restProps = objectWithoutProperties(_ref, ['color']);\n  return _extends({\n    stroke: color,\n    strokeWidth: 4,\n    fill: 'none'\n  }, restProps);\n}), defineProperty(_withStates$4, SELECTED, function (_ref2) {\n  var color = _ref2.color,\n      restProps = objectWithoutProperties(_ref2, ['color']);\n  return _extends({\n    stroke: color,\n    strokeWidth: 4,\n    fill: 'none'\n  }, restProps);\n}), _withStates$4))(RawPoint);\nvar ScatterSeries = declareSeries('ScatterSeries', {\n  components: {\n    Path: PointCollection,\n    Point: Point\n  },\n  getPointTransformer: getAreaPointTransformer,\n  createHitTester: createScatterHitTester\n});\nvar SplineSeries = declareSeries('SplineSeries', {\n  components: {\n    Path: Path\n  },\n  path: dSpline,\n  getPointTransformer: getAreaPointTransformer,\n  createHitTester: createSplineHitTester\n});\n\nvar Root$1 = function (_React$PureComponent) {\n  inherits(Root, _React$PureComponent);\n\n  function Root() {\n    classCallCheck(this, Root);\n    return possibleConstructorReturn(this, (Root.__proto__ || Object.getPrototypeOf(Root)).apply(this, arguments));\n  }\n\n  createClass(Root, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          x = _props.x,\n          y = _props.y,\n          refsHandler = _props.refsHandler,\n          children = _props.children,\n          restProps = objectWithoutProperties(_props, ['x', 'y', 'refsHandler', 'children']);\n      return createElement('g', _extends({\n        ref: refsHandler,\n        transform: 'translate(' + x + ' ' + y + ')'\n      }, restProps), children);\n    }\n  }]);\n  return Root;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? Root$1.propTypes = {\n  x: number.isRequired,\n  y: number.isRequired,\n  refsHandler: func.isRequired,\n  children: node.isRequired\n} : void 0;\n\nvar Tick = function (_React$PureComponent) {\n  inherits(Tick, _React$PureComponent);\n\n  function Tick() {\n    classCallCheck(this, Tick);\n    return possibleConstructorReturn(this, (Tick.__proto__ || Object.getPrototypeOf(Tick)).apply(this, arguments));\n  }\n\n  createClass(Tick, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          x1 = _props.x1,\n          x2 = _props.x2,\n          y1 = _props.y1,\n          y2 = _props.y2,\n          restProps = objectWithoutProperties(_props, ['x1', 'x2', 'y1', 'y2']);\n      return createElement('path', _extends({\n        d: 'M ' + x1 + ' ' + y1 + ' L ' + x2 + ' ' + y2\n      }, restProps));\n    }\n  }]);\n  return Tick;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? Tick.propTypes = {\n  x1: number.isRequired,\n  x2: number.isRequired,\n  y1: number.isRequired,\n  y2: number.isRequired\n} : void 0;\n\nvar Label$1 = function (_React$PureComponent) {\n  inherits(Label, _React$PureComponent);\n\n  function Label() {\n    classCallCheck(this, Label);\n    return possibleConstructorReturn(this, (Label.__proto__ || Object.getPrototypeOf(Label)).apply(this, arguments));\n  }\n\n  createClass(Label, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          text = _props.text,\n          x = _props.x,\n          y = _props.y,\n          dominantBaseline = _props.dominantBaseline,\n          textAnchor = _props.textAnchor,\n          restProps = objectWithoutProperties(_props, ['text', 'x', 'y', 'dominantBaseline', 'textAnchor']);\n      return createElement('text', _extends({\n        dominantBaseline: dominantBaseline,\n        textAnchor: textAnchor,\n        x: x,\n        y: y\n      }, restProps), text);\n    }\n  }]);\n  return Label;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? Label$1.propTypes = {\n  text: oneOfType([string, number]).isRequired,\n  x: number.isRequired,\n  y: number.isRequired,\n  dominantBaseline: string.isRequired,\n  textAnchor: string.isRequired\n} : void 0;\n\nvar Line = function (_React$PureComponent) {\n  inherits(Line, _React$PureComponent);\n\n  function Line() {\n    classCallCheck(this, Line);\n    return possibleConstructorReturn(this, (Line.__proto__ || Object.getPrototypeOf(Line)).apply(this, arguments));\n  }\n\n  createClass(Line, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          width = _props.width,\n          height = _props.height,\n          orientation = _props.orientation,\n          restProps = objectWithoutProperties(_props, ['width', 'height', 'orientation']);\n      return createElement('path', _extends({\n        d: 'M 0 0 L ' + (orientation === 'horizontal' ? width : 0) + ' ' + (orientation === 'horizontal' ? 0 : height)\n      }, restProps));\n    }\n  }]);\n  return Line;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? Line.propTypes = {\n  width: number.isRequired,\n  height: number.isRequired,\n  orientation: string.isRequired\n} : void 0;\n\nvar getZeroCoord = function getZeroCoord() {\n  return 0;\n};\n\nvar getCorrectSize = function getCorrectSize(position) {\n  return position === 'left' || position === 'top' ? function (coord) {\n    return -coord;\n  } : function (coord, side) {\n    return side + coord;\n  };\n};\n\nvar getCorrection = function getCorrection(position) {\n  return position === 'left' || position === 'top' ? function (coord) {\n    return coord;\n  } : getZeroCoord;\n};\n\nvar getCurrentSize = function getCurrentSize(_, side) {\n  return side;\n};\n\nvar RawAxis = function (_React$PureComponent) {\n  inherits(RawAxis, _React$PureComponent);\n\n  function RawAxis(props) {\n    classCallCheck(this, RawAxis);\n\n    var _this = possibleConstructorReturn(this, (RawAxis.__proto__ || Object.getPrototypeOf(RawAxis)).call(this, props));\n\n    _this.state = {\n      xCorrection: 0,\n      yCorrection: 0\n    };\n    _this.createRefsHandler = _this.createRefsHandler.bind(_this);\n    return _this;\n  }\n\n  createClass(RawAxis, [{\n    key: 'createRefsHandler',\n    value: function createRefsHandler(placeholder, changeBBox, _ref) {\n      var _this2 = this;\n\n      var getWidth = _ref.getWidth,\n          getHeight = _ref.getHeight,\n          getXCorrection = _ref.getXCorrection,\n          getYCorrection = _ref.getYCorrection;\n      return function (el) {\n        if (!el) {\n          return;\n        }\n\n        var _el$getBBox = el.getBBox(),\n            width = _el$getBBox.width,\n            height = _el$getBBox.height,\n            x = _el$getBBox.x,\n            y = _el$getBBox.y;\n\n        var _state = _this2.state,\n            stateWidth = _state.width,\n            stateHeight = _state.height;\n        if (width === stateWidth && height === stateHeight) return;\n        changeBBox({\n          placeholder: placeholder,\n          bBox: {\n            width: getWidth(x, width),\n            height: getHeight(y, height)\n          }\n        });\n\n        _this2.setState({\n          width: width,\n          height: height,\n          xCorrection: getXCorrection(x),\n          yCorrection: getYCorrection(y)\n        });\n      };\n    }\n  }, {\n    key: 'calculateLayout',\n    value: function calculateLayout(width, height, defaultWidth, defaultHeight) {\n      var calculatedWidth = width || defaultWidth;\n      var calculatedHeight = height || defaultHeight;\n\n      var _ref2 = this.node && this.node.getBoundingClientRect() || {},\n          containerWidth = _ref2.width,\n          containerHeight = _ref2.height;\n\n      return {\n        width: containerWidth || calculatedWidth,\n        height: containerHeight || calculatedHeight\n      };\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this3 = this;\n\n      var _props = this.props,\n          tickSize = _props.tickSize,\n          position = _props.position,\n          name = _props.name,\n          indentFromAxis = _props.indentFromAxis,\n          RootComponent = _props.rootComponent,\n          TickComponent = _props.tickComponent,\n          LabelComponent = _props.labelComponent,\n          LineComponent = _props.lineComponent;\n\n      var getAxes = function getAxes(_ref3) {\n        var axes = _ref3.axes;\n        return axesData(axes, _this3.props);\n      };\n\n      return createElement(Plugin, {\n        name: 'Axis'\n      }, createElement(Getter, {\n        name: 'axes',\n        computed: getAxes\n      }), createElement(Template, {\n        name: position + '-axis'\n      }, createElement(TemplatePlaceholder, null), createElement(TemplateConnector, null, function (_ref4, _ref5) {\n        var domains = _ref4.domains,\n            scales = _ref4.scales,\n            layouts = _ref4.layouts;\n        var changeBBox = _ref5.changeBBox; // TODO: Take axis from \"axes\" getter rather then from closure.\n\n        var placeholder = position + '-axis';\n        var domain = domains[name];\n        var scale = scales[name]; // TODO_DEBUG\n\n        if (!domain) {\n          throw new Error('domain is not found: ' + name);\n        } // TODO_DEBUG\n\n\n        var orientation = domain.orientation;\n\n        var _ref6 = layouts[placeholder] || {\n          width: 0,\n          height: 0\n        },\n            widthCalculated = _ref6.width,\n            heightCalculated = _ref6.height;\n\n        var _calculateLayout = _this3.calculateLayout(widthCalculated, heightCalculated, 0, 0),\n            widthPostCalculated = _calculateLayout.width,\n            heightPostCalculated = _calculateLayout.height; // Isn't it too late to adjust sizes?\n\n\n        var postCalculatedScale = scale.copy().range(orientation === HORIZONTAL ? [0, widthPostCalculated] : [heightPostCalculated, 0]);\n        var coordinates = axisCoordinates( // TODO: Only *orientation* and *tickFormat* are taken from *domain* -\n        // take *tickFormat* directly from props.\n        domain, postCalculatedScale, position, tickSize, indentFromAxis);\n        var _state2 = _this3.state,\n            xCorrection = _state2.xCorrection,\n            yCorrection = _state2.yCorrection;\n        return createElement('div', {\n          style: {\n            position: 'relative',\n            width: orientation === HORIZONTAL ? undefined : widthCalculated,\n            height: orientation === HORIZONTAL ? heightCalculated : null,\n            flexGrow: orientation === HORIZONTAL ? 1 : undefined\n          },\n          ref: function ref(node$$1) {\n            _this3.node = node$$1;\n          }\n        }, createElement('svg', {\n          width: widthPostCalculated,\n          height: heightPostCalculated,\n          style: {\n            position: 'absolute',\n            left: 0,\n            top: 0,\n            overflow: 'visible'\n          }\n        }, createElement(RootComponent, {\n          refsHandler: _this3.createRefsHandler(placeholder, changeBBox, {\n            getWidth: orientation !== HORIZONTAL ? getCorrectSize(position) : getCurrentSize,\n            getHeight: orientation === HORIZONTAL ? getCorrectSize(position) : getCurrentSize,\n            getXCorrection: orientation !== HORIZONTAL ? getCorrection(position) : getZeroCoord,\n            getYCorrection: orientation === HORIZONTAL ? getCorrection(position) : getZeroCoord\n          }),\n          x: -xCorrection,\n          y: -yCorrection\n        }, coordinates.ticks.map(function (_ref7) {\n          var x1 = _ref7.x1,\n              x2 = _ref7.x2,\n              y1 = _ref7.y1,\n              y2 = _ref7.y2,\n              key = _ref7.key;\n          return createElement(TickComponent, {\n            key: key,\n            x1: x1,\n            x2: x2,\n            y1: y1,\n            y2: y2\n          });\n        }), createElement(LineComponent, {\n          width: widthPostCalculated,\n          height: heightPostCalculated,\n          orientation: orientation\n        }), coordinates.ticks.map(function (_ref8) {\n          var text = _ref8.text,\n              xText = _ref8.xText,\n              yText = _ref8.yText,\n              dominantBaseline = _ref8.dominantBaseline,\n              textAnchor = _ref8.textAnchor,\n              key = _ref8.key;\n          return createElement(Fragment, {\n            key: key\n          }, createElement(LabelComponent, {\n            text: text,\n            x: xText,\n            y: yText,\n            dominantBaseline: dominantBaseline,\n            textAnchor: textAnchor\n          }));\n        }))));\n      })));\n    }\n  }]);\n  return RawAxis;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? RawAxis.propTypes = {\n  name: string.isRequired,\n  rootComponent: func.isRequired,\n  tickComponent: func.isRequired,\n  labelComponent: func.isRequired,\n  lineComponent: func.isRequired,\n  position: string.isRequired,\n  tickSize: number,\n  indentFromAxis: number\n} : void 0;\nRawAxis.defaultProps = {\n  tickSize: 5,\n  indentFromAxis: 10\n};\nRawAxis.components = {\n  rootComponent: 'Root',\n  tickComponent: 'Tick',\n  labelComponent: 'Label',\n  lineComponent: 'Line'\n};\nvar Axis = withComponents({\n  Root: Root$1,\n  Tick: Tick,\n  Label: Label$1,\n  Line: Line\n})(RawAxis); // TODO: It is not axis who defines that argument is HORIZONTAL and value is VERTICAL.\n// TODO: Check that only BOTTOM and TOP are accepted.\n\nvar ArgumentAxis = withPatchedProps(function (props) {\n  return _extends({\n    position: BOTTOM\n  }, props, {\n    name: ARGUMENT_DOMAIN\n  });\n})(Axis); // TODO: Check that only LEFT and RIGHT are accepted.\n\nvar ValueAxis = withPatchedProps(function (props) {\n  return _extends({\n    position: LEFT\n  }, props, {\n    name: getValueDomainName(props.name)\n  });\n})(Axis);\nArgumentAxis.components = Axis.components;\nValueAxis.components = Axis.components;\n\nvar Line$1 = function (_React$PureComponent) {\n  inherits(Line, _React$PureComponent);\n\n  function Line() {\n    classCallCheck(this, Line);\n    return possibleConstructorReturn(this, (Line.__proto__ || Object.getPrototypeOf(Line)).apply(this, arguments));\n  }\n\n  createClass(Line, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          x1 = _props.x1,\n          x2 = _props.x2,\n          y1 = _props.y1,\n          y2 = _props.y2,\n          restProps = objectWithoutProperties(_props, ['x1', 'x2', 'y1', 'y2']);\n      return createElement('path', _extends({\n        d: 'M ' + x1 + ' ' + y1 + ' L ' + x2 + ' ' + y2\n      }, restProps));\n    }\n  }]);\n  return Line;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? Line$1.propTypes = {\n  x1: number.isRequired,\n  x2: number.isRequired,\n  y1: number.isRequired,\n  y2: number.isRequired\n} : void 0;\n\nvar RawGrid = function (_React$PureComponent) {\n  inherits(RawGrid, _React$PureComponent);\n\n  function RawGrid() {\n    classCallCheck(this, RawGrid);\n    return possibleConstructorReturn(this, (RawGrid.__proto__ || Object.getPrototypeOf(RawGrid)).apply(this, arguments));\n  }\n\n  createClass(RawGrid, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          name = _props.name,\n          LineComponent = _props.lineComponent,\n          restProps = objectWithoutProperties(_props, ['name', 'lineComponent']);\n      return createElement(Plugin, {\n        name: 'Grid'\n      }, createElement(Template, {\n        name: 'series'\n      }, createElement(TemplatePlaceholder, null), createElement(TemplateConnector, null, function (_ref) {\n        var domains = _ref.domains,\n            scales = _ref.scales,\n            layouts = _ref.layouts;\n        var domain = domains[name];\n        var scale = scales[name];\n        var orientation = domain.orientation;\n        var _layouts$pane = layouts.pane,\n            width = _layouts$pane.width,\n            height = _layouts$pane.height;\n        var coordinates = axisCoordinates(domain, scale, orientation === HORIZONTAL ? TOP : LEFT, 0, undefined);\n        return createElement(Fragment, null, coordinates.ticks.map(function (_ref2) {\n          var x1 = _ref2.x1,\n              x2 = _ref2.x2,\n              y1 = _ref2.y1,\n              y2 = _ref2.y2,\n              key = _ref2.key;\n          return createElement(LineComponent, _extends({\n            key: key,\n            x1: orientation === HORIZONTAL ? x1 : width,\n            x2: x2,\n            y1: orientation === HORIZONTAL ? height : y1,\n            y2: y2\n          }, restProps));\n        }));\n      })));\n    }\n  }]);\n  return RawGrid;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? RawGrid.propTypes = {\n  name: string.isRequired,\n  lineComponent: func.isRequired\n} : void 0;\nRawGrid.components = {\n  lineComponent: 'Line'\n};\nvar Grid = withComponents({\n  Line: Line$1\n})(RawGrid);\nvar ArgumentGrid = withPatchedProps(function (props) {\n  return _extends({}, props, {\n    name: ARGUMENT_DOMAIN\n  });\n})(Grid);\nvar ValueGrid = withPatchedProps(function (props) {\n  return _extends({}, props, {\n    name: getValueDomainName(props.name)\n  });\n})(Grid);\nArgumentGrid.components = Grid.components;\nValueGrid.components = Grid.components;\n\nvar wrapToList = function wrapToList(arg) {\n  return arg ? [arg] : [];\n};\n\nvar EVENT_NAME_MAP = {\n  click: 'onClick',\n  pointermove: 'onPointerMove',\n  pointerleave: 'onPointerLeave'\n};\n\nvar translateEventNames = function translateEventNames(handlers) {\n  var result = {};\n  Object.entries(handlers).forEach(function (_ref) {\n    var _ref2 = slicedToArray(_ref, 2),\n        name = _ref2[0],\n        handler = _ref2[1];\n\n    result[EVENT_NAME_MAP[name]] = handler;\n  });\n  return result;\n}; // eslint-disable-next-line react/no-multi-comp\n\n\nvar EventTracker = function (_React$PureComponent) {\n  inherits(EventTracker, _React$PureComponent);\n\n  function EventTracker() {\n    classCallCheck(this, EventTracker);\n    return possibleConstructorReturn(this, (EventTracker.__proto__ || Object.getPrototypeOf(EventTracker)).apply(this, arguments));\n  }\n\n  createClass(EventTracker, [{\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          onClick = _props.onClick,\n          onPointerMove = _props.onPointerMove;\n      return createElement(Plugin, {\n        name: 'EventTracker'\n      }, createElement(Getter, {\n        name: 'clickHandlers',\n        value: wrapToList(onClick)\n      }), createElement(Getter, {\n        name: 'pointerMoveHandlers',\n        value: wrapToList(onPointerMove)\n      }), createElement(Template, {\n        name: 'canvas'\n      }, createElement(TemplateConnector, null, function (_ref3) {\n        var series = _ref3.series,\n            clickHandlers = _ref3.clickHandlers,\n            pointerMoveHandlers = _ref3.pointerMoveHandlers;\n        var handlers = buildEventHandlers(series, {\n          clickHandlers: clickHandlers,\n          pointerMoveHandlers: pointerMoveHandlers\n        });\n        return createElement(TemplatePlaceholder, {\n          params: translateEventNames(handlers)\n        });\n      })));\n    }\n  }]);\n  return EventTracker;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? EventTracker.propTypes = {\n  onClick: func,\n  onPointerMove: func\n} : void 0;\nEventTracker.defaultProps = {\n  onClick: undefined,\n  onPointerMove: undefined\n};\n\nvar HoverState = function (_React$PureComponent) {\n  inherits(HoverState, _React$PureComponent);\n\n  function HoverState(props) {\n    classCallCheck(this, HoverState);\n\n    var _this = possibleConstructorReturn(this, (HoverState.__proto__ || Object.getPrototypeOf(HoverState)).call(this, props));\n\n    _this.state = {\n      hover: props.hover || props.defaultHover\n    };\n\n    var handlePointerMove = _this.handlePointerMove.bind(_this);\n\n    _this.getPointerMoveHandlers = function (_ref) {\n      var pointerMoveHandlers = _ref.pointerMoveHandlers;\n      return [].concat(toConsumableArray(pointerMoveHandlers), [handlePointerMove]);\n    };\n\n    return _this;\n  }\n\n  createClass(HoverState, [{\n    key: 'handlePointerMove',\n    value: function handlePointerMove(_ref2) {\n      var targets = _ref2.targets;\n      var onHoverChange = this.props.onHoverChange;\n      var currentTarget = this.state.hover;\n      var hover = processPointerMove(targets, currentTarget, onHoverChange);\n\n      if (hover !== undefined) {\n        this.setState({\n          hover: hover\n        });\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var hover = this.state.hover; // Function has to be recreated every time as there is no other way\n      // to notify that \"series\" is updated.\n\n      var getSeries = function getSeries(_ref3) {\n        var series = _ref3.series;\n        return changeSeriesState(series, getHoverTargets(hover), HOVERED);\n      };\n\n      return createElement(Plugin, {\n        name: 'HoverState'\n      }, createElement(Getter, {\n        name: 'pointerMoveHandlers',\n        computed: this.getPointerMoveHandlers\n      }), createElement(Getter, {\n        name: 'series',\n        computed: getSeries\n      }));\n    }\n  }], [{\n    key: 'getDerivedStateFromProps',\n    value: function getDerivedStateFromProps(props, state) {\n      return {\n        hover: props.hover !== undefined ? props.hover : state.hover\n      };\n    }\n  }]);\n  return HoverState;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? HoverState.propTypes = {\n  defaultHover: shape({\n    series: string.isRequired,\n    point: number\n  }),\n  hover: shape({\n    series: string.isRequired,\n    point: number\n  }),\n  onHoverChange: func\n} : void 0;\nHoverState.defaultProps = {\n  defaultHover: undefined,\n  hover: undefined,\n  onHoverChange: undefined\n};\n\nvar SelectionState = function (_React$PureComponent) {\n  inherits(SelectionState, _React$PureComponent);\n\n  function SelectionState() {\n    classCallCheck(this, SelectionState);\n    return possibleConstructorReturn(this, (SelectionState.__proto__ || Object.getPrototypeOf(SelectionState)).apply(this, arguments));\n  }\n\n  createClass(SelectionState, [{\n    key: 'render',\n    value: function render() {\n      var selection = this.props.selection;\n\n      var getSeries = function getSeries(_ref) {\n        var series = _ref.series;\n        return changeSeriesState(series, selection, SELECTED);\n      };\n\n      return createElement(Plugin, {\n        name: 'SelectionState'\n      }, createElement(Getter, {\n        name: 'series',\n        computed: getSeries\n      }));\n    }\n  }]);\n  return SelectionState;\n}(PureComponent);\n\nprocess.env.NODE_ENV !== \"production\" ? SelectionState.propTypes = {\n  selection: arrayOf(shape({\n    series: string.isRequired,\n    point: number\n  }))\n} : void 0;\nSelectionState.defaultProps = {\n  selection: []\n};\nexport { Chart, Legend, Title, Scale, Stack, Palette, Animation, AreaSeries, BarSeries, LineSeries, PieSeries, ScatterSeries, SplineSeries, Axis, ArgumentAxis, ValueAxis, Grid, ArgumentGrid, ValueGrid, withPatchedProps, withComponents, EventTracker, HoverState, SelectionState };","map":null,"metadata":{},"sourceType":"module"}