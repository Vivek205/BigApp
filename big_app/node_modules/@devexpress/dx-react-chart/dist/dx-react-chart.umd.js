/**
 * Bundle of @devexpress/dx-react-chart
 * Generated: 2018-11-07
 * Version: 1.9.0
 * License: https://js.devexpress.com/Licensing
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('prop-types'), require('@devexpress/dx-react-core'), require('@devexpress/dx-chart-core'), require('d3-shape')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'prop-types', '@devexpress/dx-react-core', '@devexpress/dx-chart-core', 'd3-shape'], factory) :
  (factory((global.DevExpress = global.DevExpress || {}, global.DevExpress.DXReactChart = {}),global.React,global.PropTypes,global.DevExpress.DXReactCore,global.DevExpress.DXChartCore,global.d3Shape));
}(this, (function (exports,React,PropTypes,dxReactCore,dxChartCore,d3Shape) { 'use strict';

  if (typeof process === "undefined") { var process = { env: {} }; }

  var BasicData = function BasicData(_ref) {
    var data = _ref.data;
    return React.createElement(
      dxReactCore.Plugin,
      { name: 'Basis' },
      React.createElement(dxReactCore.Getter, { name: 'data', value: data }),
      React.createElement(dxReactCore.Getter, { name: 'series', value: [] }),
      React.createElement(dxReactCore.Getter, { name: 'axes', value: [] }),
      React.createElement(dxReactCore.Getter, { name: 'getAnimatedStyle', value: function value(style) {
          return style;
        } })
    );
  };

  process.env.NODE_ENV !== "production" ? BasicData.propTypes = {
    data: PropTypes.array.isRequired
  } : void 0;

  var getDomains = function getDomains(_ref) {
    var axes = _ref.axes,
        series = _ref.series;
    return dxChartCore.computeDomains(axes, series);
  };

  var getScales = function getScales(_ref2) {
    var domains = _ref2.domains,
        layouts = _ref2.layouts,
        scaleExtension = _ref2.scaleExtension;
    return dxChartCore.buildScales(domains, scaleExtension, layouts.pane);
  };

  var getSeries = function getSeries(_ref3) {
    var series = _ref3.series,
        scales = _ref3.scales,
        stacks = _ref3.stacks,
        scaleExtension = _ref3.scaleExtension;
    return dxChartCore.scaleSeriesPoints(series, scales, stacks, scaleExtension);
  };

  var ChartCore = function ChartCore() {
    return React.createElement(
      dxReactCore.Plugin,
      null,
      React.createElement(dxReactCore.Getter, { name: 'domains', computed: getDomains }),
      React.createElement(dxReactCore.Getter, { name: 'scales', computed: getScales }),
      React.createElement(dxReactCore.Getter, { name: 'series', computed: getSeries })
    );
  };

  var AxesLayout = function AxesLayout() {
    return React.createElement(
      dxReactCore.Plugin,
      null,
      React.createElement(
        dxReactCore.Template,
        { name: 'canvas' },
        React.createElement(
          'div',
          { id: 'center-center', style: { display: 'flex', flexDirection: 'column', flexGrow: 1 } },
          React.createElement(
            'div',
            { id: dxChartCore.TOP + '-axis-container', style: { display: 'flex', flexDirection: 'row' } },
            React.createElement(dxReactCore.TemplatePlaceholder, { name: dxChartCore.TOP + '-' + dxChartCore.LEFT + '-axis' }),
            React.createElement(dxReactCore.TemplatePlaceholder, { name: dxChartCore.TOP + '-axis' }),
            React.createElement(dxReactCore.TemplatePlaceholder, { name: dxChartCore.TOP + '-' + dxChartCore.RIGHT + '-axis' })
          ),
          React.createElement(
            'div',
            { id: 'center-axis-container', style: { display: 'flex', flexDirection: 'row', flexGrow: 1 } },
            React.createElement(dxReactCore.TemplatePlaceholder, { name: dxChartCore.LEFT + '-axis' }),
            React.createElement(dxReactCore.TemplatePlaceholder, null),
            React.createElement(dxReactCore.TemplatePlaceholder, { name: dxChartCore.RIGHT + '-axis' })
          ),
          React.createElement(
            'div',
            { id: dxChartCore.BOTTOM + '-axis-container', style: { display: 'flex', flexDirection: 'row' } },
            React.createElement(dxReactCore.TemplatePlaceholder, { name: dxChartCore.BOTTOM + '-' + dxChartCore.LEFT + '-axis' }),
            React.createElement(dxReactCore.TemplatePlaceholder, { name: dxChartCore.BOTTOM + '-axis' }),
            React.createElement(dxReactCore.TemplatePlaceholder, { name: dxChartCore.BOTTOM + '-' + dxChartCore.RIGHT + '-axis' })
          )
        )
      )
    );
  };

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var objectWithoutProperties = function (obj, keys) {
    var target = {};

    for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
      target[i] = obj[i];
    }

    return target;
  };

  var possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  var toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };

  var SpaceFillingRects = function (_React$PureComponent) {
    inherits(SpaceFillingRects, _React$PureComponent);

    function SpaceFillingRects() {
      classCallCheck(this, SpaceFillingRects);
      return possibleConstructorReturn(this, (SpaceFillingRects.__proto__ || Object.getPrototypeOf(SpaceFillingRects)).apply(this, arguments));
    }

    createClass(SpaceFillingRects, [{
      key: 'render',
      value: function render() {
        var placeholders = this.props.placeholders;

        return React.createElement(
          dxReactCore.Plugin,
          { name: 'SpaceFillingRects' },
          placeholders.map(function (name) {
            return React.createElement(
              dxReactCore.Template,
              { name: name, key: name },
              React.createElement(
                dxReactCore.TemplateConnector,
                null,
                function (_ref) {
                  var positions = _ref.layouts;

                  var _name$split = name.split('-'),
                      _name$split2 = slicedToArray(_name$split, 3),
                      horizontal = _name$split2[1],
                      postfix = _name$split2[2];

                  var _ref2 = positions[horizontal + (postfix ? '-' + postfix : '')] || {},
                      width = _ref2.width;

                  return React.createElement('div', { id: name, style: { width: width } });
                }
              )
            );
          })
        );
      }
    }]);
    return SpaceFillingRects;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? SpaceFillingRects.propTypes = {
    placeholders: PropTypes.arrayOf(PropTypes.string).isRequired
  } : void 0;

  /* eslint-disable-next-line react/prefer-stateless-function */
  var PaneLayout = function (_React$PureComponent) {
    inherits(PaneLayout, _React$PureComponent);

    function PaneLayout(props) {
      classCallCheck(this, PaneLayout);

      var _this = possibleConstructorReturn(this, (PaneLayout.__proto__ || Object.getPrototypeOf(PaneLayout)).call(this, props));

      _this.state = {
        width: 800,
        height: 600
      };
      return _this;
    }

    createClass(PaneLayout, [{
      key: 'handleSizeUpdate',
      value: function handleSizeUpdate(_ref, changeBBox) {
        var width = _ref.width,
            height = _ref.height;

        this.setState({ width: width, height: height });
        changeBBox({ placeholder: 'pane', bBox: { width: width, height: height } });
      }
    }, {
      key: 'render',
      value: function render() {
        var _this2 = this;

        var _state = this.state,
            width = _state.width,
            height = _state.height;


        return React.createElement(
          dxReactCore.Plugin,
          { name: 'PaneLayout' },
          React.createElement(
            dxReactCore.Template,
            { name: 'canvas' },
            function (params) {
              return React.createElement(
                dxReactCore.TemplateConnector,
                null,
                function (_, _ref2) {
                  var changeBBox = _ref2.changeBBox;
                  return React.createElement(
                    dxReactCore.Sizer,
                    {
                      style: { flex: 1, zIndex: 1 },
                      onSizeChange: function onSizeChange(size) {
                        return _this2.handleSizeUpdate(size, changeBBox);
                      }
                    },
                    React.createElement(
                      'div',
                      { style: { width: '100%' } },
                      React.createElement(
                        'svg',
                        _extends({}, params, {
                          width: width,
                          height: height,
                          style: {
                            position: 'absolute', left: 0, top: 0, overflow: 'visible'
                          }
                        }),
                        React.createElement(dxReactCore.TemplatePlaceholder, { name: 'series' })
                      )
                    )
                  );
                }
              );
            }
          )
        );
      }
    }]);
    return PaneLayout;
  }(React.PureComponent);

  var LayoutManager = function (_React$Component) {
    inherits(LayoutManager, _React$Component);

    function LayoutManager(props) {
      classCallCheck(this, LayoutManager);

      var _this = possibleConstructorReturn(this, (LayoutManager.__proto__ || Object.getPrototypeOf(LayoutManager)).call(this, props));

      var _this$props = _this.props,
          width = _this$props.width,
          height = _this$props.height;


      _this.state = { bBoxes: { pane: { width: width, height: height } } };

      var stateHelper = dxReactCore.createStateHelper(_this);

      _this.changeBBox = stateHelper.applyFieldReducer.bind(stateHelper, 'bBoxes', dxChartCore.bBoxes);
      return _this;
    }

    createClass(LayoutManager, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            width = _props.width,
            height = _props.height,
            Root = _props.rootComponent,
            restProps = objectWithoutProperties(_props, ['width', 'height', 'rootComponent']);
        var stateBBoxes = this.state.bBoxes;


        return React.createElement(
          dxReactCore.Plugin,
          null,
          React.createElement(dxReactCore.Getter, { name: 'layouts', value: stateBBoxes }),
          React.createElement(dxReactCore.Action, { name: 'changeBBox', action: this.changeBBox }),
          React.createElement(
            dxReactCore.Template,
            { name: 'root' },
            React.createElement(
              Root,
              _extends({
                height: height,
                width: width
              }, restProps),
              React.createElement(dxReactCore.TemplatePlaceholder, { name: 'canvas' })
            )
          )
        );
      }
    }]);
    return LayoutManager;
  }(React.Component);

  process.env.NODE_ENV !== "production" ? LayoutManager.propTypes = {
    width: PropTypes.number,
    height: PropTypes.number.isRequired,
    rootComponent: PropTypes.func.isRequired
  } : void 0;

  LayoutManager.defaultProps = {
    width: 0
  };

  var ComponentLayout = function ComponentLayout() {
    return React.createElement(
      dxReactCore.Plugin,
      { name: 'ComponentLayout' },
      React.createElement(
        dxReactCore.Template,
        { name: 'canvas' },
        React.createElement(
          'div',
          { id: dxChartCore.TOP + '-container', style: { display: 'flex', flexDirection: 'row' } },
          React.createElement(dxReactCore.TemplatePlaceholder, { name: dxChartCore.TOP + '-' + dxChartCore.LEFT }),
          React.createElement(dxReactCore.TemplatePlaceholder, { name: dxChartCore.TOP }),
          React.createElement(dxReactCore.TemplatePlaceholder, { name: dxChartCore.TOP + '-' + dxChartCore.LEFT })
        ),
        React.createElement(
          'div',
          { id: 'center-container', style: { display: 'flex', flexDirection: 'row', flexGrow: 1 } },
          React.createElement(dxReactCore.TemplatePlaceholder, { name: dxChartCore.LEFT }),
          React.createElement(dxReactCore.TemplatePlaceholder, null),
          React.createElement(dxReactCore.TemplatePlaceholder, { name: dxChartCore.RIGHT })
        ),
        React.createElement(
          'div',
          { id: dxChartCore.BOTTOM + '-container', style: { display: 'flex', flexDirection: 'row' } },
          React.createElement(dxReactCore.TemplatePlaceholder, { name: dxChartCore.BOTTOM + '-' + dxChartCore.LEFT }),
          React.createElement(dxReactCore.TemplatePlaceholder, { name: dxChartCore.BOTTOM })
        )
      )
    );
  };

  // TODO: Remove "palette" getter from BasicData and add Palette to Chart
  // when "paletteComputing" is removed.
  var Palette = function (_React$PureComponent) {
    inherits(Palette, _React$PureComponent);

    function Palette() {
      classCallCheck(this, Palette);
      return possibleConstructorReturn(this, (Palette.__proto__ || Object.getPrototypeOf(Palette)).apply(this, arguments));
    }

    createClass(Palette, [{
      key: 'render',
      value: function render() {
        var scheme = this.props.scheme;

        return React.createElement(
          dxReactCore.Plugin,
          { name: 'Palette' },
          React.createElement(dxReactCore.Getter, { name: 'palette', value: scheme })
        );
      }
    }]);
    return Palette;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? Palette.propTypes = {
    scheme: PropTypes.array.isRequired
  } : void 0;

  var Root = function (_React$PureComponent) {
    inherits(Root, _React$PureComponent);

    function Root() {
      classCallCheck(this, Root);
      return possibleConstructorReturn(this, (Root.__proto__ || Object.getPrototypeOf(Root)).apply(this, arguments));
    }

    createClass(Root, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            children = _props.children,
            width = _props.width,
            height = _props.height,
            style = _props.style,
            restProps = objectWithoutProperties(_props, ['children', 'width', 'height', 'style']);


        return React.createElement(
          'div',
          _extends({
            style: _extends({}, style, {
              height: height + 'px'
            }, width ? { width: width + 'px' } : null)
          }, restProps),
          children
        );
      }
    }]);
    return Root;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? Root.propTypes = {
    children: PropTypes.node,
    width: PropTypes.number.isRequired,
    height: PropTypes.number.isRequired,
    style: PropTypes.object
  } : void 0;

  Root.defaultProps = {
    children: undefined,
    style: undefined
  };

  var Label = function (_React$PureComponent) {
    inherits(Label, _React$PureComponent);

    function Label() {
      classCallCheck(this, Label);
      return possibleConstructorReturn(this, (Label.__proto__ || Object.getPrototypeOf(Label)).apply(this, arguments));
    }

    createClass(Label, [{
      key: 'render',
      value: function render() {
        return React.createElement('text', this.props);
      }
    }]);
    return Label;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? Label.propTypes = {
    children: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,
    x: PropTypes.number.isRequired,
    y: PropTypes.number.isRequired
  } : void 0;

  var makeBoundComponent = function makeBoundComponent(Target, components, exposed) {
    var Component = function (_React$PureComponent) {
      inherits(Component, _React$PureComponent);

      function Component() {
        classCallCheck(this, Component);
        return possibleConstructorReturn(this, (Component.__proto__ || Object.getPrototypeOf(Component)).apply(this, arguments));
      }

      createClass(Component, [{
        key: 'render',
        value: function render() {
          return React.createElement(Target, _extends({}, components, this.props));
        }
      }]);
      return Component;
    }(React.PureComponent);

    Component.components = Target.components;
    Object.assign(Component, exposed);
    return Component;
  };

  var withComponents = function withComponents(components) {
    return function (Target) {
      var props = {};
      var exposed = {};
      Object.entries(Target.components).forEach(function (_ref) {
        var _ref2 = slicedToArray(_ref, 2),
            fieldName = _ref2[0],
            componentName = _ref2[1];

        var component = components[componentName];
        if (component && component !== Target[componentName]) {
          props[fieldName] = component;
        }
        exposed[componentName] = component || Target[componentName];
      });
      return Object.keys(props).length > 0 ? makeBoundComponent(Target, props, exposed) : Target;
    };
  };

  // May be it is better to say what props are passed along rather then what are NOT passed?
  var getRenderProps = function getRenderProps(series) {
    var name = series.name,
        uniqueName = series.uniqueName,
        axisName = series.axisName,
        argumentField = series.argumentField,
        valueField = series.valueField,
        palette = series.palette,
        symbolName = series.symbolName,
        isStartedFromZero = series.isStartedFromZero,
        getValueDomain = series.getValueDomain,
        createHitTester = series.createHitTester,
        restProps = objectWithoutProperties(series, ['name', 'uniqueName', 'axisName', 'argumentField', 'valueField', 'palette', 'symbolName', 'isStartedFromZero', 'getValueDomain', 'createHitTester']);


    return restProps;
  };

  var declareSeries = function declareSeries(pluginName, _ref) {
    var components = _ref.components,
        parameters = objectWithoutProperties(_ref, ['components']);

    var Component = function (_React$PureComponent) {
      inherits(Component, _React$PureComponent);

      function Component() {
        classCallCheck(this, Component);
        return possibleConstructorReturn(this, (Component.__proto__ || Object.getPrototypeOf(Component)).apply(this, arguments));
      }

      createClass(Component, [{
        key: 'render',
        value: function render() {
          var name = this.props.name;

          var symbolName = Symbol(name);
          var seriesItem = _extends({}, parameters, this.props, {
            symbolName: symbolName
          });
          var getSeries = function getSeries(_ref2) {
            var series = _ref2.series,
                data = _ref2.data,
                palette = _ref2.palette;
            return dxChartCore.addSeries(series, data, palette, seriesItem);
          };
          return React.createElement(
            dxReactCore.Plugin,
            { name: pluginName },
            React.createElement(dxReactCore.Getter, { name: 'series', computed: getSeries }),
            React.createElement(
              dxReactCore.Template,
              { name: 'series' },
              React.createElement(dxReactCore.TemplatePlaceholder, null),
              React.createElement(
                dxReactCore.TemplateConnector,
                null,
                function (_ref3) {
                  var series = _ref3.series,
                      scales = _ref3.scales,
                      getAnimatedStyle = _ref3.getAnimatedStyle;

                  var currentSeries = dxChartCore.findSeriesByName(symbolName, series);
                  var currentScales = {
                    xScale: scales[dxChartCore.ARGUMENT_DOMAIN],
                    yScale: scales[dxChartCore.getValueDomainName(currentSeries.axisName)]
                  };

                  var _getRenderProps = getRenderProps(currentSeries),
                      Series = _getRenderProps.seriesComponent,
                      points = _getRenderProps.points,
                      props = objectWithoutProperties(_getRenderProps, ['seriesComponent', 'points']);

                  return React.createElement(Series, _extends({
                    coordinates: points,
                    scales: currentScales,
                    getAnimatedStyle: getAnimatedStyle
                  }, props));
                }
              )
            )
          );
        }
      }]);
      return Component;
    }(React.PureComponent);

    process.env.NODE_ENV !== "production" ? Component.propTypes = {
      name: PropTypes.string,
      /* eslint-disable react/no-unused-prop-types */
      valueField: PropTypes.string.isRequired,
      argumentField: PropTypes.string.isRequired
      /* eslint-enable react/no-unused-prop-types */
    } : void 0;
    Component.defaultProps = {
      name: 'defaultSeriesName'
    };
    Component.components = {};
    if (components.Path) {
      Component.components.seriesComponent = 'Path';
    }
    if (components.Point) {
      Component.components.pointComponent = 'Point';
    }
    return withComponents(components)(Component);
  };

  var withPatchedProps = function withPatchedProps(patch) {
    return function (Target) {
      var Component = function (_React$PureComponent) {
        inherits(Component, _React$PureComponent);

        function Component() {
          classCallCheck(this, Component);
          return possibleConstructorReturn(this, (Component.__proto__ || Object.getPrototypeOf(Component)).apply(this, arguments));
        }

        createClass(Component, [{
          key: 'render',
          value: function render() {
            var props = patch(this.props);
            return React.createElement(Target, props);
          }
        }]);
        return Component;
      }(React.PureComponent);

      return Component;
    };
  };

  var RawChart = function (_React$PureComponent) {
    inherits(RawChart, _React$PureComponent);

    function RawChart() {
      classCallCheck(this, RawChart);
      return possibleConstructorReturn(this, (RawChart.__proto__ || Object.getPrototypeOf(RawChart)).apply(this, arguments));
    }

    createClass(RawChart, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            data = _props.data,
            width = _props.width,
            height = _props.height,
            children = _props.children,
            rootComponent = _props.rootComponent,
            restProps = objectWithoutProperties(_props, ['data', 'width', 'height', 'children', 'rootComponent']);

        return React.createElement(
          dxReactCore.PluginHost,
          null,
          React.createElement(BasicData, { data: data }),
          React.createElement(Palette, { scheme: [] }),
          React.createElement(LayoutManager, _extends({
            width: width,
            height: height,
            rootComponent: rootComponent
          }, restProps)),
          React.createElement(PaneLayout, null),
          React.createElement(AxesLayout, null),
          React.createElement(ComponentLayout, null),
          React.createElement(SpaceFillingRects, { placeholders: [dxChartCore.TOP + '-' + dxChartCore.LEFT, dxChartCore.TOP + '-' + dxChartCore.RIGHT, dxChartCore.BOTTOM + '-' + dxChartCore.LEFT, dxChartCore.BOTTOM + '-' + dxChartCore.RIGHT, dxChartCore.TOP + '-' + dxChartCore.LEFT + '-axis', dxChartCore.TOP + '-' + dxChartCore.RIGHT + '-axis', dxChartCore.BOTTOM + '-' + dxChartCore.LEFT + '-axis', dxChartCore.BOTTOM + '-' + dxChartCore.RIGHT + '-axis']
          }),
          children,
          React.createElement(ChartCore, null)
        );
      }
    }]);
    return RawChart;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? RawChart.propTypes = {
    data: PropTypes.array.isRequired,
    rootComponent: PropTypes.func.isRequired,
    width: PropTypes.number,
    height: PropTypes.number,
    children: PropTypes.node
  } : void 0;

  RawChart.defaultProps = {
    height: 500,
    width: undefined,
    children: null
  };

  RawChart.components = {
    rootComponent: 'Root'
  };

  var Chart = withComponents({ Root: Root })(RawChart);
  Chart.Label = Label;

  var Marker = function (_React$PureComponent) {
    inherits(Marker, _React$PureComponent);

    function Marker() {
      classCallCheck(this, Marker);
      return possibleConstructorReturn(this, (Marker.__proto__ || Object.getPrototypeOf(Marker)).apply(this, arguments));
    }

    createClass(Marker, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            color = _props.color,
            restProps = objectWithoutProperties(_props, ['color']);

        return React.createElement(
          'svg',
          _extends({ fill: color, width: '10', height: '10' }, restProps),
          React.createElement('circle', _extends({ r: 5, cx: 5, cy: 5 }, restProps))
        );
      }
    }]);
    return Marker;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? Marker.propTypes = {
    color: PropTypes.string
  } : void 0;

  Marker.defaultProps = {
    color: undefined
  };

  var RawLegend = function (_React$PureComponent) {
    inherits(RawLegend, _React$PureComponent);

    function RawLegend() {
      classCallCheck(this, RawLegend);
      return possibleConstructorReturn(this, (RawLegend.__proto__ || Object.getPrototypeOf(RawLegend)).apply(this, arguments));
    }

    createClass(RawLegend, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            MarkerComponent = _props.markerComponent,
            Label = _props.labelComponent,
            Root = _props.rootComponent,
            Item = _props.itemComponent,
            position = _props.position,
            getItems = _props.getItems;

        var placeholder = position;
        return React.createElement(
          dxReactCore.Plugin,
          { name: 'Legend' },
          React.createElement(
            dxReactCore.Template,
            { name: placeholder },
            React.createElement(dxReactCore.TemplatePlaceholder, null),
            React.createElement(
              dxReactCore.TemplateConnector,
              null,
              function (getters) {
                return React.createElement(
                  Root,
                  { name: 'legend-' + placeholder },
                  getItems(getters).map(function (_ref) {
                    var text = _ref.text,
                        color = _ref.color;
                    return React.createElement(
                      Item,
                      { key: text },
                      React.createElement(MarkerComponent, { name: text, color: color }),
                      React.createElement(Label, { text: text })
                    );
                  })
                );
              }
            )
          )
        );
      }
    }]);
    return RawLegend;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? RawLegend.propTypes = {
    markerComponent: PropTypes.func.isRequired,
    labelComponent: PropTypes.func.isRequired,
    rootComponent: PropTypes.func.isRequired,
    itemComponent: PropTypes.func.isRequired,
    position: PropTypes.string,
    getItems: PropTypes.func
  } : void 0;

  RawLegend.defaultProps = {
    position: 'right',
    getItems: function getItems(_ref2) {
      var series = _ref2.series;
      return dxChartCore.getLegendItems(series);
    }
  };

  RawLegend.components = {
    rootComponent: 'Root',
    itemComponent: 'Item',
    markerComponent: 'Marker',
    labelComponent: 'Label'
  };

  var Legend = withComponents({ Marker: Marker })(RawLegend);

  var Title = function (_React$PureComponent) {
    inherits(Title, _React$PureComponent);

    function Title() {
      classCallCheck(this, Title);
      return possibleConstructorReturn(this, (Title.__proto__ || Object.getPrototypeOf(Title)).apply(this, arguments));
    }

    createClass(Title, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            Text = _props.textComponent,
            text = _props.text,
            position = _props.position,
            restProps = objectWithoutProperties(_props, ['textComponent', 'text', 'position']);

        var placeholder = position;
        return React.createElement(
          dxReactCore.Plugin,
          { name: 'Title' },
          React.createElement(
            dxReactCore.Template,
            { name: placeholder },
            React.createElement(dxReactCore.TemplatePlaceholder, null),
            React.createElement(Text, _extends({ text: text }, restProps))
          )
        );
      }
    }]);
    return Title;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? Title.propTypes = {
    textComponent: PropTypes.func.isRequired,
    text: PropTypes.string.isRequired,
    position: PropTypes.string
  } : void 0;

  Title.defaultProps = {
    position: 'top'
  };

  Title.components = {
    textComponent: 'Text'
  };

  var Scale = function (_React$PureComponent) {
    inherits(Scale, _React$PureComponent);

    function Scale() {
      classCallCheck(this, Scale);
      return possibleConstructorReturn(this, (Scale.__proto__ || Object.getPrototypeOf(Scale)).apply(this, arguments));
    }

    createClass(Scale, [{
      key: 'render',
      value: function render() {
        var extensions = this.props.extensions;

        return React.createElement(
          dxReactCore.Plugin,
          { name: 'Scale' },
          React.createElement(dxReactCore.Getter, { name: 'scaleExtension', value: dxChartCore.computeExtension(extensions) })
        );
      }
    }]);
    return Scale;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? Scale.propTypes = {
    extensions: PropTypes.arrayOf(PropTypes.shape({
      type: PropTypes.string,
      constructor: PropTypes.func
    }))
  } : void 0;

  Scale.defaultProps = {
    extensions: []
  };

  var Stack = function (_React$PureComponent) {
    inherits(Stack, _React$PureComponent);

    function Stack() {
      classCallCheck(this, Stack);
      return possibleConstructorReturn(this, (Stack.__proto__ || Object.getPrototypeOf(Stack)).apply(this, arguments));
    }

    createClass(Stack, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            stacks = _props.stacks,
            offset = _props.offset,
            order = _props.order;

        var params = { stacks: stacks, offset: offset, order: order };
        var getSeries = function getSeries(_ref) {
          var series = _ref.series,
              data = _ref.data;
          return dxChartCore.getStackedSeries(series, data, params);
        };
        return React.createElement(
          dxReactCore.Plugin,
          { name: 'Stack' },
          React.createElement(dxReactCore.Getter, { name: 'series', computed: getSeries })
        );
      }
    }]);
    return Stack;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? Stack.propTypes = {
    stacks: PropTypes.arrayOf(PropTypes.shape({
      series: PropTypes.arrayOf(PropTypes.string).isRequired
    })),
    offset: PropTypes.func,
    order: PropTypes.func
  } : void 0;

  Stack.defaultProps = {
    stacks: [],
    offset: d3Shape.stackOffsetDiverging,
    order: d3Shape.stackOrderNone
  };

  /* eslint-disable-next-line react/prefer-stateless-function */
  var Animation = function (_React$PureComponent) {
    inherits(Animation, _React$PureComponent);

    function Animation() {
      classCallCheck(this, Animation);
      return possibleConstructorReturn(this, (Animation.__proto__ || Object.getPrototypeOf(Animation)).apply(this, arguments));
    }

    createClass(Animation, [{
      key: 'render',
      value: function render() {
        return React.createElement(
          dxReactCore.Plugin,
          { name: 'Animation' },
          React.createElement(dxReactCore.Getter, { name: 'getAnimatedStyle', value: dxChartCore.buildAnimatedStyleGetter })
        );
      }
    }]);
    return Animation;
  }(React.PureComponent);

  var withStates = function withStates(states) {
    return function (Component) {
      var ComponentWithStates = function (_React$PureComponent) {
        inherits(ComponentWithStates, _React$PureComponent);

        function ComponentWithStates() {
          classCallCheck(this, ComponentWithStates);
          return possibleConstructorReturn(this, (ComponentWithStates.__proto__ || Object.getPrototypeOf(ComponentWithStates)).apply(this, arguments));
        }

        createClass(ComponentWithStates, [{
          key: 'render',
          value: function render() {
            var _props = this.props,
                state = _props.state,
                restProps = objectWithoutProperties(_props, ['state']);

            var stateFunc = states[state];
            var result = stateFunc ? stateFunc(restProps) : restProps;
            return React.isValidElement(result) ? result : React.createElement(Component, result);
          }
        }]);
        return ComponentWithStates;
      }(React.PureComponent);

      process.env.NODE_ENV !== "production" ? ComponentWithStates.propTypes = {
        state: PropTypes.string
      } : void 0;
      ComponentWithStates.defaultProps = {
        state: undefined
      };
      return ComponentWithStates;
    };
  };

  var Pattern = function (_React$PureComponent) {
    inherits(Pattern, _React$PureComponent);

    function Pattern() {
      classCallCheck(this, Pattern);
      return possibleConstructorReturn(this, (Pattern.__proto__ || Object.getPrototypeOf(Pattern)).apply(this, arguments));
    }

    createClass(Pattern, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            id = _props.id,
            size = _props.size,
            color = _props.color,
            opacity = _props.opacity;

        return React.createElement(
          'defs',
          null,
          React.createElement(
            'pattern',
            {
              id: id,
              width: size,
              height: size,
              patternUnits: 'userSpaceOnUse'
            },
            React.createElement('rect', { x: 0, y: 0, width: size, height: size, fill: color, opacity: opacity }),
            React.createElement('path', {
              d: 'M ' + size / 2 + ' ' + -size / 2 + ' L ' + -size / 2 + ' ' + size / 2 + ' M 0 ' + size + ' L ' + size + ' 0 M ' + size * 1.5 + ' ' + size / 2 + ' L ' + size / 2 + ' ' + size * 1.5,
              strokeWidth: 2,
              stroke: color
            })
          )
        );
      }
    }]);
    return Pattern;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? Pattern.propTypes = {
    id: PropTypes.string.isRequired,
    size: PropTypes.number,
    color: PropTypes.string.isRequired,
    opacity: PropTypes.number
  } : void 0;

  Pattern.defaultProps = {
    size: 6,
    opacity: 0.75
  };

  // Function is returned (not PureComponent descendant) because
  // result is invoked as function (not as React component).
  var withPattern = function withPattern(getPatternId, props) {
    return function (Target) {
      return function (_ref) {
        var color = _ref.color,
            restProps = objectWithoutProperties(_ref, ['color']);

        var patternId = getPatternId(restProps);
        return React.createElement(
          React.Fragment,
          null,
          React.createElement(Target, _extends({
            fill: 'url(#' + patternId + ')'
          }, restProps)),
          React.createElement(Pattern, _extends({
            id: patternId,
            color: color
          }, props))
        );
      };
    };
  };

  var _withStates;

  var RawArea = function (_React$PureComponent) {
    inherits(RawArea, _React$PureComponent);

    function RawArea() {
      classCallCheck(this, RawArea);
      return possibleConstructorReturn(this, (RawArea.__proto__ || Object.getPrototypeOf(RawArea)).apply(this, arguments));
    }

    createClass(RawArea, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            path = _props.path,
            coordinates = _props.coordinates,
            color = _props.color,
            index = _props.index,
            style = _props.style,
            getAnimatedStyle = _props.getAnimatedStyle,
            scales = _props.scales,
            restProps = objectWithoutProperties(_props, ['path', 'coordinates', 'color', 'index', 'style', 'getAnimatedStyle', 'scales']);

        return React.createElement('path', _extends({
          d: path(coordinates),
          fill: color,
          opacity: 0.5,
          style: getAnimatedStyle(style, dxChartCore.getAreaAnimationStyle, scales)
        }, restProps));
      }
    }]);
    return RawArea;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? RawArea.propTypes = {
    path: PropTypes.func.isRequired,
    coordinates: PropTypes.array.isRequired,
    color: PropTypes.string,
    style: PropTypes.object
  } : void 0;

  RawArea.defaultProps = {
    color: undefined,
    style: undefined
  };

  var Area = withStates((_withStates = {}, defineProperty(_withStates, dxChartCore.HOVERED, withPattern(function (_ref) {
    var index = _ref.index;
    return 'series-' + index + '-hover';
  }, { opacity: 0.75 })(RawArea)), defineProperty(_withStates, dxChartCore.SELECTED, withPattern(function (_ref2) {
    var index = _ref2.index;
    return 'series-' + index + '-selection';
  }, { opacity: 0.5 })(RawArea)), _withStates))(RawArea);

  var AreaSeries = declareSeries('AreaSeries', {
    components: { Path: Area },
    path: dxChartCore.dArea,
    isStartedFromZero: true,
    getPointTransformer: dxChartCore.getAreaPointTransformer,
    createHitTester: dxChartCore.createAreaHitTester
  });

  var BarCollection = function (_React$PureComponent) {
    inherits(BarCollection, _React$PureComponent);

    function BarCollection() {
      classCallCheck(this, BarCollection);
      return possibleConstructorReturn(this, (BarCollection.__proto__ || Object.getPrototypeOf(BarCollection)).apply(this, arguments));
    }

    createClass(BarCollection, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            Point = _props.pointComponent,
            path = _props.path,
            coordinates = _props.coordinates,
            index = _props.index,
            style = _props.style,
            scales = _props.scales,
            getAnimatedStyle = _props.getAnimatedStyle,
            state = _props.state,
            restProps = objectWithoutProperties(_props, ['pointComponent', 'path', 'coordinates', 'index', 'style', 'scales', 'getAnimatedStyle', 'state']);

        return coordinates.map(function (item) {
          return React.createElement(Point, _extends({
            key: item.index.toString(),
            style: getAnimatedStyle(style, dxChartCore.getAreaAnimationStyle, scales),
            seriesIndex: index
          }, restProps, dxChartCore.dBar(item), item));
        });
      }
    }]);
    return BarCollection;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? BarCollection.propTypes = {
    pointComponent: PropTypes.func.isRequired,
    style: PropTypes.object
  } : void 0;

  BarCollection.defaultProps = {
    style: undefined
  };

  var _withStates$1;

  var RawBar = function (_React$PureComponent) {
    inherits(RawBar, _React$PureComponent);

    function RawBar() {
      classCallCheck(this, RawBar);
      return possibleConstructorReturn(this, (RawBar.__proto__ || Object.getPrototypeOf(RawBar)).apply(this, arguments));
    }

    createClass(RawBar, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            argument = _props.argument,
            value = _props.value,
            index = _props.index,
            seriesIndex = _props.seriesIndex,
            barWidth = _props.barWidth,
            color = _props.color,
            restProps = objectWithoutProperties(_props, ['argument', 'value', 'index', 'seriesIndex', 'barWidth', 'color']);

        return React.createElement('rect', _extends({ fill: color }, restProps));
      }
    }]);
    return RawBar;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? RawBar.propTypes = {
    x: PropTypes.number.isRequired,
    y: PropTypes.number.isRequired,
    width: PropTypes.number.isRequired,
    height: PropTypes.number.isRequired,
    value: PropTypes.number.isRequired,
    color: PropTypes.string
  } : void 0;

  RawBar.defaultProps = {
    color: undefined
  };

  var Bar = withStates((_withStates$1 = {}, defineProperty(_withStates$1, dxChartCore.HOVERED, withPattern(function (_ref) {
    var seriesIndex = _ref.seriesIndex,
        index = _ref.index;
    return 'series-' + seriesIndex + '-point-' + index + '-hover';
  }, { opacity: 0.75 })(RawBar)), defineProperty(_withStates$1, dxChartCore.SELECTED, withPattern(function (_ref2) {
    var seriesIndex = _ref2.seriesIndex,
        index = _ref2.index;
    return 'series-' + seriesIndex + '-point-' + index + '-selection';
  }, { opacity: 0.5 })(RawBar)), _withStates$1))(RawBar);

  var BarSeries = declareSeries('BarSeries', {
    components: { Path: BarCollection, Point: Bar },
    isStartedFromZero: true,
    getPointTransformer: dxChartCore.getBarPointTransformer,
    createHitTester: dxChartCore.createBarHitTester
  });

  BarSeries.defaultProps = {
    barWidth: 0.9
  };

  var _withStates$2;

  var RawPath = function (_React$PureComponent) {
    inherits(RawPath, _React$PureComponent);

    function RawPath() {
      classCallCheck(this, RawPath);
      return possibleConstructorReturn(this, (RawPath.__proto__ || Object.getPrototypeOf(RawPath)).apply(this, arguments));
    }

    createClass(RawPath, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            path = _props.path,
            coordinates = _props.coordinates,
            color = _props.color,
            index = _props.index,
            style = _props.style,
            getAnimatedStyle = _props.getAnimatedStyle,
            scales = _props.scales,
            restProps = objectWithoutProperties(_props, ['path', 'coordinates', 'color', 'index', 'style', 'getAnimatedStyle', 'scales']);

        return React.createElement('path', _extends({
          d: path(coordinates),
          fill: 'none',
          strokeWidth: 2,
          stroke: color,
          style: getAnimatedStyle(style, dxChartCore.getAreaAnimationStyle, scales)
        }, restProps));
      }
    }]);
    return RawPath;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? RawPath.propTypes = {
    path: PropTypes.func.isRequired,
    coordinates: PropTypes.array.isRequired,
    color: PropTypes.string,
    style: PropTypes.object
  } : void 0;

  RawPath.defaultProps = {
    color: undefined,
    style: undefined
  };

  var Path = withStates((_withStates$2 = {}, defineProperty(_withStates$2, dxChartCore.HOVERED, function (props) {
    return _extends({ strokeWidth: 4 }, props);
  }), defineProperty(_withStates$2, dxChartCore.SELECTED, function (props) {
    return _extends({ strokeWidth: 4 }, props);
  }), _withStates$2))(RawPath);

  var LineSeries = declareSeries('LineSeries', {
    components: { Path: Path },
    path: dxChartCore.dLine,
    getPointTransformer: dxChartCore.getAreaPointTransformer,
    createHitTester: dxChartCore.createLineHitTester
  });

  // TODO: Is it fine to have it hard coded or should there be `path` property?
  var SliceCollection = function (_React$PureComponent) {
    inherits(SliceCollection, _React$PureComponent);

    function SliceCollection() {
      classCallCheck(this, SliceCollection);
      return possibleConstructorReturn(this, (SliceCollection.__proto__ || Object.getPrototypeOf(SliceCollection)).apply(this, arguments));
    }

    createClass(SliceCollection, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            Point = _props.pointComponent,
            path = _props.path,
            coordinates = _props.coordinates,
            index = _props.index,
            uniqueName = _props.uniqueName,
            style = _props.style,
            getAnimatedStyle = _props.getAnimatedStyle,
            scales = _props.scales,
            innerRadius = _props.innerRadius,
            outerRadius = _props.outerRadius,
            state = _props.state,
            restProps = objectWithoutProperties(_props, ['pointComponent', 'path', 'coordinates', 'index', 'uniqueName', 'style', 'getAnimatedStyle', 'scales', 'innerRadius', 'outerRadius', 'state']);

        return React.createElement(
          'g',
          { transform: 'translate(' + coordinates[0].x + ' ' + coordinates[0].y + ')' },
          coordinates.map(function (item) {
            return React.createElement(Point, _extends({
              key: item.index.toString(),
              style: getAnimatedStyle(style, dxChartCore.getPieAnimationStyle, scales, item),
              seriesIndex: index
            }, restProps, item));
          })
        );
      }
    }]);
    return SliceCollection;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? SliceCollection.propTypes = {
    pointComponent: PropTypes.func.isRequired,
    style: PropTypes.object
  } : void 0;

  SliceCollection.defaultProps = {
    style: undefined
  };

  var _withStates$3;

  var RawSlice = function (_React$PureComponent) {
    inherits(RawSlice, _React$PureComponent);

    function RawSlice() {
      classCallCheck(this, RawSlice);
      return possibleConstructorReturn(this, (RawSlice.__proto__ || Object.getPrototypeOf(RawSlice)).apply(this, arguments));
    }

    createClass(RawSlice, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            argument = _props.argument,
            value = _props.value,
            index = _props.index,
            seriesIndex = _props.seriesIndex,
            innerRadius = _props.innerRadius,
            outerRadius = _props.outerRadius,
            startAngle = _props.startAngle,
            endAngle = _props.endAngle,
            x = _props.x,
            y = _props.y,
            d = _props.d,
            color = _props.color,
            restProps = objectWithoutProperties(_props, ['argument', 'value', 'index', 'seriesIndex', 'innerRadius', 'outerRadius', 'startAngle', 'endAngle', 'x', 'y', 'd', 'color']);

        return React.createElement('path', _extends({
          fill: color,
          stroke: 'none',
          d: d
        }, restProps));
      }
    }]);
    return RawSlice;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? RawSlice.propTypes = {
    x: PropTypes.number.isRequired,
    y: PropTypes.number.isRequired,
    d: PropTypes.string.isRequired,
    value: PropTypes.number.isRequired,
    style: PropTypes.object,
    color: PropTypes.string
  } : void 0;

  RawSlice.defaultProps = {
    style: {},
    color: undefined
  };

  var Slice = withStates((_withStates$3 = {}, defineProperty(_withStates$3, dxChartCore.HOVERED, withPattern(function (_ref) {
    var seriesIndex = _ref.seriesIndex,
        index = _ref.index;
    return 'series-' + seriesIndex + '-point-' + index + '-hover';
  }, { opacity: 0.75 })(RawSlice)), defineProperty(_withStates$3, dxChartCore.SELECTED, withPattern(function (_ref2) {
    var seriesIndex = _ref2.seriesIndex,
        index = _ref2.index;
    return 'series-' + seriesIndex + '-point-' + index + '-selection';
  }, { opacity: 0.5 })(RawSlice)), _withStates$3))(RawSlice);

  var PieSeries = declareSeries('PieSeries', {
    components: { Path: SliceCollection, Point: Slice },
    getPointTransformer: dxChartCore.getPiePointTransformer,
    createHitTester: dxChartCore.createPieHitTester
  });

  var PointCollection = function (_React$PureComponent) {
    inherits(PointCollection, _React$PureComponent);

    function PointCollection() {
      classCallCheck(this, PointCollection);
      return possibleConstructorReturn(this, (PointCollection.__proto__ || Object.getPrototypeOf(PointCollection)).apply(this, arguments));
    }

    createClass(PointCollection, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            Point = _props.pointComponent,
            path = _props.path,
            coordinates = _props.coordinates,
            _props$point = _props.point,
            point = _props$point === undefined ? {} : _props$point,
            style = _props.style,
            getAnimatedStyle = _props.getAnimatedStyle,
            scales = _props.scales,
            state = _props.state,
            restProps = objectWithoutProperties(_props, ['pointComponent', 'path', 'coordinates', 'point', 'style', 'getAnimatedStyle', 'scales', 'state']);

        var getAttributes = dxChartCore.pointAttributes(point);
        return coordinates.map(function (item) {
          return React.createElement(Point, _extends({
            key: item.index.toString(),
            style: getAnimatedStyle(style, dxChartCore.getScatterAnimationStyle, scales)
          }, restProps, getAttributes(item), item));
        });
      }
    }]);
    return PointCollection;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? PointCollection.propTypes = {
    pointComponent: PropTypes.func.isRequired,
    style: PropTypes.object
  } : void 0;

  PointCollection.defaultProps = {
    style: undefined
  };

  var _withStates$4;

  var RawPoint = function (_React$PureComponent) {
    inherits(RawPoint, _React$PureComponent);

    function RawPoint() {
      classCallCheck(this, RawPoint);
      return possibleConstructorReturn(this, (RawPoint.__proto__ || Object.getPrototypeOf(RawPoint)).apply(this, arguments));
    }

    createClass(RawPoint, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            argument = _props.argument,
            value = _props.value,
            index = _props.index,
            x = _props.x,
            y = _props.y,
            color = _props.color,
            restProps = objectWithoutProperties(_props, ['argument', 'value', 'index', 'x', 'y', 'color']);
        // *d* attribute is calculated during points scaling.
        // TODO: Do it here - d={path().size(size).type(type)()}

        return React.createElement('path', _extends({
          fill: color,
          stroke: 'none',
          transform: 'translate(' + x + ' ' + y + ')'
        }, restProps));
      }
    }]);
    return RawPoint;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? RawPoint.propTypes = {
    x: PropTypes.number.isRequired,
    y: PropTypes.number.isRequired,
    value: PropTypes.number.isRequired,
    color: PropTypes.string
  } : void 0;

  RawPoint.defaultProps = {
    color: undefined
  };

  var Point = withStates((_withStates$4 = {}, defineProperty(_withStates$4, dxChartCore.HOVERED, function (_ref) {
    var color = _ref.color,
        restProps = objectWithoutProperties(_ref, ['color']);
    return _extends({
      stroke: color,
      strokeWidth: 4,
      fill: 'none'
    }, restProps);
  }), defineProperty(_withStates$4, dxChartCore.SELECTED, function (_ref2) {
    var color = _ref2.color,
        restProps = objectWithoutProperties(_ref2, ['color']);
    return _extends({
      stroke: color,
      strokeWidth: 4,
      fill: 'none'
    }, restProps);
  }), _withStates$4))(RawPoint);

  var ScatterSeries = declareSeries('ScatterSeries', {
    components: { Path: PointCollection, Point: Point },
    getPointTransformer: dxChartCore.getAreaPointTransformer,
    createHitTester: dxChartCore.createScatterHitTester
  });

  var SplineSeries = declareSeries('SplineSeries', {
    components: { Path: Path },
    path: dxChartCore.dSpline,
    getPointTransformer: dxChartCore.getAreaPointTransformer,
    createHitTester: dxChartCore.createSplineHitTester
  });

  var Root$1 = function (_React$PureComponent) {
    inherits(Root, _React$PureComponent);

    function Root() {
      classCallCheck(this, Root);
      return possibleConstructorReturn(this, (Root.__proto__ || Object.getPrototypeOf(Root)).apply(this, arguments));
    }

    createClass(Root, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            x = _props.x,
            y = _props.y,
            refsHandler = _props.refsHandler,
            children = _props.children,
            restProps = objectWithoutProperties(_props, ['x', 'y', 'refsHandler', 'children']);

        return React.createElement(
          'g',
          _extends({
            ref: refsHandler,
            transform: 'translate(' + x + ' ' + y + ')'
          }, restProps),
          children
        );
      }
    }]);
    return Root;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? Root$1.propTypes = {
    x: PropTypes.number.isRequired,
    y: PropTypes.number.isRequired,
    refsHandler: PropTypes.func.isRequired,
    children: PropTypes.node.isRequired
  } : void 0;

  var Tick = function (_React$PureComponent) {
    inherits(Tick, _React$PureComponent);

    function Tick() {
      classCallCheck(this, Tick);
      return possibleConstructorReturn(this, (Tick.__proto__ || Object.getPrototypeOf(Tick)).apply(this, arguments));
    }

    createClass(Tick, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            x1 = _props.x1,
            x2 = _props.x2,
            y1 = _props.y1,
            y2 = _props.y2,
            restProps = objectWithoutProperties(_props, ['x1', 'x2', 'y1', 'y2']);

        return React.createElement('path', _extends({
          d: 'M ' + x1 + ' ' + y1 + ' L ' + x2 + ' ' + y2
        }, restProps));
      }
    }]);
    return Tick;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? Tick.propTypes = {
    x1: PropTypes.number.isRequired,
    x2: PropTypes.number.isRequired,
    y1: PropTypes.number.isRequired,
    y2: PropTypes.number.isRequired
  } : void 0;

  var Label$1 = function (_React$PureComponent) {
    inherits(Label, _React$PureComponent);

    function Label() {
      classCallCheck(this, Label);
      return possibleConstructorReturn(this, (Label.__proto__ || Object.getPrototypeOf(Label)).apply(this, arguments));
    }

    createClass(Label, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            text = _props.text,
            x = _props.x,
            y = _props.y,
            dominantBaseline = _props.dominantBaseline,
            textAnchor = _props.textAnchor,
            restProps = objectWithoutProperties(_props, ['text', 'x', 'y', 'dominantBaseline', 'textAnchor']);


        return React.createElement(
          'text',
          _extends({
            dominantBaseline: dominantBaseline,
            textAnchor: textAnchor,
            x: x,
            y: y
          }, restProps),
          text
        );
      }
    }]);
    return Label;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? Label$1.propTypes = {
    text: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,
    x: PropTypes.number.isRequired,
    y: PropTypes.number.isRequired,
    dominantBaseline: PropTypes.string.isRequired,
    textAnchor: PropTypes.string.isRequired
  } : void 0;

  var Line = function (_React$PureComponent) {
    inherits(Line, _React$PureComponent);

    function Line() {
      classCallCheck(this, Line);
      return possibleConstructorReturn(this, (Line.__proto__ || Object.getPrototypeOf(Line)).apply(this, arguments));
    }

    createClass(Line, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            width = _props.width,
            height = _props.height,
            orientation = _props.orientation,
            restProps = objectWithoutProperties(_props, ['width', 'height', 'orientation']);

        return React.createElement('path', _extends({
          d: 'M 0 0 L ' + (orientation === 'horizontal' ? width : 0) + ' ' + (orientation === 'horizontal' ? 0 : height)
        }, restProps));
      }
    }]);
    return Line;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? Line.propTypes = {
    width: PropTypes.number.isRequired,
    height: PropTypes.number.isRequired,
    orientation: PropTypes.string.isRequired
  } : void 0;

  var getZeroCoord = function getZeroCoord() {
    return 0;
  };
  var getCorrectSize = function getCorrectSize(position) {
    return position === 'left' || position === 'top' ? function (coord) {
      return -coord;
    } : function (coord, side) {
      return side + coord;
    };
  };
  var getCorrection = function getCorrection(position) {
    return position === 'left' || position === 'top' ? function (coord) {
      return coord;
    } : getZeroCoord;
  };
  var getCurrentSize = function getCurrentSize(_, side) {
    return side;
  };

  var RawAxis = function (_React$PureComponent) {
    inherits(RawAxis, _React$PureComponent);

    function RawAxis(props) {
      classCallCheck(this, RawAxis);

      var _this = possibleConstructorReturn(this, (RawAxis.__proto__ || Object.getPrototypeOf(RawAxis)).call(this, props));

      _this.state = {
        xCorrection: 0,
        yCorrection: 0
      };
      _this.createRefsHandler = _this.createRefsHandler.bind(_this);
      return _this;
    }

    createClass(RawAxis, [{
      key: 'createRefsHandler',
      value: function createRefsHandler(placeholder, changeBBox, _ref) {
        var _this2 = this;

        var getWidth = _ref.getWidth,
            getHeight = _ref.getHeight,
            getXCorrection = _ref.getXCorrection,
            getYCorrection = _ref.getYCorrection;

        return function (el) {
          if (!el) {
            return;
          }

          var _el$getBBox = el.getBBox(),
              width = _el$getBBox.width,
              height = _el$getBBox.height,
              x = _el$getBBox.x,
              y = _el$getBBox.y;

          var _state = _this2.state,
              stateWidth = _state.width,
              stateHeight = _state.height;


          if (width === stateWidth && height === stateHeight) return;
          changeBBox({
            placeholder: placeholder,
            bBox: {
              width: getWidth(x, width),
              height: getHeight(y, height)
            }
          });
          _this2.setState({
            width: width,
            height: height,
            xCorrection: getXCorrection(x),
            yCorrection: getYCorrection(y)
          });
        };
      }
    }, {
      key: 'calculateLayout',
      value: function calculateLayout(width, height, defaultWidth, defaultHeight) {
        var calculatedWidth = width || defaultWidth;
        var calculatedHeight = height || defaultHeight;

        var _ref2 = this.node && this.node.getBoundingClientRect() || {},
            containerWidth = _ref2.width,
            containerHeight = _ref2.height;

        return {
          width: containerWidth || calculatedWidth,
          height: containerHeight || calculatedHeight
        };
      }
    }, {
      key: 'render',
      value: function render() {
        var _this3 = this;

        var _props = this.props,
            tickSize = _props.tickSize,
            position = _props.position,
            name = _props.name,
            indentFromAxis = _props.indentFromAxis,
            RootComponent = _props.rootComponent,
            TickComponent = _props.tickComponent,
            LabelComponent = _props.labelComponent,
            LineComponent = _props.lineComponent;

        var getAxes = function getAxes(_ref3) {
          var axes = _ref3.axes;
          return dxChartCore.axesData(axes, _this3.props);
        };
        return React.createElement(
          dxReactCore.Plugin,
          { name: 'Axis' },
          React.createElement(dxReactCore.Getter, { name: 'axes', computed: getAxes }),
          React.createElement(
            dxReactCore.Template,
            { name: position + '-axis' },
            React.createElement(dxReactCore.TemplatePlaceholder, null),
            React.createElement(
              dxReactCore.TemplateConnector,
              null,
              function (_ref4, _ref5) {
                var domains = _ref4.domains,
                    scales = _ref4.scales,
                    layouts = _ref4.layouts;
                var changeBBox = _ref5.changeBBox;

                // TODO: Take axis from "axes" getter rather then from closure.
                var placeholder = position + '-axis';
                var domain = domains[name];
                var scale = scales[name];
                // TODO_DEBUG
                if (!domain) {
                  throw new Error('domain is not found: ' + name);
                }
                // TODO_DEBUG
                var orientation = domain.orientation;

                var _ref6 = layouts[placeholder] || { width: 0, height: 0 },
                    widthCalculated = _ref6.width,
                    heightCalculated = _ref6.height;

                var _calculateLayout = _this3.calculateLayout(widthCalculated, heightCalculated, 0, 0),
                    widthPostCalculated = _calculateLayout.width,
                    heightPostCalculated = _calculateLayout.height;
                // Isn't it too late to adjust sizes?


                var postCalculatedScale = scale.copy().range(orientation === dxChartCore.HORIZONTAL ? [0, widthPostCalculated] : [heightPostCalculated, 0]);
                var coordinates = dxChartCore.axisCoordinates(
                // TODO: Only *orientation* and *tickFormat* are taken from *domain* -
                // take *tickFormat* directly from props.
                domain, postCalculatedScale, position, tickSize, indentFromAxis);
                var _state2 = _this3.state,
                    xCorrection = _state2.xCorrection,
                    yCorrection = _state2.yCorrection;


                return React.createElement(
                  'div',
                  {
                    style: {
                      position: 'relative',
                      width: orientation === dxChartCore.HORIZONTAL ? undefined : widthCalculated,
                      height: orientation === dxChartCore.HORIZONTAL ? heightCalculated : null,
                      flexGrow: orientation === dxChartCore.HORIZONTAL ? 1 : undefined
                    },
                    ref: function ref(node) {
                      _this3.node = node;
                    }
                  },
                  React.createElement(
                    'svg',
                    {
                      width: widthPostCalculated,
                      height: heightPostCalculated,
                      style: {
                        position: 'absolute', left: 0, top: 0, overflow: 'visible'
                      }
                    },
                    React.createElement(
                      RootComponent,
                      {
                        refsHandler: _this3.createRefsHandler(placeholder, changeBBox, {
                          getWidth: orientation !== dxChartCore.HORIZONTAL ? getCorrectSize(position) : getCurrentSize,
                          getHeight: orientation === dxChartCore.HORIZONTAL ? getCorrectSize(position) : getCurrentSize,
                          getXCorrection: orientation !== dxChartCore.HORIZONTAL ? getCorrection(position) : getZeroCoord,
                          getYCorrection: orientation === dxChartCore.HORIZONTAL ? getCorrection(position) : getZeroCoord
                        }),
                        x: -xCorrection,
                        y: -yCorrection
                      },
                      coordinates.ticks.map(function (_ref7) {
                        var x1 = _ref7.x1,
                            x2 = _ref7.x2,
                            y1 = _ref7.y1,
                            y2 = _ref7.y2,
                            key = _ref7.key;
                        return React.createElement(TickComponent, {
                          key: key,
                          x1: x1,
                          x2: x2,
                          y1: y1,
                          y2: y2
                        });
                      }),
                      React.createElement(LineComponent, {
                        width: widthPostCalculated,
                        height: heightPostCalculated,
                        orientation: orientation
                      }),
                      coordinates.ticks.map(function (_ref8) {
                        var text = _ref8.text,
                            xText = _ref8.xText,
                            yText = _ref8.yText,
                            dominantBaseline = _ref8.dominantBaseline,
                            textAnchor = _ref8.textAnchor,
                            key = _ref8.key;
                        return React.createElement(
                          React.Fragment,
                          { key: key },
                          React.createElement(LabelComponent, {
                            text: text,
                            x: xText,
                            y: yText,
                            dominantBaseline: dominantBaseline,
                            textAnchor: textAnchor
                          })
                        );
                      })
                    )
                  )
                );
              }
            )
          )
        );
      }
    }]);
    return RawAxis;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? RawAxis.propTypes = {
    name: PropTypes.string.isRequired,
    rootComponent: PropTypes.func.isRequired,
    tickComponent: PropTypes.func.isRequired,
    labelComponent: PropTypes.func.isRequired,
    lineComponent: PropTypes.func.isRequired,
    position: PropTypes.string.isRequired,
    tickSize: PropTypes.number,
    indentFromAxis: PropTypes.number
  } : void 0;

  RawAxis.defaultProps = {
    tickSize: 5,
    indentFromAxis: 10
  };

  RawAxis.components = {
    rootComponent: 'Root',
    tickComponent: 'Tick',
    labelComponent: 'Label',
    lineComponent: 'Line'
  };

  var Axis = withComponents({
    Root: Root$1, Tick: Tick, Label: Label$1, Line: Line
  })(RawAxis);

  // TODO: It is not axis who defines that argument is HORIZONTAL and value is VERTICAL.

  // TODO: Check that only BOTTOM and TOP are accepted.
  var ArgumentAxis = withPatchedProps(function (props) {
    return _extends({
      position: dxChartCore.BOTTOM
    }, props, {
      name: dxChartCore.ARGUMENT_DOMAIN
    });
  })(Axis);

  // TODO: Check that only LEFT and RIGHT are accepted.
  var ValueAxis = withPatchedProps(function (props) {
    return _extends({
      position: dxChartCore.LEFT
    }, props, {
      name: dxChartCore.getValueDomainName(props.name)
    });
  })(Axis);

  ArgumentAxis.components = Axis.components;
  ValueAxis.components = Axis.components;

  var Line$1 = function (_React$PureComponent) {
    inherits(Line, _React$PureComponent);

    function Line() {
      classCallCheck(this, Line);
      return possibleConstructorReturn(this, (Line.__proto__ || Object.getPrototypeOf(Line)).apply(this, arguments));
    }

    createClass(Line, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            x1 = _props.x1,
            x2 = _props.x2,
            y1 = _props.y1,
            y2 = _props.y2,
            restProps = objectWithoutProperties(_props, ['x1', 'x2', 'y1', 'y2']);

        return React.createElement('path', _extends({
          d: 'M ' + x1 + ' ' + y1 + ' L ' + x2 + ' ' + y2
        }, restProps));
      }
    }]);
    return Line;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? Line$1.propTypes = {
    x1: PropTypes.number.isRequired,
    x2: PropTypes.number.isRequired,
    y1: PropTypes.number.isRequired,
    y2: PropTypes.number.isRequired
  } : void 0;

  var RawGrid = function (_React$PureComponent) {
    inherits(RawGrid, _React$PureComponent);

    function RawGrid() {
      classCallCheck(this, RawGrid);
      return possibleConstructorReturn(this, (RawGrid.__proto__ || Object.getPrototypeOf(RawGrid)).apply(this, arguments));
    }

    createClass(RawGrid, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            name = _props.name,
            LineComponent = _props.lineComponent,
            restProps = objectWithoutProperties(_props, ['name', 'lineComponent']);

        return React.createElement(
          dxReactCore.Plugin,
          { name: 'Grid' },
          React.createElement(
            dxReactCore.Template,
            { name: 'series' },
            React.createElement(dxReactCore.TemplatePlaceholder, null),
            React.createElement(
              dxReactCore.TemplateConnector,
              null,
              function (_ref) {
                var domains = _ref.domains,
                    scales = _ref.scales,
                    layouts = _ref.layouts;

                var domain = domains[name];
                var scale = scales[name];
                var orientation = domain.orientation;
                var _layouts$pane = layouts.pane,
                    width = _layouts$pane.width,
                    height = _layouts$pane.height;


                var coordinates = dxChartCore.axisCoordinates(domain, scale, orientation === dxChartCore.HORIZONTAL ? dxChartCore.TOP : dxChartCore.LEFT, 0, undefined);

                return React.createElement(
                  React.Fragment,
                  null,
                  coordinates.ticks.map(function (_ref2) {
                    var x1 = _ref2.x1,
                        x2 = _ref2.x2,
                        y1 = _ref2.y1,
                        y2 = _ref2.y2,
                        key = _ref2.key;
                    return React.createElement(LineComponent, _extends({
                      key: key,
                      x1: orientation === dxChartCore.HORIZONTAL ? x1 : width,
                      x2: x2,
                      y1: orientation === dxChartCore.HORIZONTAL ? height : y1,
                      y2: y2
                    }, restProps));
                  })
                );
              }
            )
          )
        );
      }
    }]);
    return RawGrid;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? RawGrid.propTypes = {
    name: PropTypes.string.isRequired,
    lineComponent: PropTypes.func.isRequired
  } : void 0;

  RawGrid.components = {
    lineComponent: 'Line'
  };

  var Grid = withComponents({ Line: Line$1 })(RawGrid);

  var ArgumentGrid = withPatchedProps(function (props) {
    return _extends({}, props, {
      name: dxChartCore.ARGUMENT_DOMAIN
    });
  })(Grid);

  var ValueGrid = withPatchedProps(function (props) {
    return _extends({}, props, {
      name: dxChartCore.getValueDomainName(props.name)
    });
  })(Grid);

  ArgumentGrid.components = Grid.components;
  ValueGrid.components = Grid.components;

  var wrapToList = function wrapToList(arg) {
    return arg ? [arg] : [];
  };

  var EVENT_NAME_MAP = {
    click: 'onClick',
    pointermove: 'onPointerMove',
    pointerleave: 'onPointerLeave'
  };

  var translateEventNames = function translateEventNames(handlers) {
    var result = {};
    Object.entries(handlers).forEach(function (_ref) {
      var _ref2 = slicedToArray(_ref, 2),
          name = _ref2[0],
          handler = _ref2[1];

      result[EVENT_NAME_MAP[name]] = handler;
    });
    return result;
  };

  // eslint-disable-next-line react/no-multi-comp
  var EventTracker = function (_React$PureComponent) {
    inherits(EventTracker, _React$PureComponent);

    function EventTracker() {
      classCallCheck(this, EventTracker);
      return possibleConstructorReturn(this, (EventTracker.__proto__ || Object.getPrototypeOf(EventTracker)).apply(this, arguments));
    }

    createClass(EventTracker, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            onClick = _props.onClick,
            onPointerMove = _props.onPointerMove;

        return React.createElement(
          dxReactCore.Plugin,
          { name: 'EventTracker' },
          React.createElement(dxReactCore.Getter, { name: 'clickHandlers', value: wrapToList(onClick) }),
          React.createElement(dxReactCore.Getter, { name: 'pointerMoveHandlers', value: wrapToList(onPointerMove) }),
          React.createElement(
            dxReactCore.Template,
            { name: 'canvas' },
            React.createElement(
              dxReactCore.TemplateConnector,
              null,
              function (_ref3) {
                var series = _ref3.series,
                    clickHandlers = _ref3.clickHandlers,
                    pointerMoveHandlers = _ref3.pointerMoveHandlers;

                var handlers = dxChartCore.buildEventHandlers(series, { clickHandlers: clickHandlers, pointerMoveHandlers: pointerMoveHandlers });
                return React.createElement(dxReactCore.TemplatePlaceholder, { params: translateEventNames(handlers) });
              }
            )
          )
        );
      }
    }]);
    return EventTracker;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? EventTracker.propTypes = {
    onClick: PropTypes.func,
    onPointerMove: PropTypes.func
  } : void 0;

  EventTracker.defaultProps = {
    onClick: undefined,
    onPointerMove: undefined
  };

  var HoverState = function (_React$PureComponent) {
    inherits(HoverState, _React$PureComponent);

    function HoverState(props) {
      classCallCheck(this, HoverState);

      var _this = possibleConstructorReturn(this, (HoverState.__proto__ || Object.getPrototypeOf(HoverState)).call(this, props));

      _this.state = {
        hover: props.hover || props.defaultHover
      };
      var handlePointerMove = _this.handlePointerMove.bind(_this);
      _this.getPointerMoveHandlers = function (_ref) {
        var pointerMoveHandlers = _ref.pointerMoveHandlers;
        return [].concat(toConsumableArray(pointerMoveHandlers), [handlePointerMove]);
      };
      return _this;
    }

    createClass(HoverState, [{
      key: 'handlePointerMove',
      value: function handlePointerMove(_ref2) {
        var targets = _ref2.targets;
        var onHoverChange = this.props.onHoverChange;
        var currentTarget = this.state.hover;

        var hover = dxChartCore.processPointerMove(targets, currentTarget, onHoverChange);
        if (hover !== undefined) {
          this.setState({ hover: hover });
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var hover = this.state.hover;
        // Function has to be recreated every time as there is no other way
        // to notify that "series" is updated.

        var getSeries = function getSeries(_ref3) {
          var series = _ref3.series;
          return dxChartCore.changeSeriesState(series, dxChartCore.getHoverTargets(hover), dxChartCore.HOVERED);
        };
        return React.createElement(
          dxReactCore.Plugin,
          { name: 'HoverState' },
          React.createElement(dxReactCore.Getter, { name: 'pointerMoveHandlers', computed: this.getPointerMoveHandlers }),
          React.createElement(dxReactCore.Getter, { name: 'series', computed: getSeries })
        );
      }
    }], [{
      key: 'getDerivedStateFromProps',
      value: function getDerivedStateFromProps(props, state) {
        return { hover: props.hover !== undefined ? props.hover : state.hover };
      }
    }]);
    return HoverState;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? HoverState.propTypes = {
    defaultHover: PropTypes.shape({
      series: PropTypes.string.isRequired,
      point: PropTypes.number
    }),
    hover: PropTypes.shape({
      series: PropTypes.string.isRequired,
      point: PropTypes.number
    }),
    onHoverChange: PropTypes.func
  } : void 0;

  HoverState.defaultProps = {
    defaultHover: undefined,
    hover: undefined,
    onHoverChange: undefined
  };

  var SelectionState = function (_React$PureComponent) {
    inherits(SelectionState, _React$PureComponent);

    function SelectionState() {
      classCallCheck(this, SelectionState);
      return possibleConstructorReturn(this, (SelectionState.__proto__ || Object.getPrototypeOf(SelectionState)).apply(this, arguments));
    }

    createClass(SelectionState, [{
      key: 'render',
      value: function render() {
        var selection = this.props.selection;

        var getSeries = function getSeries(_ref) {
          var series = _ref.series;
          return dxChartCore.changeSeriesState(series, selection, dxChartCore.SELECTED);
        };
        return React.createElement(
          dxReactCore.Plugin,
          { name: 'SelectionState' },
          React.createElement(dxReactCore.Getter, { name: 'series', computed: getSeries })
        );
      }
    }]);
    return SelectionState;
  }(React.PureComponent);

  process.env.NODE_ENV !== "production" ? SelectionState.propTypes = {
    selection: PropTypes.arrayOf(PropTypes.shape({
      series: PropTypes.string.isRequired,
      point: PropTypes.number
    }))
  } : void 0;

  SelectionState.defaultProps = {
    selection: []
  };

  exports.Chart = Chart;
  exports.Legend = Legend;
  exports.Title = Title;
  exports.Scale = Scale;
  exports.Stack = Stack;
  exports.Palette = Palette;
  exports.Animation = Animation;
  exports.AreaSeries = AreaSeries;
  exports.BarSeries = BarSeries;
  exports.LineSeries = LineSeries;
  exports.PieSeries = PieSeries;
  exports.ScatterSeries = ScatterSeries;
  exports.SplineSeries = SplineSeries;
  exports.Axis = Axis;
  exports.ArgumentAxis = ArgumentAxis;
  exports.ValueAxis = ValueAxis;
  exports.Grid = Grid;
  exports.ArgumentGrid = ArgumentGrid;
  exports.ValueGrid = ValueGrid;
  exports.withPatchedProps = withPatchedProps;
  exports.withComponents = withComponents;
  exports.EventTracker = EventTracker;
  exports.HoverState = HoverState;
  exports.SelectionState = SelectionState;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=dx-react-chart.umd.js.map
