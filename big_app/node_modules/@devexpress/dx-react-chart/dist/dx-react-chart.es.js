/**
 * Bundle of @devexpress/dx-react-chart
 * Generated: 2018-11-07
 * Version: 1.9.0
 * License: https://js.devexpress.com/Licensing
 */

import { createElement, PureComponent, Fragment, Component, isValidElement } from 'react';
import { array, func, number, node, string, arrayOf, shape, object, oneOfType } from 'prop-types';
import { Plugin, Getter, Template, TemplatePlaceholder, TemplateConnector, Sizer, Action, createStateHelper, PluginHost } from '@devexpress/dx-react-core';
import { computeDomains, buildScales, scaleSeriesPoints, TOP, BOTTOM, LEFT, RIGHT, bBoxes, findSeriesByName, addSeries, getValueDomainName, ARGUMENT_DOMAIN, getLegendItems, computeExtension, getStackedSeries, buildAnimatedStyleGetter, getAreaAnimationStyle, HOVERED, SELECTED, dArea, getAreaPointTransformer, createAreaHitTester, dBar, getBarPointTransformer, createBarHitTester, dLine, createLineHitTester, getPieAnimationStyle, getPiePointTransformer, createPieHitTester, pointAttributes, getScatterAnimationStyle, createScatterHitTester, dSpline, createSplineHitTester, axisCoordinates, HORIZONTAL, axesData, buildEventHandlers, changeSeriesState, processPointerMove, getHoverTargets } from '@devexpress/dx-chart-core';
import { stackOrderNone, stackOffsetDiverging } from 'd3-shape';

var BasicData = function BasicData(_ref) {
  var data = _ref.data;
  return createElement(
    Plugin,
    { name: 'Basis' },
    createElement(Getter, { name: 'data', value: data }),
    createElement(Getter, { name: 'series', value: [] }),
    createElement(Getter, { name: 'axes', value: [] }),
    createElement(Getter, { name: 'getAnimatedStyle', value: function value(style) {
        return style;
      } })
  );
};

process.env.NODE_ENV !== "production" ? BasicData.propTypes = {
  data: array.isRequired
} : void 0;

var getDomains = function getDomains(_ref) {
  var axes = _ref.axes,
      series = _ref.series;
  return computeDomains(axes, series);
};

var getScales = function getScales(_ref2) {
  var domains = _ref2.domains,
      layouts = _ref2.layouts,
      scaleExtension = _ref2.scaleExtension;
  return buildScales(domains, scaleExtension, layouts.pane);
};

var getSeries = function getSeries(_ref3) {
  var series = _ref3.series,
      scales = _ref3.scales,
      stacks = _ref3.stacks,
      scaleExtension = _ref3.scaleExtension;
  return scaleSeriesPoints(series, scales, stacks, scaleExtension);
};

var ChartCore = function ChartCore() {
  return createElement(
    Plugin,
    null,
    createElement(Getter, { name: 'domains', computed: getDomains }),
    createElement(Getter, { name: 'scales', computed: getScales }),
    createElement(Getter, { name: 'series', computed: getSeries })
  );
};

var AxesLayout = function AxesLayout() {
  return createElement(
    Plugin,
    null,
    createElement(
      Template,
      { name: 'canvas' },
      createElement(
        'div',
        { id: 'center-center', style: { display: 'flex', flexDirection: 'column', flexGrow: 1 } },
        createElement(
          'div',
          { id: TOP + '-axis-container', style: { display: 'flex', flexDirection: 'row' } },
          createElement(TemplatePlaceholder, { name: TOP + '-' + LEFT + '-axis' }),
          createElement(TemplatePlaceholder, { name: TOP + '-axis' }),
          createElement(TemplatePlaceholder, { name: TOP + '-' + RIGHT + '-axis' })
        ),
        createElement(
          'div',
          { id: 'center-axis-container', style: { display: 'flex', flexDirection: 'row', flexGrow: 1 } },
          createElement(TemplatePlaceholder, { name: LEFT + '-axis' }),
          createElement(TemplatePlaceholder, null),
          createElement(TemplatePlaceholder, { name: RIGHT + '-axis' })
        ),
        createElement(
          'div',
          { id: BOTTOM + '-axis-container', style: { display: 'flex', flexDirection: 'row' } },
          createElement(TemplatePlaceholder, { name: BOTTOM + '-' + LEFT + '-axis' }),
          createElement(TemplatePlaceholder, { name: BOTTOM + '-axis' }),
          createElement(TemplatePlaceholder, { name: BOTTOM + '-' + RIGHT + '-axis' })
        )
      )
    )
  );
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var SpaceFillingRects = function (_React$PureComponent) {
  inherits(SpaceFillingRects, _React$PureComponent);

  function SpaceFillingRects() {
    classCallCheck(this, SpaceFillingRects);
    return possibleConstructorReturn(this, (SpaceFillingRects.__proto__ || Object.getPrototypeOf(SpaceFillingRects)).apply(this, arguments));
  }

  createClass(SpaceFillingRects, [{
    key: 'render',
    value: function render() {
      var placeholders = this.props.placeholders;

      return createElement(
        Plugin,
        { name: 'SpaceFillingRects' },
        placeholders.map(function (name) {
          return createElement(
            Template,
            { name: name, key: name },
            createElement(
              TemplateConnector,
              null,
              function (_ref) {
                var positions = _ref.layouts;

                var _name$split = name.split('-'),
                    _name$split2 = slicedToArray(_name$split, 3),
                    horizontal = _name$split2[1],
                    postfix = _name$split2[2];

                var _ref2 = positions[horizontal + (postfix ? '-' + postfix : '')] || {},
                    width = _ref2.width;

                return createElement('div', { id: name, style: { width: width } });
              }
            )
          );
        })
      );
    }
  }]);
  return SpaceFillingRects;
}(PureComponent);

process.env.NODE_ENV !== "production" ? SpaceFillingRects.propTypes = {
  placeholders: arrayOf(string).isRequired
} : void 0;

/* eslint-disable-next-line react/prefer-stateless-function */
var PaneLayout = function (_React$PureComponent) {
  inherits(PaneLayout, _React$PureComponent);

  function PaneLayout(props) {
    classCallCheck(this, PaneLayout);

    var _this = possibleConstructorReturn(this, (PaneLayout.__proto__ || Object.getPrototypeOf(PaneLayout)).call(this, props));

    _this.state = {
      width: 800,
      height: 600
    };
    return _this;
  }

  createClass(PaneLayout, [{
    key: 'handleSizeUpdate',
    value: function handleSizeUpdate(_ref, changeBBox) {
      var width = _ref.width,
          height = _ref.height;

      this.setState({ width: width, height: height });
      changeBBox({ placeholder: 'pane', bBox: { width: width, height: height } });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _state = this.state,
          width = _state.width,
          height = _state.height;


      return createElement(
        Plugin,
        { name: 'PaneLayout' },
        createElement(
          Template,
          { name: 'canvas' },
          function (params) {
            return createElement(
              TemplateConnector,
              null,
              function (_, _ref2) {
                var changeBBox = _ref2.changeBBox;
                return createElement(
                  Sizer,
                  {
                    style: { flex: 1, zIndex: 1 },
                    onSizeChange: function onSizeChange(size) {
                      return _this2.handleSizeUpdate(size, changeBBox);
                    }
                  },
                  createElement(
                    'div',
                    { style: { width: '100%' } },
                    createElement(
                      'svg',
                      _extends({}, params, {
                        width: width,
                        height: height,
                        style: {
                          position: 'absolute', left: 0, top: 0, overflow: 'visible'
                        }
                      }),
                      createElement(TemplatePlaceholder, { name: 'series' })
                    )
                  )
                );
              }
            );
          }
        )
      );
    }
  }]);
  return PaneLayout;
}(PureComponent);

var LayoutManager = function (_React$Component) {
  inherits(LayoutManager, _React$Component);

  function LayoutManager(props) {
    classCallCheck(this, LayoutManager);

    var _this = possibleConstructorReturn(this, (LayoutManager.__proto__ || Object.getPrototypeOf(LayoutManager)).call(this, props));

    var _this$props = _this.props,
        width = _this$props.width,
        height = _this$props.height;


    _this.state = { bBoxes: { pane: { width: width, height: height } } };

    var stateHelper = createStateHelper(_this);

    _this.changeBBox = stateHelper.applyFieldReducer.bind(stateHelper, 'bBoxes', bBoxes);
    return _this;
  }

  createClass(LayoutManager, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          width = _props.width,
          height = _props.height,
          Root = _props.rootComponent,
          restProps = objectWithoutProperties(_props, ['width', 'height', 'rootComponent']);
      var stateBBoxes = this.state.bBoxes;


      return createElement(
        Plugin,
        null,
        createElement(Getter, { name: 'layouts', value: stateBBoxes }),
        createElement(Action, { name: 'changeBBox', action: this.changeBBox }),
        createElement(
          Template,
          { name: 'root' },
          createElement(
            Root,
            _extends({
              height: height,
              width: width
            }, restProps),
            createElement(TemplatePlaceholder, { name: 'canvas' })
          )
        )
      );
    }
  }]);
  return LayoutManager;
}(Component);

process.env.NODE_ENV !== "production" ? LayoutManager.propTypes = {
  width: number,
  height: number.isRequired,
  rootComponent: func.isRequired
} : void 0;

LayoutManager.defaultProps = {
  width: 0
};

var ComponentLayout = function ComponentLayout() {
  return createElement(
    Plugin,
    { name: 'ComponentLayout' },
    createElement(
      Template,
      { name: 'canvas' },
      createElement(
        'div',
        { id: TOP + '-container', style: { display: 'flex', flexDirection: 'row' } },
        createElement(TemplatePlaceholder, { name: TOP + '-' + LEFT }),
        createElement(TemplatePlaceholder, { name: TOP }),
        createElement(TemplatePlaceholder, { name: TOP + '-' + LEFT })
      ),
      createElement(
        'div',
        { id: 'center-container', style: { display: 'flex', flexDirection: 'row', flexGrow: 1 } },
        createElement(TemplatePlaceholder, { name: LEFT }),
        createElement(TemplatePlaceholder, null),
        createElement(TemplatePlaceholder, { name: RIGHT })
      ),
      createElement(
        'div',
        { id: BOTTOM + '-container', style: { display: 'flex', flexDirection: 'row' } },
        createElement(TemplatePlaceholder, { name: BOTTOM + '-' + LEFT }),
        createElement(TemplatePlaceholder, { name: BOTTOM })
      )
    )
  );
};

// TODO: Remove "palette" getter from BasicData and add Palette to Chart
// when "paletteComputing" is removed.
var Palette = function (_React$PureComponent) {
  inherits(Palette, _React$PureComponent);

  function Palette() {
    classCallCheck(this, Palette);
    return possibleConstructorReturn(this, (Palette.__proto__ || Object.getPrototypeOf(Palette)).apply(this, arguments));
  }

  createClass(Palette, [{
    key: 'render',
    value: function render() {
      var scheme = this.props.scheme;

      return createElement(
        Plugin,
        { name: 'Palette' },
        createElement(Getter, { name: 'palette', value: scheme })
      );
    }
  }]);
  return Palette;
}(PureComponent);

process.env.NODE_ENV !== "production" ? Palette.propTypes = {
  scheme: array.isRequired
} : void 0;

var Root = function (_React$PureComponent) {
  inherits(Root, _React$PureComponent);

  function Root() {
    classCallCheck(this, Root);
    return possibleConstructorReturn(this, (Root.__proto__ || Object.getPrototypeOf(Root)).apply(this, arguments));
  }

  createClass(Root, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          children = _props.children,
          width = _props.width,
          height = _props.height,
          style = _props.style,
          restProps = objectWithoutProperties(_props, ['children', 'width', 'height', 'style']);


      return createElement(
        'div',
        _extends({
          style: _extends({}, style, {
            height: height + 'px'
          }, width ? { width: width + 'px' } : null)
        }, restProps),
        children
      );
    }
  }]);
  return Root;
}(PureComponent);

process.env.NODE_ENV !== "production" ? Root.propTypes = {
  children: node,
  width: number.isRequired,
  height: number.isRequired,
  style: object
} : void 0;

Root.defaultProps = {
  children: undefined,
  style: undefined
};

var Label = function (_React$PureComponent) {
  inherits(Label, _React$PureComponent);

  function Label() {
    classCallCheck(this, Label);
    return possibleConstructorReturn(this, (Label.__proto__ || Object.getPrototypeOf(Label)).apply(this, arguments));
  }

  createClass(Label, [{
    key: 'render',
    value: function render() {
      return createElement('text', this.props);
    }
  }]);
  return Label;
}(PureComponent);

process.env.NODE_ENV !== "production" ? Label.propTypes = {
  children: oneOfType([string, number]).isRequired,
  x: number.isRequired,
  y: number.isRequired
} : void 0;

var makeBoundComponent = function makeBoundComponent(Target, components, exposed) {
  var Component$$1 = function (_React$PureComponent) {
    inherits(Component$$1, _React$PureComponent);

    function Component$$1() {
      classCallCheck(this, Component$$1);
      return possibleConstructorReturn(this, (Component$$1.__proto__ || Object.getPrototypeOf(Component$$1)).apply(this, arguments));
    }

    createClass(Component$$1, [{
      key: 'render',
      value: function render() {
        return createElement(Target, _extends({}, components, this.props));
      }
    }]);
    return Component$$1;
  }(PureComponent);

  Component$$1.components = Target.components;
  Object.assign(Component$$1, exposed);
  return Component$$1;
};

var withComponents = function withComponents(components) {
  return function (Target) {
    var props = {};
    var exposed = {};
    Object.entries(Target.components).forEach(function (_ref) {
      var _ref2 = slicedToArray(_ref, 2),
          fieldName = _ref2[0],
          componentName = _ref2[1];

      var component = components[componentName];
      if (component && component !== Target[componentName]) {
        props[fieldName] = component;
      }
      exposed[componentName] = component || Target[componentName];
    });
    return Object.keys(props).length > 0 ? makeBoundComponent(Target, props, exposed) : Target;
  };
};

// May be it is better to say what props are passed along rather then what are NOT passed?
var getRenderProps = function getRenderProps(series) {
  var name = series.name,
      uniqueName = series.uniqueName,
      axisName = series.axisName,
      argumentField = series.argumentField,
      valueField = series.valueField,
      palette = series.palette,
      symbolName = series.symbolName,
      isStartedFromZero = series.isStartedFromZero,
      getValueDomain = series.getValueDomain,
      createHitTester = series.createHitTester,
      restProps = objectWithoutProperties(series, ['name', 'uniqueName', 'axisName', 'argumentField', 'valueField', 'palette', 'symbolName', 'isStartedFromZero', 'getValueDomain', 'createHitTester']);


  return restProps;
};

var declareSeries = function declareSeries(pluginName, _ref) {
  var components = _ref.components,
      parameters = objectWithoutProperties(_ref, ['components']);

  var Component$$1 = function (_React$PureComponent) {
    inherits(Component$$1, _React$PureComponent);

    function Component$$1() {
      classCallCheck(this, Component$$1);
      return possibleConstructorReturn(this, (Component$$1.__proto__ || Object.getPrototypeOf(Component$$1)).apply(this, arguments));
    }

    createClass(Component$$1, [{
      key: 'render',
      value: function render() {
        var name = this.props.name;

        var symbolName = Symbol(name);
        var seriesItem = _extends({}, parameters, this.props, {
          symbolName: symbolName
        });
        var getSeries = function getSeries(_ref2) {
          var series = _ref2.series,
              data = _ref2.data,
              palette = _ref2.palette;
          return addSeries(series, data, palette, seriesItem);
        };
        return createElement(
          Plugin,
          { name: pluginName },
          createElement(Getter, { name: 'series', computed: getSeries }),
          createElement(
            Template,
            { name: 'series' },
            createElement(TemplatePlaceholder, null),
            createElement(
              TemplateConnector,
              null,
              function (_ref3) {
                var series = _ref3.series,
                    scales = _ref3.scales,
                    getAnimatedStyle = _ref3.getAnimatedStyle;

                var currentSeries = findSeriesByName(symbolName, series);
                var currentScales = {
                  xScale: scales[ARGUMENT_DOMAIN],
                  yScale: scales[getValueDomainName(currentSeries.axisName)]
                };

                var _getRenderProps = getRenderProps(currentSeries),
                    Series = _getRenderProps.seriesComponent,
                    points = _getRenderProps.points,
                    props = objectWithoutProperties(_getRenderProps, ['seriesComponent', 'points']);

                return createElement(Series, _extends({
                  coordinates: points,
                  scales: currentScales,
                  getAnimatedStyle: getAnimatedStyle
                }, props));
              }
            )
          )
        );
      }
    }]);
    return Component$$1;
  }(PureComponent);

  process.env.NODE_ENV !== "production" ? Component$$1.propTypes = {
    name: string,
    /* eslint-disable react/no-unused-prop-types */
    valueField: string.isRequired,
    argumentField: string.isRequired
    /* eslint-enable react/no-unused-prop-types */
  } : void 0;
  Component$$1.defaultProps = {
    name: 'defaultSeriesName'
  };
  Component$$1.components = {};
  if (components.Path) {
    Component$$1.components.seriesComponent = 'Path';
  }
  if (components.Point) {
    Component$$1.components.pointComponent = 'Point';
  }
  return withComponents(components)(Component$$1);
};

var withPatchedProps = function withPatchedProps(patch) {
  return function (Target) {
    var Component$$1 = function (_React$PureComponent) {
      inherits(Component$$1, _React$PureComponent);

      function Component$$1() {
        classCallCheck(this, Component$$1);
        return possibleConstructorReturn(this, (Component$$1.__proto__ || Object.getPrototypeOf(Component$$1)).apply(this, arguments));
      }

      createClass(Component$$1, [{
        key: 'render',
        value: function render() {
          var props = patch(this.props);
          return createElement(Target, props);
        }
      }]);
      return Component$$1;
    }(PureComponent);

    return Component$$1;
  };
};

var RawChart = function (_React$PureComponent) {
  inherits(RawChart, _React$PureComponent);

  function RawChart() {
    classCallCheck(this, RawChart);
    return possibleConstructorReturn(this, (RawChart.__proto__ || Object.getPrototypeOf(RawChart)).apply(this, arguments));
  }

  createClass(RawChart, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          data = _props.data,
          width = _props.width,
          height = _props.height,
          children = _props.children,
          rootComponent = _props.rootComponent,
          restProps = objectWithoutProperties(_props, ['data', 'width', 'height', 'children', 'rootComponent']);

      return createElement(
        PluginHost,
        null,
        createElement(BasicData, { data: data }),
        createElement(Palette, { scheme: [] }),
        createElement(LayoutManager, _extends({
          width: width,
          height: height,
          rootComponent: rootComponent
        }, restProps)),
        createElement(PaneLayout, null),
        createElement(AxesLayout, null),
        createElement(ComponentLayout, null),
        createElement(SpaceFillingRects, { placeholders: [TOP + '-' + LEFT, TOP + '-' + RIGHT, BOTTOM + '-' + LEFT, BOTTOM + '-' + RIGHT, TOP + '-' + LEFT + '-axis', TOP + '-' + RIGHT + '-axis', BOTTOM + '-' + LEFT + '-axis', BOTTOM + '-' + RIGHT + '-axis']
        }),
        children,
        createElement(ChartCore, null)
      );
    }
  }]);
  return RawChart;
}(PureComponent);

process.env.NODE_ENV !== "production" ? RawChart.propTypes = {
  data: array.isRequired,
  rootComponent: func.isRequired,
  width: number,
  height: number,
  children: node
} : void 0;

RawChart.defaultProps = {
  height: 500,
  width: undefined,
  children: null
};

RawChart.components = {
  rootComponent: 'Root'
};

var Chart = withComponents({ Root: Root })(RawChart);
Chart.Label = Label;

var Marker = function (_React$PureComponent) {
  inherits(Marker, _React$PureComponent);

  function Marker() {
    classCallCheck(this, Marker);
    return possibleConstructorReturn(this, (Marker.__proto__ || Object.getPrototypeOf(Marker)).apply(this, arguments));
  }

  createClass(Marker, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          color = _props.color,
          restProps = objectWithoutProperties(_props, ['color']);

      return createElement(
        'svg',
        _extends({ fill: color, width: '10', height: '10' }, restProps),
        createElement('circle', _extends({ r: 5, cx: 5, cy: 5 }, restProps))
      );
    }
  }]);
  return Marker;
}(PureComponent);

process.env.NODE_ENV !== "production" ? Marker.propTypes = {
  color: string
} : void 0;

Marker.defaultProps = {
  color: undefined
};

var RawLegend = function (_React$PureComponent) {
  inherits(RawLegend, _React$PureComponent);

  function RawLegend() {
    classCallCheck(this, RawLegend);
    return possibleConstructorReturn(this, (RawLegend.__proto__ || Object.getPrototypeOf(RawLegend)).apply(this, arguments));
  }

  createClass(RawLegend, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          MarkerComponent = _props.markerComponent,
          Label = _props.labelComponent,
          Root = _props.rootComponent,
          Item = _props.itemComponent,
          position = _props.position,
          getItems = _props.getItems;

      var placeholder = position;
      return createElement(
        Plugin,
        { name: 'Legend' },
        createElement(
          Template,
          { name: placeholder },
          createElement(TemplatePlaceholder, null),
          createElement(
            TemplateConnector,
            null,
            function (getters) {
              return createElement(
                Root,
                { name: 'legend-' + placeholder },
                getItems(getters).map(function (_ref) {
                  var text = _ref.text,
                      color = _ref.color;
                  return createElement(
                    Item,
                    { key: text },
                    createElement(MarkerComponent, { name: text, color: color }),
                    createElement(Label, { text: text })
                  );
                })
              );
            }
          )
        )
      );
    }
  }]);
  return RawLegend;
}(PureComponent);

process.env.NODE_ENV !== "production" ? RawLegend.propTypes = {
  markerComponent: func.isRequired,
  labelComponent: func.isRequired,
  rootComponent: func.isRequired,
  itemComponent: func.isRequired,
  position: string,
  getItems: func
} : void 0;

RawLegend.defaultProps = {
  position: 'right',
  getItems: function getItems(_ref2) {
    var series = _ref2.series;
    return getLegendItems(series);
  }
};

RawLegend.components = {
  rootComponent: 'Root',
  itemComponent: 'Item',
  markerComponent: 'Marker',
  labelComponent: 'Label'
};

var Legend = withComponents({ Marker: Marker })(RawLegend);

var Title = function (_React$PureComponent) {
  inherits(Title, _React$PureComponent);

  function Title() {
    classCallCheck(this, Title);
    return possibleConstructorReturn(this, (Title.__proto__ || Object.getPrototypeOf(Title)).apply(this, arguments));
  }

  createClass(Title, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          Text = _props.textComponent,
          text = _props.text,
          position = _props.position,
          restProps = objectWithoutProperties(_props, ['textComponent', 'text', 'position']);

      var placeholder = position;
      return createElement(
        Plugin,
        { name: 'Title' },
        createElement(
          Template,
          { name: placeholder },
          createElement(TemplatePlaceholder, null),
          createElement(Text, _extends({ text: text }, restProps))
        )
      );
    }
  }]);
  return Title;
}(PureComponent);

process.env.NODE_ENV !== "production" ? Title.propTypes = {
  textComponent: func.isRequired,
  text: string.isRequired,
  position: string
} : void 0;

Title.defaultProps = {
  position: 'top'
};

Title.components = {
  textComponent: 'Text'
};

var Scale = function (_React$PureComponent) {
  inherits(Scale, _React$PureComponent);

  function Scale() {
    classCallCheck(this, Scale);
    return possibleConstructorReturn(this, (Scale.__proto__ || Object.getPrototypeOf(Scale)).apply(this, arguments));
  }

  createClass(Scale, [{
    key: 'render',
    value: function render() {
      var extensions = this.props.extensions;

      return createElement(
        Plugin,
        { name: 'Scale' },
        createElement(Getter, { name: 'scaleExtension', value: computeExtension(extensions) })
      );
    }
  }]);
  return Scale;
}(PureComponent);

process.env.NODE_ENV !== "production" ? Scale.propTypes = {
  extensions: arrayOf(shape({
    type: string,
    constructor: func
  }))
} : void 0;

Scale.defaultProps = {
  extensions: []
};

var Stack = function (_React$PureComponent) {
  inherits(Stack, _React$PureComponent);

  function Stack() {
    classCallCheck(this, Stack);
    return possibleConstructorReturn(this, (Stack.__proto__ || Object.getPrototypeOf(Stack)).apply(this, arguments));
  }

  createClass(Stack, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          stacks = _props.stacks,
          offset = _props.offset,
          order = _props.order;

      var params = { stacks: stacks, offset: offset, order: order };
      var getSeries = function getSeries(_ref) {
        var series = _ref.series,
            data = _ref.data;
        return getStackedSeries(series, data, params);
      };
      return createElement(
        Plugin,
        { name: 'Stack' },
        createElement(Getter, { name: 'series', computed: getSeries })
      );
    }
  }]);
  return Stack;
}(PureComponent);

process.env.NODE_ENV !== "production" ? Stack.propTypes = {
  stacks: arrayOf(shape({
    series: arrayOf(string).isRequired
  })),
  offset: func,
  order: func
} : void 0;

Stack.defaultProps = {
  stacks: [],
  offset: stackOffsetDiverging,
  order: stackOrderNone
};

/* eslint-disable-next-line react/prefer-stateless-function */
var Animation = function (_React$PureComponent) {
  inherits(Animation, _React$PureComponent);

  function Animation() {
    classCallCheck(this, Animation);
    return possibleConstructorReturn(this, (Animation.__proto__ || Object.getPrototypeOf(Animation)).apply(this, arguments));
  }

  createClass(Animation, [{
    key: 'render',
    value: function render() {
      return createElement(
        Plugin,
        { name: 'Animation' },
        createElement(Getter, { name: 'getAnimatedStyle', value: buildAnimatedStyleGetter })
      );
    }
  }]);
  return Animation;
}(PureComponent);

var withStates = function withStates(states) {
  return function (Component$$1) {
    var ComponentWithStates = function (_React$PureComponent) {
      inherits(ComponentWithStates, _React$PureComponent);

      function ComponentWithStates() {
        classCallCheck(this, ComponentWithStates);
        return possibleConstructorReturn(this, (ComponentWithStates.__proto__ || Object.getPrototypeOf(ComponentWithStates)).apply(this, arguments));
      }

      createClass(ComponentWithStates, [{
        key: 'render',
        value: function render() {
          var _props = this.props,
              state = _props.state,
              restProps = objectWithoutProperties(_props, ['state']);

          var stateFunc = states[state];
          var result = stateFunc ? stateFunc(restProps) : restProps;
          return isValidElement(result) ? result : createElement(Component$$1, result);
        }
      }]);
      return ComponentWithStates;
    }(PureComponent);

    process.env.NODE_ENV !== "production" ? ComponentWithStates.propTypes = {
      state: string
    } : void 0;
    ComponentWithStates.defaultProps = {
      state: undefined
    };
    return ComponentWithStates;
  };
};

var Pattern = function (_React$PureComponent) {
  inherits(Pattern, _React$PureComponent);

  function Pattern() {
    classCallCheck(this, Pattern);
    return possibleConstructorReturn(this, (Pattern.__proto__ || Object.getPrototypeOf(Pattern)).apply(this, arguments));
  }

  createClass(Pattern, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          id = _props.id,
          size = _props.size,
          color = _props.color,
          opacity = _props.opacity;

      return createElement(
        'defs',
        null,
        createElement(
          'pattern',
          {
            id: id,
            width: size,
            height: size,
            patternUnits: 'userSpaceOnUse'
          },
          createElement('rect', { x: 0, y: 0, width: size, height: size, fill: color, opacity: opacity }),
          createElement('path', {
            d: 'M ' + size / 2 + ' ' + -size / 2 + ' L ' + -size / 2 + ' ' + size / 2 + ' M 0 ' + size + ' L ' + size + ' 0 M ' + size * 1.5 + ' ' + size / 2 + ' L ' + size / 2 + ' ' + size * 1.5,
            strokeWidth: 2,
            stroke: color
          })
        )
      );
    }
  }]);
  return Pattern;
}(PureComponent);

process.env.NODE_ENV !== "production" ? Pattern.propTypes = {
  id: string.isRequired,
  size: number,
  color: string.isRequired,
  opacity: number
} : void 0;

Pattern.defaultProps = {
  size: 6,
  opacity: 0.75
};

// Function is returned (not PureComponent descendant) because
// result is invoked as function (not as React component).
var withPattern = function withPattern(getPatternId, props) {
  return function (Target) {
    return function (_ref) {
      var color = _ref.color,
          restProps = objectWithoutProperties(_ref, ['color']);

      var patternId = getPatternId(restProps);
      return createElement(
        Fragment,
        null,
        createElement(Target, _extends({
          fill: 'url(#' + patternId + ')'
        }, restProps)),
        createElement(Pattern, _extends({
          id: patternId,
          color: color
        }, props))
      );
    };
  };
};

var _withStates;

var RawArea = function (_React$PureComponent) {
  inherits(RawArea, _React$PureComponent);

  function RawArea() {
    classCallCheck(this, RawArea);
    return possibleConstructorReturn(this, (RawArea.__proto__ || Object.getPrototypeOf(RawArea)).apply(this, arguments));
  }

  createClass(RawArea, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          path = _props.path,
          coordinates = _props.coordinates,
          color = _props.color,
          index = _props.index,
          style = _props.style,
          getAnimatedStyle = _props.getAnimatedStyle,
          scales = _props.scales,
          restProps = objectWithoutProperties(_props, ['path', 'coordinates', 'color', 'index', 'style', 'getAnimatedStyle', 'scales']);

      return createElement('path', _extends({
        d: path(coordinates),
        fill: color,
        opacity: 0.5,
        style: getAnimatedStyle(style, getAreaAnimationStyle, scales)
      }, restProps));
    }
  }]);
  return RawArea;
}(PureComponent);

process.env.NODE_ENV !== "production" ? RawArea.propTypes = {
  path: func.isRequired,
  coordinates: array.isRequired,
  color: string,
  style: object
} : void 0;

RawArea.defaultProps = {
  color: undefined,
  style: undefined
};

var Area = withStates((_withStates = {}, defineProperty(_withStates, HOVERED, withPattern(function (_ref) {
  var index = _ref.index;
  return 'series-' + index + '-hover';
}, { opacity: 0.75 })(RawArea)), defineProperty(_withStates, SELECTED, withPattern(function (_ref2) {
  var index = _ref2.index;
  return 'series-' + index + '-selection';
}, { opacity: 0.5 })(RawArea)), _withStates))(RawArea);

var AreaSeries = declareSeries('AreaSeries', {
  components: { Path: Area },
  path: dArea,
  isStartedFromZero: true,
  getPointTransformer: getAreaPointTransformer,
  createHitTester: createAreaHitTester
});

var BarCollection = function (_React$PureComponent) {
  inherits(BarCollection, _React$PureComponent);

  function BarCollection() {
    classCallCheck(this, BarCollection);
    return possibleConstructorReturn(this, (BarCollection.__proto__ || Object.getPrototypeOf(BarCollection)).apply(this, arguments));
  }

  createClass(BarCollection, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          Point = _props.pointComponent,
          path = _props.path,
          coordinates = _props.coordinates,
          index = _props.index,
          style = _props.style,
          scales = _props.scales,
          getAnimatedStyle = _props.getAnimatedStyle,
          state = _props.state,
          restProps = objectWithoutProperties(_props, ['pointComponent', 'path', 'coordinates', 'index', 'style', 'scales', 'getAnimatedStyle', 'state']);

      return coordinates.map(function (item) {
        return createElement(Point, _extends({
          key: item.index.toString(),
          style: getAnimatedStyle(style, getAreaAnimationStyle, scales),
          seriesIndex: index
        }, restProps, dBar(item), item));
      });
    }
  }]);
  return BarCollection;
}(PureComponent);

process.env.NODE_ENV !== "production" ? BarCollection.propTypes = {
  pointComponent: func.isRequired,
  style: object
} : void 0;

BarCollection.defaultProps = {
  style: undefined
};

var _withStates$1;

var RawBar = function (_React$PureComponent) {
  inherits(RawBar, _React$PureComponent);

  function RawBar() {
    classCallCheck(this, RawBar);
    return possibleConstructorReturn(this, (RawBar.__proto__ || Object.getPrototypeOf(RawBar)).apply(this, arguments));
  }

  createClass(RawBar, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          argument = _props.argument,
          value = _props.value,
          index = _props.index,
          seriesIndex = _props.seriesIndex,
          barWidth = _props.barWidth,
          color = _props.color,
          restProps = objectWithoutProperties(_props, ['argument', 'value', 'index', 'seriesIndex', 'barWidth', 'color']);

      return createElement('rect', _extends({ fill: color }, restProps));
    }
  }]);
  return RawBar;
}(PureComponent);

process.env.NODE_ENV !== "production" ? RawBar.propTypes = {
  x: number.isRequired,
  y: number.isRequired,
  width: number.isRequired,
  height: number.isRequired,
  value: number.isRequired,
  color: string
} : void 0;

RawBar.defaultProps = {
  color: undefined
};

var Bar = withStates((_withStates$1 = {}, defineProperty(_withStates$1, HOVERED, withPattern(function (_ref) {
  var seriesIndex = _ref.seriesIndex,
      index = _ref.index;
  return 'series-' + seriesIndex + '-point-' + index + '-hover';
}, { opacity: 0.75 })(RawBar)), defineProperty(_withStates$1, SELECTED, withPattern(function (_ref2) {
  var seriesIndex = _ref2.seriesIndex,
      index = _ref2.index;
  return 'series-' + seriesIndex + '-point-' + index + '-selection';
}, { opacity: 0.5 })(RawBar)), _withStates$1))(RawBar);

var BarSeries = declareSeries('BarSeries', {
  components: { Path: BarCollection, Point: Bar },
  isStartedFromZero: true,
  getPointTransformer: getBarPointTransformer,
  createHitTester: createBarHitTester
});

BarSeries.defaultProps = {
  barWidth: 0.9
};

var _withStates$2;

var RawPath = function (_React$PureComponent) {
  inherits(RawPath, _React$PureComponent);

  function RawPath() {
    classCallCheck(this, RawPath);
    return possibleConstructorReturn(this, (RawPath.__proto__ || Object.getPrototypeOf(RawPath)).apply(this, arguments));
  }

  createClass(RawPath, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          path = _props.path,
          coordinates = _props.coordinates,
          color = _props.color,
          index = _props.index,
          style = _props.style,
          getAnimatedStyle = _props.getAnimatedStyle,
          scales = _props.scales,
          restProps = objectWithoutProperties(_props, ['path', 'coordinates', 'color', 'index', 'style', 'getAnimatedStyle', 'scales']);

      return createElement('path', _extends({
        d: path(coordinates),
        fill: 'none',
        strokeWidth: 2,
        stroke: color,
        style: getAnimatedStyle(style, getAreaAnimationStyle, scales)
      }, restProps));
    }
  }]);
  return RawPath;
}(PureComponent);

process.env.NODE_ENV !== "production" ? RawPath.propTypes = {
  path: func.isRequired,
  coordinates: array.isRequired,
  color: string,
  style: object
} : void 0;

RawPath.defaultProps = {
  color: undefined,
  style: undefined
};

var Path = withStates((_withStates$2 = {}, defineProperty(_withStates$2, HOVERED, function (props) {
  return _extends({ strokeWidth: 4 }, props);
}), defineProperty(_withStates$2, SELECTED, function (props) {
  return _extends({ strokeWidth: 4 }, props);
}), _withStates$2))(RawPath);

var LineSeries = declareSeries('LineSeries', {
  components: { Path: Path },
  path: dLine,
  getPointTransformer: getAreaPointTransformer,
  createHitTester: createLineHitTester
});

// TODO: Is it fine to have it hard coded or should there be `path` property?
var SliceCollection = function (_React$PureComponent) {
  inherits(SliceCollection, _React$PureComponent);

  function SliceCollection() {
    classCallCheck(this, SliceCollection);
    return possibleConstructorReturn(this, (SliceCollection.__proto__ || Object.getPrototypeOf(SliceCollection)).apply(this, arguments));
  }

  createClass(SliceCollection, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          Point = _props.pointComponent,
          path = _props.path,
          coordinates = _props.coordinates,
          index = _props.index,
          uniqueName = _props.uniqueName,
          style = _props.style,
          getAnimatedStyle = _props.getAnimatedStyle,
          scales = _props.scales,
          innerRadius = _props.innerRadius,
          outerRadius = _props.outerRadius,
          state = _props.state,
          restProps = objectWithoutProperties(_props, ['pointComponent', 'path', 'coordinates', 'index', 'uniqueName', 'style', 'getAnimatedStyle', 'scales', 'innerRadius', 'outerRadius', 'state']);

      return createElement(
        'g',
        { transform: 'translate(' + coordinates[0].x + ' ' + coordinates[0].y + ')' },
        coordinates.map(function (item) {
          return createElement(Point, _extends({
            key: item.index.toString(),
            style: getAnimatedStyle(style, getPieAnimationStyle, scales, item),
            seriesIndex: index
          }, restProps, item));
        })
      );
    }
  }]);
  return SliceCollection;
}(PureComponent);

process.env.NODE_ENV !== "production" ? SliceCollection.propTypes = {
  pointComponent: func.isRequired,
  style: object
} : void 0;

SliceCollection.defaultProps = {
  style: undefined
};

var _withStates$3;

var RawSlice = function (_React$PureComponent) {
  inherits(RawSlice, _React$PureComponent);

  function RawSlice() {
    classCallCheck(this, RawSlice);
    return possibleConstructorReturn(this, (RawSlice.__proto__ || Object.getPrototypeOf(RawSlice)).apply(this, arguments));
  }

  createClass(RawSlice, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          argument = _props.argument,
          value = _props.value,
          index = _props.index,
          seriesIndex = _props.seriesIndex,
          innerRadius = _props.innerRadius,
          outerRadius = _props.outerRadius,
          startAngle = _props.startAngle,
          endAngle = _props.endAngle,
          x = _props.x,
          y = _props.y,
          d = _props.d,
          color = _props.color,
          restProps = objectWithoutProperties(_props, ['argument', 'value', 'index', 'seriesIndex', 'innerRadius', 'outerRadius', 'startAngle', 'endAngle', 'x', 'y', 'd', 'color']);

      return createElement('path', _extends({
        fill: color,
        stroke: 'none',
        d: d
      }, restProps));
    }
  }]);
  return RawSlice;
}(PureComponent);

process.env.NODE_ENV !== "production" ? RawSlice.propTypes = {
  x: number.isRequired,
  y: number.isRequired,
  d: string.isRequired,
  value: number.isRequired,
  style: object,
  color: string
} : void 0;

RawSlice.defaultProps = {
  style: {},
  color: undefined
};

var Slice = withStates((_withStates$3 = {}, defineProperty(_withStates$3, HOVERED, withPattern(function (_ref) {
  var seriesIndex = _ref.seriesIndex,
      index = _ref.index;
  return 'series-' + seriesIndex + '-point-' + index + '-hover';
}, { opacity: 0.75 })(RawSlice)), defineProperty(_withStates$3, SELECTED, withPattern(function (_ref2) {
  var seriesIndex = _ref2.seriesIndex,
      index = _ref2.index;
  return 'series-' + seriesIndex + '-point-' + index + '-selection';
}, { opacity: 0.5 })(RawSlice)), _withStates$3))(RawSlice);

var PieSeries = declareSeries('PieSeries', {
  components: { Path: SliceCollection, Point: Slice },
  getPointTransformer: getPiePointTransformer,
  createHitTester: createPieHitTester
});

var PointCollection = function (_React$PureComponent) {
  inherits(PointCollection, _React$PureComponent);

  function PointCollection() {
    classCallCheck(this, PointCollection);
    return possibleConstructorReturn(this, (PointCollection.__proto__ || Object.getPrototypeOf(PointCollection)).apply(this, arguments));
  }

  createClass(PointCollection, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          Point = _props.pointComponent,
          path = _props.path,
          coordinates = _props.coordinates,
          _props$point = _props.point,
          point = _props$point === undefined ? {} : _props$point,
          style = _props.style,
          getAnimatedStyle = _props.getAnimatedStyle,
          scales = _props.scales,
          state = _props.state,
          restProps = objectWithoutProperties(_props, ['pointComponent', 'path', 'coordinates', 'point', 'style', 'getAnimatedStyle', 'scales', 'state']);

      var getAttributes = pointAttributes(point);
      return coordinates.map(function (item) {
        return createElement(Point, _extends({
          key: item.index.toString(),
          style: getAnimatedStyle(style, getScatterAnimationStyle, scales)
        }, restProps, getAttributes(item), item));
      });
    }
  }]);
  return PointCollection;
}(PureComponent);

process.env.NODE_ENV !== "production" ? PointCollection.propTypes = {
  pointComponent: func.isRequired,
  style: object
} : void 0;

PointCollection.defaultProps = {
  style: undefined
};

var _withStates$4;

var RawPoint = function (_React$PureComponent) {
  inherits(RawPoint, _React$PureComponent);

  function RawPoint() {
    classCallCheck(this, RawPoint);
    return possibleConstructorReturn(this, (RawPoint.__proto__ || Object.getPrototypeOf(RawPoint)).apply(this, arguments));
  }

  createClass(RawPoint, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          argument = _props.argument,
          value = _props.value,
          index = _props.index,
          x = _props.x,
          y = _props.y,
          color = _props.color,
          restProps = objectWithoutProperties(_props, ['argument', 'value', 'index', 'x', 'y', 'color']);
      // *d* attribute is calculated during points scaling.
      // TODO: Do it here - d={path().size(size).type(type)()}

      return createElement('path', _extends({
        fill: color,
        stroke: 'none',
        transform: 'translate(' + x + ' ' + y + ')'
      }, restProps));
    }
  }]);
  return RawPoint;
}(PureComponent);

process.env.NODE_ENV !== "production" ? RawPoint.propTypes = {
  x: number.isRequired,
  y: number.isRequired,
  value: number.isRequired,
  color: string
} : void 0;

RawPoint.defaultProps = {
  color: undefined
};

var Point = withStates((_withStates$4 = {}, defineProperty(_withStates$4, HOVERED, function (_ref) {
  var color = _ref.color,
      restProps = objectWithoutProperties(_ref, ['color']);
  return _extends({
    stroke: color,
    strokeWidth: 4,
    fill: 'none'
  }, restProps);
}), defineProperty(_withStates$4, SELECTED, function (_ref2) {
  var color = _ref2.color,
      restProps = objectWithoutProperties(_ref2, ['color']);
  return _extends({
    stroke: color,
    strokeWidth: 4,
    fill: 'none'
  }, restProps);
}), _withStates$4))(RawPoint);

var ScatterSeries = declareSeries('ScatterSeries', {
  components: { Path: PointCollection, Point: Point },
  getPointTransformer: getAreaPointTransformer,
  createHitTester: createScatterHitTester
});

var SplineSeries = declareSeries('SplineSeries', {
  components: { Path: Path },
  path: dSpline,
  getPointTransformer: getAreaPointTransformer,
  createHitTester: createSplineHitTester
});

var Root$1 = function (_React$PureComponent) {
  inherits(Root, _React$PureComponent);

  function Root() {
    classCallCheck(this, Root);
    return possibleConstructorReturn(this, (Root.__proto__ || Object.getPrototypeOf(Root)).apply(this, arguments));
  }

  createClass(Root, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          x = _props.x,
          y = _props.y,
          refsHandler = _props.refsHandler,
          children = _props.children,
          restProps = objectWithoutProperties(_props, ['x', 'y', 'refsHandler', 'children']);

      return createElement(
        'g',
        _extends({
          ref: refsHandler,
          transform: 'translate(' + x + ' ' + y + ')'
        }, restProps),
        children
      );
    }
  }]);
  return Root;
}(PureComponent);

process.env.NODE_ENV !== "production" ? Root$1.propTypes = {
  x: number.isRequired,
  y: number.isRequired,
  refsHandler: func.isRequired,
  children: node.isRequired
} : void 0;

var Tick = function (_React$PureComponent) {
  inherits(Tick, _React$PureComponent);

  function Tick() {
    classCallCheck(this, Tick);
    return possibleConstructorReturn(this, (Tick.__proto__ || Object.getPrototypeOf(Tick)).apply(this, arguments));
  }

  createClass(Tick, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          x1 = _props.x1,
          x2 = _props.x2,
          y1 = _props.y1,
          y2 = _props.y2,
          restProps = objectWithoutProperties(_props, ['x1', 'x2', 'y1', 'y2']);

      return createElement('path', _extends({
        d: 'M ' + x1 + ' ' + y1 + ' L ' + x2 + ' ' + y2
      }, restProps));
    }
  }]);
  return Tick;
}(PureComponent);

process.env.NODE_ENV !== "production" ? Tick.propTypes = {
  x1: number.isRequired,
  x2: number.isRequired,
  y1: number.isRequired,
  y2: number.isRequired
} : void 0;

var Label$1 = function (_React$PureComponent) {
  inherits(Label, _React$PureComponent);

  function Label() {
    classCallCheck(this, Label);
    return possibleConstructorReturn(this, (Label.__proto__ || Object.getPrototypeOf(Label)).apply(this, arguments));
  }

  createClass(Label, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          text = _props.text,
          x = _props.x,
          y = _props.y,
          dominantBaseline = _props.dominantBaseline,
          textAnchor = _props.textAnchor,
          restProps = objectWithoutProperties(_props, ['text', 'x', 'y', 'dominantBaseline', 'textAnchor']);


      return createElement(
        'text',
        _extends({
          dominantBaseline: dominantBaseline,
          textAnchor: textAnchor,
          x: x,
          y: y
        }, restProps),
        text
      );
    }
  }]);
  return Label;
}(PureComponent);

process.env.NODE_ENV !== "production" ? Label$1.propTypes = {
  text: oneOfType([string, number]).isRequired,
  x: number.isRequired,
  y: number.isRequired,
  dominantBaseline: string.isRequired,
  textAnchor: string.isRequired
} : void 0;

var Line = function (_React$PureComponent) {
  inherits(Line, _React$PureComponent);

  function Line() {
    classCallCheck(this, Line);
    return possibleConstructorReturn(this, (Line.__proto__ || Object.getPrototypeOf(Line)).apply(this, arguments));
  }

  createClass(Line, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          width = _props.width,
          height = _props.height,
          orientation = _props.orientation,
          restProps = objectWithoutProperties(_props, ['width', 'height', 'orientation']);

      return createElement('path', _extends({
        d: 'M 0 0 L ' + (orientation === 'horizontal' ? width : 0) + ' ' + (orientation === 'horizontal' ? 0 : height)
      }, restProps));
    }
  }]);
  return Line;
}(PureComponent);

process.env.NODE_ENV !== "production" ? Line.propTypes = {
  width: number.isRequired,
  height: number.isRequired,
  orientation: string.isRequired
} : void 0;

var getZeroCoord = function getZeroCoord() {
  return 0;
};
var getCorrectSize = function getCorrectSize(position) {
  return position === 'left' || position === 'top' ? function (coord) {
    return -coord;
  } : function (coord, side) {
    return side + coord;
  };
};
var getCorrection = function getCorrection(position) {
  return position === 'left' || position === 'top' ? function (coord) {
    return coord;
  } : getZeroCoord;
};
var getCurrentSize = function getCurrentSize(_, side) {
  return side;
};

var RawAxis = function (_React$PureComponent) {
  inherits(RawAxis, _React$PureComponent);

  function RawAxis(props) {
    classCallCheck(this, RawAxis);

    var _this = possibleConstructorReturn(this, (RawAxis.__proto__ || Object.getPrototypeOf(RawAxis)).call(this, props));

    _this.state = {
      xCorrection: 0,
      yCorrection: 0
    };
    _this.createRefsHandler = _this.createRefsHandler.bind(_this);
    return _this;
  }

  createClass(RawAxis, [{
    key: 'createRefsHandler',
    value: function createRefsHandler(placeholder, changeBBox, _ref) {
      var _this2 = this;

      var getWidth = _ref.getWidth,
          getHeight = _ref.getHeight,
          getXCorrection = _ref.getXCorrection,
          getYCorrection = _ref.getYCorrection;

      return function (el) {
        if (!el) {
          return;
        }

        var _el$getBBox = el.getBBox(),
            width = _el$getBBox.width,
            height = _el$getBBox.height,
            x = _el$getBBox.x,
            y = _el$getBBox.y;

        var _state = _this2.state,
            stateWidth = _state.width,
            stateHeight = _state.height;


        if (width === stateWidth && height === stateHeight) return;
        changeBBox({
          placeholder: placeholder,
          bBox: {
            width: getWidth(x, width),
            height: getHeight(y, height)
          }
        });
        _this2.setState({
          width: width,
          height: height,
          xCorrection: getXCorrection(x),
          yCorrection: getYCorrection(y)
        });
      };
    }
  }, {
    key: 'calculateLayout',
    value: function calculateLayout(width, height, defaultWidth, defaultHeight) {
      var calculatedWidth = width || defaultWidth;
      var calculatedHeight = height || defaultHeight;

      var _ref2 = this.node && this.node.getBoundingClientRect() || {},
          containerWidth = _ref2.width,
          containerHeight = _ref2.height;

      return {
        width: containerWidth || calculatedWidth,
        height: containerHeight || calculatedHeight
      };
    }
  }, {
    key: 'render',
    value: function render() {
      var _this3 = this;

      var _props = this.props,
          tickSize = _props.tickSize,
          position = _props.position,
          name = _props.name,
          indentFromAxis = _props.indentFromAxis,
          RootComponent = _props.rootComponent,
          TickComponent = _props.tickComponent,
          LabelComponent = _props.labelComponent,
          LineComponent = _props.lineComponent;

      var getAxes = function getAxes(_ref3) {
        var axes = _ref3.axes;
        return axesData(axes, _this3.props);
      };
      return createElement(
        Plugin,
        { name: 'Axis' },
        createElement(Getter, { name: 'axes', computed: getAxes }),
        createElement(
          Template,
          { name: position + '-axis' },
          createElement(TemplatePlaceholder, null),
          createElement(
            TemplateConnector,
            null,
            function (_ref4, _ref5) {
              var domains = _ref4.domains,
                  scales = _ref4.scales,
                  layouts = _ref4.layouts;
              var changeBBox = _ref5.changeBBox;

              // TODO: Take axis from "axes" getter rather then from closure.
              var placeholder = position + '-axis';
              var domain = domains[name];
              var scale = scales[name];
              // TODO_DEBUG
              if (!domain) {
                throw new Error('domain is not found: ' + name);
              }
              // TODO_DEBUG
              var orientation = domain.orientation;

              var _ref6 = layouts[placeholder] || { width: 0, height: 0 },
                  widthCalculated = _ref6.width,
                  heightCalculated = _ref6.height;

              var _calculateLayout = _this3.calculateLayout(widthCalculated, heightCalculated, 0, 0),
                  widthPostCalculated = _calculateLayout.width,
                  heightPostCalculated = _calculateLayout.height;
              // Isn't it too late to adjust sizes?


              var postCalculatedScale = scale.copy().range(orientation === HORIZONTAL ? [0, widthPostCalculated] : [heightPostCalculated, 0]);
              var coordinates = axisCoordinates(
              // TODO: Only *orientation* and *tickFormat* are taken from *domain* -
              // take *tickFormat* directly from props.
              domain, postCalculatedScale, position, tickSize, indentFromAxis);
              var _state2 = _this3.state,
                  xCorrection = _state2.xCorrection,
                  yCorrection = _state2.yCorrection;


              return createElement(
                'div',
                {
                  style: {
                    position: 'relative',
                    width: orientation === HORIZONTAL ? undefined : widthCalculated,
                    height: orientation === HORIZONTAL ? heightCalculated : null,
                    flexGrow: orientation === HORIZONTAL ? 1 : undefined
                  },
                  ref: function ref(node$$1) {
                    _this3.node = node$$1;
                  }
                },
                createElement(
                  'svg',
                  {
                    width: widthPostCalculated,
                    height: heightPostCalculated,
                    style: {
                      position: 'absolute', left: 0, top: 0, overflow: 'visible'
                    }
                  },
                  createElement(
                    RootComponent,
                    {
                      refsHandler: _this3.createRefsHandler(placeholder, changeBBox, {
                        getWidth: orientation !== HORIZONTAL ? getCorrectSize(position) : getCurrentSize,
                        getHeight: orientation === HORIZONTAL ? getCorrectSize(position) : getCurrentSize,
                        getXCorrection: orientation !== HORIZONTAL ? getCorrection(position) : getZeroCoord,
                        getYCorrection: orientation === HORIZONTAL ? getCorrection(position) : getZeroCoord
                      }),
                      x: -xCorrection,
                      y: -yCorrection
                    },
                    coordinates.ticks.map(function (_ref7) {
                      var x1 = _ref7.x1,
                          x2 = _ref7.x2,
                          y1 = _ref7.y1,
                          y2 = _ref7.y2,
                          key = _ref7.key;
                      return createElement(TickComponent, {
                        key: key,
                        x1: x1,
                        x2: x2,
                        y1: y1,
                        y2: y2
                      });
                    }),
                    createElement(LineComponent, {
                      width: widthPostCalculated,
                      height: heightPostCalculated,
                      orientation: orientation
                    }),
                    coordinates.ticks.map(function (_ref8) {
                      var text = _ref8.text,
                          xText = _ref8.xText,
                          yText = _ref8.yText,
                          dominantBaseline = _ref8.dominantBaseline,
                          textAnchor = _ref8.textAnchor,
                          key = _ref8.key;
                      return createElement(
                        Fragment,
                        { key: key },
                        createElement(LabelComponent, {
                          text: text,
                          x: xText,
                          y: yText,
                          dominantBaseline: dominantBaseline,
                          textAnchor: textAnchor
                        })
                      );
                    })
                  )
                )
              );
            }
          )
        )
      );
    }
  }]);
  return RawAxis;
}(PureComponent);

process.env.NODE_ENV !== "production" ? RawAxis.propTypes = {
  name: string.isRequired,
  rootComponent: func.isRequired,
  tickComponent: func.isRequired,
  labelComponent: func.isRequired,
  lineComponent: func.isRequired,
  position: string.isRequired,
  tickSize: number,
  indentFromAxis: number
} : void 0;

RawAxis.defaultProps = {
  tickSize: 5,
  indentFromAxis: 10
};

RawAxis.components = {
  rootComponent: 'Root',
  tickComponent: 'Tick',
  labelComponent: 'Label',
  lineComponent: 'Line'
};

var Axis = withComponents({
  Root: Root$1, Tick: Tick, Label: Label$1, Line: Line
})(RawAxis);

// TODO: It is not axis who defines that argument is HORIZONTAL and value is VERTICAL.

// TODO: Check that only BOTTOM and TOP are accepted.
var ArgumentAxis = withPatchedProps(function (props) {
  return _extends({
    position: BOTTOM
  }, props, {
    name: ARGUMENT_DOMAIN
  });
})(Axis);

// TODO: Check that only LEFT and RIGHT are accepted.
var ValueAxis = withPatchedProps(function (props) {
  return _extends({
    position: LEFT
  }, props, {
    name: getValueDomainName(props.name)
  });
})(Axis);

ArgumentAxis.components = Axis.components;
ValueAxis.components = Axis.components;

var Line$1 = function (_React$PureComponent) {
  inherits(Line, _React$PureComponent);

  function Line() {
    classCallCheck(this, Line);
    return possibleConstructorReturn(this, (Line.__proto__ || Object.getPrototypeOf(Line)).apply(this, arguments));
  }

  createClass(Line, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          x1 = _props.x1,
          x2 = _props.x2,
          y1 = _props.y1,
          y2 = _props.y2,
          restProps = objectWithoutProperties(_props, ['x1', 'x2', 'y1', 'y2']);

      return createElement('path', _extends({
        d: 'M ' + x1 + ' ' + y1 + ' L ' + x2 + ' ' + y2
      }, restProps));
    }
  }]);
  return Line;
}(PureComponent);

process.env.NODE_ENV !== "production" ? Line$1.propTypes = {
  x1: number.isRequired,
  x2: number.isRequired,
  y1: number.isRequired,
  y2: number.isRequired
} : void 0;

var RawGrid = function (_React$PureComponent) {
  inherits(RawGrid, _React$PureComponent);

  function RawGrid() {
    classCallCheck(this, RawGrid);
    return possibleConstructorReturn(this, (RawGrid.__proto__ || Object.getPrototypeOf(RawGrid)).apply(this, arguments));
  }

  createClass(RawGrid, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          name = _props.name,
          LineComponent = _props.lineComponent,
          restProps = objectWithoutProperties(_props, ['name', 'lineComponent']);

      return createElement(
        Plugin,
        { name: 'Grid' },
        createElement(
          Template,
          { name: 'series' },
          createElement(TemplatePlaceholder, null),
          createElement(
            TemplateConnector,
            null,
            function (_ref) {
              var domains = _ref.domains,
                  scales = _ref.scales,
                  layouts = _ref.layouts;

              var domain = domains[name];
              var scale = scales[name];
              var orientation = domain.orientation;
              var _layouts$pane = layouts.pane,
                  width = _layouts$pane.width,
                  height = _layouts$pane.height;


              var coordinates = axisCoordinates(domain, scale, orientation === HORIZONTAL ? TOP : LEFT, 0, undefined);

              return createElement(
                Fragment,
                null,
                coordinates.ticks.map(function (_ref2) {
                  var x1 = _ref2.x1,
                      x2 = _ref2.x2,
                      y1 = _ref2.y1,
                      y2 = _ref2.y2,
                      key = _ref2.key;
                  return createElement(LineComponent, _extends({
                    key: key,
                    x1: orientation === HORIZONTAL ? x1 : width,
                    x2: x2,
                    y1: orientation === HORIZONTAL ? height : y1,
                    y2: y2
                  }, restProps));
                })
              );
            }
          )
        )
      );
    }
  }]);
  return RawGrid;
}(PureComponent);

process.env.NODE_ENV !== "production" ? RawGrid.propTypes = {
  name: string.isRequired,
  lineComponent: func.isRequired
} : void 0;

RawGrid.components = {
  lineComponent: 'Line'
};

var Grid = withComponents({ Line: Line$1 })(RawGrid);

var ArgumentGrid = withPatchedProps(function (props) {
  return _extends({}, props, {
    name: ARGUMENT_DOMAIN
  });
})(Grid);

var ValueGrid = withPatchedProps(function (props) {
  return _extends({}, props, {
    name: getValueDomainName(props.name)
  });
})(Grid);

ArgumentGrid.components = Grid.components;
ValueGrid.components = Grid.components;

var wrapToList = function wrapToList(arg) {
  return arg ? [arg] : [];
};

var EVENT_NAME_MAP = {
  click: 'onClick',
  pointermove: 'onPointerMove',
  pointerleave: 'onPointerLeave'
};

var translateEventNames = function translateEventNames(handlers) {
  var result = {};
  Object.entries(handlers).forEach(function (_ref) {
    var _ref2 = slicedToArray(_ref, 2),
        name = _ref2[0],
        handler = _ref2[1];

    result[EVENT_NAME_MAP[name]] = handler;
  });
  return result;
};

// eslint-disable-next-line react/no-multi-comp
var EventTracker = function (_React$PureComponent) {
  inherits(EventTracker, _React$PureComponent);

  function EventTracker() {
    classCallCheck(this, EventTracker);
    return possibleConstructorReturn(this, (EventTracker.__proto__ || Object.getPrototypeOf(EventTracker)).apply(this, arguments));
  }

  createClass(EventTracker, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          onClick = _props.onClick,
          onPointerMove = _props.onPointerMove;

      return createElement(
        Plugin,
        { name: 'EventTracker' },
        createElement(Getter, { name: 'clickHandlers', value: wrapToList(onClick) }),
        createElement(Getter, { name: 'pointerMoveHandlers', value: wrapToList(onPointerMove) }),
        createElement(
          Template,
          { name: 'canvas' },
          createElement(
            TemplateConnector,
            null,
            function (_ref3) {
              var series = _ref3.series,
                  clickHandlers = _ref3.clickHandlers,
                  pointerMoveHandlers = _ref3.pointerMoveHandlers;

              var handlers = buildEventHandlers(series, { clickHandlers: clickHandlers, pointerMoveHandlers: pointerMoveHandlers });
              return createElement(TemplatePlaceholder, { params: translateEventNames(handlers) });
            }
          )
        )
      );
    }
  }]);
  return EventTracker;
}(PureComponent);

process.env.NODE_ENV !== "production" ? EventTracker.propTypes = {
  onClick: func,
  onPointerMove: func
} : void 0;

EventTracker.defaultProps = {
  onClick: undefined,
  onPointerMove: undefined
};

var HoverState = function (_React$PureComponent) {
  inherits(HoverState, _React$PureComponent);

  function HoverState(props) {
    classCallCheck(this, HoverState);

    var _this = possibleConstructorReturn(this, (HoverState.__proto__ || Object.getPrototypeOf(HoverState)).call(this, props));

    _this.state = {
      hover: props.hover || props.defaultHover
    };
    var handlePointerMove = _this.handlePointerMove.bind(_this);
    _this.getPointerMoveHandlers = function (_ref) {
      var pointerMoveHandlers = _ref.pointerMoveHandlers;
      return [].concat(toConsumableArray(pointerMoveHandlers), [handlePointerMove]);
    };
    return _this;
  }

  createClass(HoverState, [{
    key: 'handlePointerMove',
    value: function handlePointerMove(_ref2) {
      var targets = _ref2.targets;
      var onHoverChange = this.props.onHoverChange;
      var currentTarget = this.state.hover;

      var hover = processPointerMove(targets, currentTarget, onHoverChange);
      if (hover !== undefined) {
        this.setState({ hover: hover });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var hover = this.state.hover;
      // Function has to be recreated every time as there is no other way
      // to notify that "series" is updated.

      var getSeries = function getSeries(_ref3) {
        var series = _ref3.series;
        return changeSeriesState(series, getHoverTargets(hover), HOVERED);
      };
      return createElement(
        Plugin,
        { name: 'HoverState' },
        createElement(Getter, { name: 'pointerMoveHandlers', computed: this.getPointerMoveHandlers }),
        createElement(Getter, { name: 'series', computed: getSeries })
      );
    }
  }], [{
    key: 'getDerivedStateFromProps',
    value: function getDerivedStateFromProps(props, state) {
      return { hover: props.hover !== undefined ? props.hover : state.hover };
    }
  }]);
  return HoverState;
}(PureComponent);

process.env.NODE_ENV !== "production" ? HoverState.propTypes = {
  defaultHover: shape({
    series: string.isRequired,
    point: number
  }),
  hover: shape({
    series: string.isRequired,
    point: number
  }),
  onHoverChange: func
} : void 0;

HoverState.defaultProps = {
  defaultHover: undefined,
  hover: undefined,
  onHoverChange: undefined
};

var SelectionState = function (_React$PureComponent) {
  inherits(SelectionState, _React$PureComponent);

  function SelectionState() {
    classCallCheck(this, SelectionState);
    return possibleConstructorReturn(this, (SelectionState.__proto__ || Object.getPrototypeOf(SelectionState)).apply(this, arguments));
  }

  createClass(SelectionState, [{
    key: 'render',
    value: function render() {
      var selection = this.props.selection;

      var getSeries = function getSeries(_ref) {
        var series = _ref.series;
        return changeSeriesState(series, selection, SELECTED);
      };
      return createElement(
        Plugin,
        { name: 'SelectionState' },
        createElement(Getter, { name: 'series', computed: getSeries })
      );
    }
  }]);
  return SelectionState;
}(PureComponent);

process.env.NODE_ENV !== "production" ? SelectionState.propTypes = {
  selection: arrayOf(shape({
    series: string.isRequired,
    point: number
  }))
} : void 0;

SelectionState.defaultProps = {
  selection: []
};

export { Chart, Legend, Title, Scale, Stack, Palette, Animation, AreaSeries, BarSeries, LineSeries, PieSeries, ScatterSeries, SplineSeries, Axis, ArgumentAxis, ValueAxis, Grid, ArgumentGrid, ValueGrid, withPatchedProps, withComponents, EventTracker, HoverState, SelectionState };
//# sourceMappingURL=dx-react-chart.es.js.map
