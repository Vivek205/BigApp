/**
 * Bundle of @devexpress/dx-chart-core
 * Generated: 2018-11-07
 * Version: 1.9.0
 * License: https://js.devexpress.com/Licensing
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array'), require('d3-scale'), require('d3-shape')) :
  typeof define === 'function' && define.amd ? define(['exports', 'd3-array', 'd3-scale', 'd3-shape'], factory) :
  (factory((global.DevExpress = global.DevExpress || {}, global.DevExpress.DXChartCore = {}),global.d3Array,global.d3Scale,global.d3Shape));
}(this, (function (exports,d3Array,d3Scale,d3Shape) { 'use strict';

  var HORIZONTAL = 'horizontal';
  var VERTICAL = 'vertical';
  var TOP = 'top';
  var BOTTOM = 'bottom';
  var LEFT = 'left';
  var RIGHT = 'right';
  var MIDDLE = 'middle';
  var END = 'end';
  var START = 'start';

  var LINEAR = 'linear';
  var BAND = 'band';

  var ARGUMENT_DOMAIN = 'argument-domain';
  var VALUE_DOMAIN = 'value-domain';

  var HOVERED = 'hovered';
  var SELECTED = 'selected';

  var createScale = function createScale(_ref, width, height, constructor) {
    var domain = _ref.domain,
        orientation = _ref.orientation;

    var scale = constructor();
    return scale.domain(domain).range(orientation === HORIZONTAL ? [0, width] : [height, 0]);
  };

  var getWidth = function getWidth(scale) {
    return scale.bandwidth ? scale.bandwidth() : 0;
  };

  var getValueDomainName = function getValueDomainName(name) {
    return name || VALUE_DOMAIN;
  };

  var defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var objectWithoutProperties = function (obj, keys) {
    var target = {};

    for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
      target[i] = obj[i];
    }

    return target;
  };

  var slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  var toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };

  var isDefined = function isDefined(item) {
    return item !== undefined;
  };

  // TODO: Property name should not contain "axis" part as it actually means domain.
  var getSeriesValueDomainName = function getSeriesValueDomainName(series) {
    return getValueDomainName(series.axisName);
  };

  var calculateDomainField = function calculateDomainField(items, domain, type) {
    return type === BAND ? [].concat(toConsumableArray(domain), toConsumableArray(items)) : d3Array.extent([].concat(toConsumableArray(domain), toConsumableArray(d3Array.extent(items))));
  };

  var getArgument = function getArgument(point) {
    return point.argument;
  };

  var getValue = function getValue(point) {
    return point.value;
  };

  var getCorrectAxisType = function getCorrectAxisType(type, points, getItem) {
    return type || points.length && typeof getItem(points[0]) === 'string' && BAND || LINEAR;
  };

  var calculateDomains = function calculateDomains(domains, seriesList) {
    seriesList.forEach(function (seriesItem) {
      var valueDomainName = getSeriesValueDomainName(seriesItem);
      var points = seriesItem.points;

      var argumentDomain = domains[ARGUMENT_DOMAIN];
      var valueDomain = domains[valueDomainName];

      var valueType = getCorrectAxisType(valueDomain.type, points, getValue);
      var argumentType = getCorrectAxisType(argumentDomain.type, points, getArgument);

      // TODO: This is a temporary workaround for Stack plugin.
      // Once scales (or domains) are exposed for modification Stack will modify scale and
      // this code will be removed.
      var valueDomainItems = seriesItem.getValueDomain ? seriesItem.getValueDomain(points) : points.map(getValue);
      valueDomain.domain = calculateDomainField(valueDomainItems, valueDomain.domain, valueType);
      valueDomain.type = valueType;

      argumentDomain.domain = calculateDomainField(points.map(getArgument), argumentDomain.domain, argumentType);
      argumentDomain.type = argumentType;
    });
  };

  var computeExtension = function computeExtension(extension) {
    var defaultExtension = [{ type: LINEAR, constructor: d3Scale.scaleLinear }, { type: BAND, constructor: function constructor() {
        return d3Scale.scaleBand().paddingInner(0.3).paddingOuter(0.15);
      } }];
    return extension.concat(defaultExtension);
  };

  var collectDomains = function collectDomains(seriesList) {
    var domains = defineProperty({}, ARGUMENT_DOMAIN, { domain: [], orientation: HORIZONTAL });
    seriesList.forEach(function (seriesItem) {
      var name = getSeriesValueDomainName(seriesItem);
      var domain = domains[name] || { domain: [], orientation: VERTICAL };
      domains[name] = domain;
      if (seriesItem.isStartedFromZero && domain.domain.length === 0) {
        domain.domain = [0];
      }
    });
    return domains;
  };

  var takeTypeFromAxesOptions = function takeTypeFromAxesOptions(domains, axes) {
    axes.forEach(function (_ref) {
      var name = _ref.name,
          type = _ref.type;

      var domain = domains[name];
      if (domain) {
        domain.type = type;
      }
    });
  };

  var takeRestAxesOptions = function takeRestAxesOptions(domains, axes) {
    axes.forEach(function (_ref2) {
      var name = _ref2.name,
          tickFormat = _ref2.tickFormat,
          min = _ref2.min,
          max = _ref2.max;

      var domain = domains[name];
      if (!domain) {
        return;
      }
      domain.tickFormat = tickFormat;
      if (domain.type !== BAND) {
        domain.domain = [isDefined(min) ? min : domain.domain[0], isDefined(max) ? max : domain.domain[1]];
      }
    });
  };

  var computeDomains = function computeDomains(axes, series) {
    var result = collectDomains(series);
    // Axes options are taken in two steps because *type* is required for domains calculation
    // and other options must be applied after domains are calculated.
    takeTypeFromAxesOptions(result, axes);
    calculateDomains(result, series);
    takeRestAxesOptions(result, axes);
    return result;
  };

  var buildScales = function buildScales(domains, scaleExtension, _ref3) {
    var width = _ref3.width,
        height = _ref3.height;

    var scales = {};
    Object.entries(domains).forEach(function (_ref4) {
      var _ref5 = slicedToArray(_ref4, 2),
          name = _ref5[0],
          domain = _ref5[1];

      var _scaleExtension$find = scaleExtension.find(function (item) {
        return item.type === domain.type;
      }),
          constructor = _scaleExtension$find.constructor;

      scales[name] = createScale(domain, width, height, constructor);
    });
    return scales;
  };

  var isEqual = function isEqual(_ref, _ref2) {
    var firstWidth = _ref.width,
        firstHeight = _ref.height;
    var secondWidth = _ref2.width,
        secondHeight = _ref2.height;
    return firstWidth === secondWidth && firstHeight === secondHeight;
  };

  var bBoxes = function bBoxes(prevBBoxes, _ref3) {
    var bBox = _ref3.bBox,
        placeholder = _ref3.placeholder;

    if (isEqual(prevBBoxes[placeholder] || {}, bBox)) return prevBBoxes;
    return _extends({}, prevBBoxes, defineProperty({}, placeholder, bBox));
  };

  var getTicks = function getTicks(scale) {
    return scale.ticks ? scale.ticks() : scale.domain();
  };
  var getDominantBaseline = function getDominantBaseline(orientation, position) {
    if (orientation === HORIZONTAL) {
      return position === TOP ? 'baseline' : 'hanging';
    }
    return MIDDLE;
  };
  var getTextAnchor = function getTextAnchor(orientation, position) {
    if (orientation === HORIZONTAL) {
      return MIDDLE;
    }
    return position === LEFT ? END : START;
  };

  var getFormat = function getFormat(scale, tickFormat) {
    if (scale.tickFormat) {
      return tickFormat ? tickFormat(scale) : scale.tickFormat();
    }
    return function (tick) {
      return tick;
    };
  };

  // It is called for grid (which do not have labels) - how is it handled here?
  var calculateAxisCoordinates = function calculateAxisCoordinates(scale, orientation, position, tickSize, indentFromAxis, tickFormat) {
    var ticks = getTicks(scale);
    var offset = getWidth(scale) / 2;
    var dominantBaseline = getDominantBaseline(orientation, position);
    var textAnchor = getTextAnchor(orientation, position);
    var getTickCoordinates = function getTickCoordinates(tick, index) {
      var coordinates = scale(tick) + offset;
      if (orientation === HORIZONTAL) {
        return {
          dominantBaseline: dominantBaseline,
          textAnchor: textAnchor,
          x1: coordinates,
          x2: coordinates,
          y1: position === TOP ? -tickSize : 0,
          y2: position === TOP ? 0 : tickSize,
          text: getFormat(scale, tickFormat)(tick),
          xText: coordinates,
          yText: position === TOP ? -indentFromAxis : indentFromAxis,
          key: index
        };
      }
      return {
        dominantBaseline: dominantBaseline,
        textAnchor: textAnchor,
        y1: coordinates,
        y2: coordinates,
        x1: position === LEFT ? -tickSize : 0,
        x2: position === LEFT ? 0 : tickSize,
        text: getFormat(scale, tickFormat)(tick),
        xText: position === LEFT ? -indentFromAxis : indentFromAxis,
        yText: coordinates,
        key: index
      };
    };
    return {
      ticks: ticks.map(getTickCoordinates)
    };
  };

  var axisCoordinates = function axisCoordinates(domain, scale, position, tickSize, indentFromAxis) {
    return calculateAxisCoordinates(scale, domain.orientation, position, tickSize, indentFromAxis,
    // TODO: *tickFormat* belongs to axis rather then domain - take it from axis.
    domain.tickFormat);
  };

  var axesData = function axesData(axes, axisProps) {
    return [].concat(toConsumableArray(axes), [axisProps]);
  };

  var getX = function getX(_ref) {
    var x = _ref.x;
    return x;
  };
  var getY = function getY(_ref2) {
    var y = _ref2.y;
    return y;
  };
  var getY1 = function getY1(_ref3) {
    var y1 = _ref3.y1;
    return y1;
  };

  var DEFAULT_POINT_SIZE = 7;

  var dArea = d3Shape.area().x(getX).y1(getY).y0(getY1);

  var dLine = d3Shape.line().x(getX).y(getY);

  var dSpline = d3Shape.line().x(getX).y(getY).curve(d3Shape.curveMonotoneX);

  var getPiePointTransformer = function getPiePointTransformer(_ref4) {
    var _ref4$innerRadius = _ref4.innerRadius,
        innerRadius = _ref4$innerRadius === undefined ? 0 : _ref4$innerRadius,
        _ref4$outerRadius = _ref4.outerRadius,
        outerRadius = _ref4$outerRadius === undefined ? 1 : _ref4$outerRadius,
        argumentScale = _ref4.argumentScale,
        valueScale = _ref4.valueScale,
        palette = _ref4.palette,
        points = _ref4.points;

    var x = Math.max.apply(Math, toConsumableArray(argumentScale.range())) / 2;
    var y = Math.max.apply(Math, toConsumableArray(valueScale.range())) / 2;
    var radius = Math.min(x, y);
    var pieData = d3Shape.pie().sort(null).value(function (d) {
      return d.value;
    })(points);
    var inner = innerRadius * radius;
    var outer = outerRadius * radius;
    var gen = d3Shape.arc().innerRadius(inner).outerRadius(outer);
    var colorScale = d3Scale.scaleOrdinal().range(palette);
    return function (point) {
      var _pieData$point$index = pieData[point.index],
          startAngle = _pieData$point$index.startAngle,
          endAngle = _pieData$point$index.endAngle;

      return _extends({}, point, {
        // TODO: It should be calculated in *pointComponent*.
        d: gen.startAngle(startAngle).endAngle(endAngle)(),
        color: point.color || colorScale(point.index),
        x: x,
        y: y,
        innerRadius: inner,
        outerRadius: outer,
        startAngle: startAngle,
        endAngle: endAngle
      });
    };
  };

  var getAreaPointTransformer = function getAreaPointTransformer(_ref5) {
    var argumentScale = _ref5.argumentScale,
        valueScale = _ref5.valueScale;

    var y1 = valueScale(0);
    var offset = getWidth(argumentScale) / 2;
    return function (point) {
      return _extends({}, point, {
        x: argumentScale(point.argument) + offset,
        y: valueScale(point.value),
        y1: y1
      });
    };
  };

  var getBarPointTransformer = function getBarPointTransformer(_ref6) {
    var argumentScale = _ref6.argumentScale,
        valueScale = _ref6.valueScale,
        barWidth = _ref6.barWidth;

    var y1 = valueScale(0);
    var categoryWidth = getWidth(argumentScale);
    var offset = categoryWidth * (1 - barWidth) / 2;
    var width = categoryWidth * barWidth;
    return function (point) {
      return _extends({}, point, {
        x: argumentScale(point.argument) + offset,
        y: valueScale(point.value),
        y1: y1,
        width: width
      });
    };
  };
  // Used for Bar grouping.
  getBarPointTransformer.isBroad = true;

  var findSeriesByName = function findSeriesByName(name, series) {
    return series.find(function (seriesItem) {
      return seriesItem.symbolName === name;
    });
  };

  var dBar = function dBar(_ref7) {
    var x = _ref7.x,
        y = _ref7.y,
        y1 = _ref7.y1,
        width = _ref7.width;
    return {
      x: x, y: Math.min(y, y1), width: width || 2, height: Math.abs(y1 - y)
    };
  };

  var pointAttributes = function pointAttributes(_ref8) {
    var _ref8$size = _ref8.size,
        size = _ref8$size === undefined ? DEFAULT_POINT_SIZE : _ref8$size;

    var dPoint = d3Shape.symbol().size([Math.pow(size, 2)]).type(d3Shape.symbolCircle)();
    return function (item) {
      return {
        // TODO: It should be calculated in *pointComponent*.
        d: dPoint,
        x: item.x,
        y: item.y
      };
    };
  };

  var createNewUniqueName = function createNewUniqueName(name) {
    return name.replace(/\d*$/, function (str) {
      return str ? +str + 1 : 0;
    });
  };

  var addItem = function addItem(list, item) {
    return list.find(function (obj) {
      return obj.uniqueName === item.uniqueName;
    }) ? addItem(list, _extends({}, item, {
      uniqueName: createNewUniqueName(item.uniqueName)
    })) : list.concat(item);
  };

  // TODO: Memoization is much needed here.
  // Though "series" list never persists, single "series" item most often does.
  var createPoints = function createPoints(argumentField, valueField, data) {
    var points = [];
    data.forEach(function (dataItem, index) {
      var argument = dataItem[argumentField];
      var value = dataItem[valueField];
      if (argument !== undefined && value !== undefined) {
        points.push({ argument: argument, value: value, index: index });
      }
    });
    return points;
  };

  var addSeries = function addSeries(series, data, palette, props) {
    var points = createPoints(props.argumentField, props.valueField, data);
    // It is used to generate unique series dependent attribute names for patterns.
    // *symbolName* cannot be used as it cannot be part of DOM attribute name.
    // TODO: Consider making *name* unique and then use it instead of *index*.
    var index = series.length;
    return addItem(series, _extends({}, props, {
      index: index,
      points: points,
      uniqueName: props.name,
      palette: palette, // TODO: For Pie only. Find a better place for it.
      color: props.color || palette[index % palette.length]
    }));
  };

  // TODO: Memoization is much needed here by the same reason as in "createPoints".
  // Make "scales" persistent first.
  var scalePoints = function scalePoints(series, scales) {
    var getPointTransformer = series.getPointTransformer,
        rest = objectWithoutProperties(series, ['getPointTransformer']);

    var transform = getPointTransformer(_extends({}, series, {
      argumentScale: scales[ARGUMENT_DOMAIN],
      valueScale: scales[getValueDomainName(series.axisName)]
    }));
    return _extends({}, rest, {
      points: series.points.map(transform)
    });
  };

  var scaleSeriesPoints = function scaleSeriesPoints(series, scales) {
    return series.map(function (seriesItem) {
      return scalePoints(seriesItem, scales);
    });
  };

  // "Stack" plugin relies on "data" and "series" getters and
  // knowledge about "getPointTransformer" and "path" functions behavior.

  var buildSeriesToStackMap = function buildSeriesToStackMap(stacks) {
    var result = {};
    stacks.forEach(function (_ref, i) {
      var series = _ref.series;

      series.forEach(function (name) {
        result[name] = i;
      });
    });
    return result;
  };

  var getStackedPointTransformer = function getStackedPointTransformer(getPointTransformer) {
    var wrapper = function wrapper(series) {
      var transform = getPointTransformer(series);
      var valueScale = series.valueScale;

      return function (point) {
        var ret = transform(point);
        ret.y1 = valueScale(point.value0);
        return ret;
      };
    };
    // Preserve static fields of original transformer.
    Object.assign(wrapper, getPointTransformer);
    return wrapper;
  };

  // TODO: Temporary - see corresponding note in *computeDomains*.
  var getValueDomain = function getValueDomain(points) {
    var items = [];
    points.forEach(function (point) {
      items.push(point.value, point.value0);
    });
    return items;
  };

  var collectStacks = function collectStacks(seriesList, seriesToStackMap) {
    var stacksKeys = {};
    var seriesPositions = {};
    seriesList.forEach(function (_ref2) {
      var name = _ref2.name,
          valueField = _ref2.valueField;

      var stackId = seriesToStackMap[name];
      if (stackId === undefined) {
        return;
      }

      if (!stacksKeys[stackId]) {
        stacksKeys[stackId] = [];
      }
      seriesPositions[name] = stacksKeys[stackId].length;
      stacksKeys[stackId].push(valueField);
    });
    // Stack cannot consist of single series.
    Object.keys(stacksKeys).forEach(function (stackId) {
      if (stacksKeys[stackId].length === 1) {
        delete stacksKeys[stackId];
      }
    });
    return [stacksKeys, seriesPositions];
  };

  var getStackedData = function getStackedData(stacksKeys, dataItems, offset, order) {
    var result = {};
    Object.keys(stacksKeys).forEach(function (stackId) {
      result[stackId] = d3Shape.stack().keys(stacksKeys[stackId]).order(order).offset(offset)(dataItems);
    });
    return result;
  };

  var buildStackedSeries = function buildStackedSeries(series, dataItems) {
    var points = series.points.map(function (point) {
      var _dataItems$point$inde = slicedToArray(dataItems[point.index], 2),
          value0 = _dataItems$point$inde[0],
          value = _dataItems$point$inde[1];

      return _extends({}, point, { value: value, value0: value0 });
    });
    var stackedSeries = _extends({}, series, {
      points: points
    });
    if (series.isStartedFromZero) {
      stackedSeries.getPointTransformer = getStackedPointTransformer(series.getPointTransformer);
      stackedSeries.getValueDomain = getValueDomain;
    }
    return stackedSeries;
  };

  var applyStacking = function applyStacking(seriesList, dataItems, seriesToStackMap, offset, order) {
    var _collectStacks = collectStacks(seriesList, seriesToStackMap),
        _collectStacks2 = slicedToArray(_collectStacks, 2),
        stacksKeys = _collectStacks2[0],
        seriesPositions = _collectStacks2[1];

    if (Object.keys(stacksKeys).length === 0) {
      return seriesList;
    }
    var stackedData = getStackedData(stacksKeys, dataItems, offset, order);
    return seriesList.map(function (seriesItem) {
      var stackId = seriesToStackMap[seriesItem.name];
      var stackData = stackedData[stackId];
      if (!stackData) {
        return seriesItem;
      }
      var position = seriesPositions[seriesItem.name];
      return buildStackedSeries(seriesItem, stackData[position]);
    });
  };

  var getGroupName = function getGroupName(series, i, seriesToStackMap) {
    var stackId = seriesToStackMap[series.name];
    return stackId >= 0 ? String(stackId) : 'group-' + i;
  };

  var getGroupedPointTransformer = function getGroupedPointTransformer(getPointTransformer, groupCount, groupOffset) {
    var wrapper = function wrapper(series) {
      var transform = getPointTransformer(series);
      var barWidth = series.barWidth;

      var widthCoeff = 1 / groupCount;
      var offsetCoeff = -(1 - barWidth) / 2 + groupOffset + widthCoeff * (1 - barWidth) / 2;
      return function (point) {
        var ret = transform(point);
        ret.x += ret.width / barWidth * offsetCoeff;
        ret.width *= widthCoeff;
        return ret;
      };
    };
    // Preserve static fields of original transformer.
    Object.assign(wrapper, getPointTransformer);
    return wrapper;
  };

  var applyGrouping = function applyGrouping(seriesList, seriesToStackMap) {
    var groups = new Set();
    seriesList.forEach(function (seriesItem, i) {
      if (seriesItem.getPointTransformer.isBroad) {
        groups.add(getGroupName(seriesItem, i, seriesToStackMap));
      }
    });
    // There cannot be single group.
    if (groups.size < 2) {
      return seriesList;
    }
    var scale = d3Scale.scaleBand().domain(Array.from(groups)).range([0, 1]);
    return seriesList.map(function (seriesItem, i) {
      if (!seriesItem.getPointTransformer.isBroad) {
        return seriesItem;
      }
      var getPointTransformer = getGroupedPointTransformer(seriesItem.getPointTransformer, groups.size, scale(getGroupName(seriesItem, i, seriesToStackMap)));
      return _extends({}, seriesItem, {
        getPointTransformer: getPointTransformer
      });
    });
  };

  var getStackedSeries = function getStackedSeries(seriesList, dataItems, _ref3) {
    var stacks = _ref3.stacks,
        offset = _ref3.offset,
        order = _ref3.order;

    var map = buildSeriesToStackMap(stacks);
    var stackedSeriesList = applyStacking(seriesList, dataItems, map, offset, order);
    var groupedSeriesList = applyGrouping(stackedSeriesList, map);
    return groupedSeriesList;
  };

  var ANIMATIONS = Symbol('animation');

  var addKeyframe = function addKeyframe(name, def) {
    if (typeof document === 'undefined') {
      return;
    }
    var head = document.getElementsByTagName('head')[0]; // eslint-disable-line no-undef
    var style = Array.from(head.getElementsByTagName('style')).find(function (node) {
      return node.dataset[ANIMATIONS];
    });
    if (!style) {
      style = document.createElement('style'); // eslint-disable-line no-undef
      style.type = 'text/css';
      style.dataset[ANIMATIONS] = true;
      head.appendChild(style);
    }
    var content = style.textContent;
    if (!content.includes(name)) {
      style.textContent += '\n@keyframes ' + name + ' ' + def + '\n';
    }
  };

  var getAreaAnimationName = function getAreaAnimationName() {
    var name = 'animation_transform';
    addKeyframe(name, '{ from { transform: scaleY(0); } }');
    return name;
  };

  var getScatterAnimationName = function getScatterAnimationName() {
    var name = 'animation_scatter';
    addKeyframe(name, '{ 0% { opacity: 0; } 50% { opacity: 0; } 100% { opacity: 1 } }');
    return name;
  };

  var getPieAnimationName = function getPieAnimationName() {
    var name = 'animation_pie';
    addKeyframe(name, '{ from { transform: scale(0); } }');
    return name;
  };

  var getDefaultAreaAnimationOptions = function getDefaultAreaAnimationOptions() {
    return '1s';
  };

  var getDefaultPieAnimationOptions = function getDefaultPieAnimationOptions(_ref) {
    var index = _ref.index;
    return 0.7 + index * 0.1 + 's';
  };

  var getAreaAnimationStyle = function getAreaAnimationStyle(scales) {
    var animationStyle = {
      transformOrigin: '0px ' + scales.yScale.copy().clamp(true)(0) + 'px'
    };
    var options = getDefaultAreaAnimationOptions();
    return _extends({
      animation: getAreaAnimationName() + ' ' + options
    }, animationStyle);
  };

  var getPieAnimationStyle = function getPieAnimationStyle(scales, point) {
    var options = getDefaultPieAnimationOptions(point);
    return {
      animation: getPieAnimationName() + ' ' + options
    };
  };

  var getScatterAnimationStyle = function getScatterAnimationStyle() {
    var options = getDefaultAreaAnimationOptions();
    return {
      animation: getScatterAnimationName() + ' ' + options
    };
  };

  var buildAnimatedStyleGetter = function buildAnimatedStyleGetter(style, getAnimationStyle, scales, point) {
    var animationStyle = getAnimationStyle(scales, point);
    return _extends({}, animationStyle, style);
  };

  var isPointInRect = function isPointInRect(x, y, x1, x2, y1, y2) {
    return x1 <= x && x <= x2 && y1 <= y && y <= y2;
  };

  var LINE_TOLERANCE = 10;

  // This function is called from event handlers (when DOM is available) -
  // *window.document* can be accessed safely.
  var createContext = function createContext() {
    return document.createElement('canvas').getContext('2d');
  }; // eslint-disable-line no-undef

  // For a start using browser canvas will suffice.
  // However a better and more clean solution should be found.
  // Can't d3 perform hit testing?
  var createCanvasAbusingHitTesterCreator = function createCanvasAbusingHitTesterCreator(makePath) {
    return function (coordinates) {
      var ctx = createContext();
      var path = makePath();
      path.context(ctx);
      path(coordinates);
      return function (_ref) {
        var _ref2 = slicedToArray(_ref, 2),
            px = _ref2[0],
            py = _ref2[1];

        var hit = ctx.isPointInPath(px, py) ? {} : null;
        if (hit) {
          var point = coordinates.find(function (_ref3) {
            var x = _ref3.x,
                y = _ref3.y;
            return isPointInRect(px, py, x - LINE_TOLERANCE, x + LINE_TOLERANCE, y - LINE_TOLERANCE, y + LINE_TOLERANCE);
          });
          if (point) {
            hit.point = point.index;
          }
        }
        return hit;
      };
    };
  };

  var createAreaHitTester = createCanvasAbusingHitTesterCreator(function () {
    var path = d3Shape.area();
    path.x(dArea.x());
    path.y1(dArea.y1());
    path.y0(dArea.y0());
    return path;
  });

  var createLineHitTester = createCanvasAbusingHitTesterCreator(function () {
    var path = d3Shape.area();
    var getY = dLine.y();
    path.x(dLine.x());
    path.y1(function (point) {
      return getY(point) - LINE_TOLERANCE;
    });
    path.y0(function (point) {
      return getY(point) + LINE_TOLERANCE;
    });
    return path;
  });

  var createSplineHitTester = createCanvasAbusingHitTesterCreator(function () {
    var path = d3Shape.area();
    var getY = dSpline.y();
    path.x(dSpline.x());
    path.y1(function (point) {
      return getY(point) - LINE_TOLERANCE;
    });
    path.y0(function (point) {
      return getY(point) + LINE_TOLERANCE;
    });
    path.curve(dSpline.curve());
    return path;
  });

  var createBarHitTester = function createBarHitTester(coordinates) {
    return function (_ref4) {
      var _ref5 = slicedToArray(_ref4, 2),
          px = _ref5[0],
          py = _ref5[1];

      var point = coordinates.find(function (_ref6) {
        var x = _ref6.x,
            width = _ref6.width,
            y = _ref6.y,
            y1 = _ref6.y1;
        return isPointInRect(px, py, x, x + width, Math.min(y, y1), Math.max(y, y1));
      });
      return point ? { point: point.index } : null;
    };
  };

  // TODO: Use actual point size here!
  var createScatterHitTester = function createScatterHitTester(coordinates) {
    return function (_ref7) {
      var _ref8 = slicedToArray(_ref7, 2),
          px = _ref8[0],
          py = _ref8[1];

      var point = coordinates.find(function (_ref9) {
        var x = _ref9.x,
            y = _ref9.y;
        return isPointInRect(px, py, x - 10, x + 10, y - 10, y + 10);
      });
      return point ? { point: point.index } : null;
    };
  };

  var mapAngleTod3 = function mapAngleTod3(angle) {
    var ret = angle + Math.PI / 2;
    return ret >= 0 ? ret : ret + Math.PI * 2;
  };

  var createPieHitTester = function createPieHitTester(coordinates) {
    return function (_ref10) {
      var _ref11 = slicedToArray(_ref10, 2),
          px = _ref11[0],
          py = _ref11[1];

      var point = coordinates.find(function (_ref12) {
        var x = _ref12.x,
            y = _ref12.y,
            innerRadius = _ref12.innerRadius,
            outerRadius = _ref12.outerRadius,
            startAngle = _ref12.startAngle,
            endAngle = _ref12.endAngle;

        var dx = px - x;
        var dy = py - y;
        var r = Math.sqrt(dx * dx + dy * dy);
        if (r < innerRadius || r > outerRadius) {
          return null;
        }
        var angle = mapAngleTod3(Math.atan2(dy, dx));
        return startAngle <= angle && angle <= endAngle;
      });
      return point ? { point: point.index } : null;
    };
  };

  var buildFilter = function buildFilter(targets) {
    var result = {};
    targets.forEach(function (_ref13) {
      var series = _ref13.series,
          point = _ref13.point;

      result[series] = result[series] || { points: {} };
      if (point >= 0) {
        result[series].points[point] = true;
      } else {
        result[series].self = true;
      }
    });
    return result;
  };

  var changeSeriesState = function changeSeriesState(seriesList, targets, state) {
    if (targets.length === 0) {
      return seriesList;
    }
    var filter = buildFilter(targets);
    var matches = 0;
    var result = seriesList.map(function (seriesItem) {
      var obj = filter[seriesItem.name];
      if (!obj) {
        return seriesItem;
      }
      matches += 1;
      var props = {};
      if (obj.self) {
        props.state = state;
      }
      if (Object.keys(obj.points).length) {
        props.points = seriesItem.points.map(function (point) {
          return obj.points[point.index] ? _extends({}, point, { state: state }) : point;
        });
      }
      return _extends({}, seriesItem, props);
    });
    // This is to prevent false rerenders.
    return matches > 0 ? result : seriesList;
  };

  var getDefaultLegendItems = function getDefaultLegendItems(series) {
    return series.map(function (_ref) {
      var text = _ref.uniqueName,
          color = _ref.color;
      return { text: text, color: color };
    });
  };

  var getPieLegendItems = function getPieLegendItems(series) {
    return series[0].points.map(function (_ref2) {
      var text = _ref2.id,
          color = _ref2.color;
      return { text: text, color: color };
    });
  };

  // The function supports special case when there is single Pie series.
  // There is no commom way to tell if series is of Pie type -
  // checking `seriesComponent` function name will suffice for now.
  var isSinglePieSeriesCase = function isSinglePieSeriesCase(series) {
    return series.length === 1 && series[0].seriesComponent.name === 'SliceCollection';
  };

  var getLegendItems = function getLegendItems(series) {
    return (isSinglePieSeriesCase(series) ? getPieLegendItems : getDefaultLegendItems)(series);
  };

  // This function is called from event handlers (when DOM is available) -
  // *window* can be accessed safely.
  var getEventCoords = function getEventCoords(e) {
    var _window = window,
        pageXOffset = _window.pageXOffset,
        pageYOffset = _window.pageYOffset; // eslint-disable-line no-undef

    var _e$currentTarget$getB = e.currentTarget.getBoundingClientRect(),
        left = _e$currentTarget$getB.left,
        top = _e$currentTarget$getB.top;

    return [e.clientX - left - pageXOffset, e.clientY - top - pageYOffset];
  };

  var buildEventHandler = function buildEventHandler(seriesList, handlers) {
    var hitTesters = null;

    var createHitTesters = function createHitTesters() {
      var obj = {};
      seriesList.forEach(function (seriesItem) {
        obj[seriesItem.symbolName] = seriesItem.createHitTester(seriesItem.points);
      });
      return obj;
    };

    return function (e) {
      var location = getEventCoords(e);
      hitTesters = hitTesters || createHitTesters();
      var targets = [];
      seriesList.forEach(function (seriesItem) {
        var status = hitTesters[seriesItem.symbolName](location);
        if (status) {
          targets.push(_extends({ series: seriesItem.name }, status));
        }
      });
      var arg = { location: location, targets: targets };
      handlers.forEach(function (handler) {
        return handler(arg);
      });
    };
  };

  var buildLeaveEventHandler = function buildLeaveEventHandler(handlers) {
    return function (e) {
      var location = getEventCoords(e);
      var arg = { location: location, targets: [] };
      handlers.forEach(function (handler) {
        return handler(arg);
      });
    };
  };

  var buildEventHandlers = function buildEventHandlers(seriesList, _ref) {
    var clickHandlers = _ref.clickHandlers,
        pointerMoveHandlers = _ref.pointerMoveHandlers;

    var handlers = {};
    if (clickHandlers.length) {
      handlers.click = buildEventHandler(seriesList, clickHandlers);
    }
    if (pointerMoveHandlers.length) {
      handlers.pointermove = buildEventHandler(seriesList, pointerMoveHandlers);
      handlers.pointerleave = buildLeaveEventHandler(pointerMoveHandlers);
    }
    return handlers;
  };

  var selectTarget = function selectTarget(targets) {
    return targets.length > 0 ? targets[targets.length - 1] : null;
  };

  // Comparing by reference is not an option as Tracker always sends new objects.
  // On the other side Tracker cannot persist references as it actually operates with simple scalars
  // and constructs objects to provide info in a slightly more suitable way.
  var compareTargets = function compareTargets(target1, target2) {
    return target1 && target2 && target1.series === target2.series && target1.point === target2.point || !target1 && !target2;
  };

  var processPointerMove = function processPointerMove(targets, currentTarget, notify) {
    var nextTarget = selectTarget(targets);
    if (compareTargets(currentTarget, nextTarget)) {
      return undefined;
    }
    if (notify) {
      notify(nextTarget);
    }
    return nextTarget;
  };

  // It handles the case when point is hovered and series does not contain visual points.
  // Series then knows that it is also hovered and can represent the changed state.
  var getHoverTargets = function getHoverTargets(hover) {
    if (!hover) {
      return [];
    }
    return hover.point >= 0 ? [{ series: hover.series }, hover] : [hover];
  };

  exports.computeExtension = computeExtension;
  exports.computeDomains = computeDomains;
  exports.buildScales = buildScales;
  exports.bBoxes = bBoxes;
  exports.axisCoordinates = axisCoordinates;
  exports.axesData = axesData;
  exports.dArea = dArea;
  exports.dLine = dLine;
  exports.dSpline = dSpline;
  exports.getPiePointTransformer = getPiePointTransformer;
  exports.getAreaPointTransformer = getAreaPointTransformer;
  exports.getBarPointTransformer = getBarPointTransformer;
  exports.findSeriesByName = findSeriesByName;
  exports.dBar = dBar;
  exports.pointAttributes = pointAttributes;
  exports.addSeries = addSeries;
  exports.scaleSeriesPoints = scaleSeriesPoints;
  exports.getStackedSeries = getStackedSeries;
  exports.getAreaAnimationStyle = getAreaAnimationStyle;
  exports.getPieAnimationStyle = getPieAnimationStyle;
  exports.getScatterAnimationStyle = getScatterAnimationStyle;
  exports.buildAnimatedStyleGetter = buildAnimatedStyleGetter;
  exports.createAreaHitTester = createAreaHitTester;
  exports.createLineHitTester = createLineHitTester;
  exports.createSplineHitTester = createSplineHitTester;
  exports.createBarHitTester = createBarHitTester;
  exports.createScatterHitTester = createScatterHitTester;
  exports.createPieHitTester = createPieHitTester;
  exports.changeSeriesState = changeSeriesState;
  exports.createScale = createScale;
  exports.getWidth = getWidth;
  exports.getValueDomainName = getValueDomainName;
  exports.getLegendItems = getLegendItems;
  exports.buildEventHandlers = buildEventHandlers;
  exports.processPointerMove = processPointerMove;
  exports.getHoverTargets = getHoverTargets;
  exports.HORIZONTAL = HORIZONTAL;
  exports.VERTICAL = VERTICAL;
  exports.TOP = TOP;
  exports.BOTTOM = BOTTOM;
  exports.LEFT = LEFT;
  exports.RIGHT = RIGHT;
  exports.MIDDLE = MIDDLE;
  exports.END = END;
  exports.START = START;
  exports.LINEAR = LINEAR;
  exports.BAND = BAND;
  exports.ARGUMENT_DOMAIN = ARGUMENT_DOMAIN;
  exports.VALUE_DOMAIN = VALUE_DOMAIN;
  exports.HOVERED = HOVERED;
  exports.SELECTED = SELECTED;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=dx-chart-core.umd.js.map
