{"version":3,"file":"dx-chart-core.es.js","sources":["../src/constants.js","../src/utils/scale.js","../src/plugins/scale/computeds.js","../src/plugins/layout-manager/computeds.js","../src/plugins/axis/computeds.js","../src/plugins/series/computeds.js","../src/plugins/stack/computeds.js","../src/plugins/animation/computeds.js","../src/utils/series.js","../src/utils/legend.js","../src/utils/event-tracker.js","../src/utils/hover-state.js"],"sourcesContent":["export const HORIZONTAL = 'horizontal';\nexport const VERTICAL = 'vertical';\nexport const TOP = 'top';\nexport const BOTTOM = 'bottom';\nexport const LEFT = 'left';\nexport const RIGHT = 'right';\nexport const MIDDLE = 'middle';\nexport const END = 'end';\nexport const START = 'start';\n\nexport const LINEAR = 'linear';\nexport const BAND = 'band';\n\nexport const ARGUMENT_DOMAIN = 'argument-domain';\nexport const VALUE_DOMAIN = 'value-domain';\n\nexport const HOVERED = 'hovered';\nexport const SELECTED = 'selected';\n","import { HORIZONTAL, VALUE_DOMAIN } from '../constants';\n\nexport const createScale = (\n  { domain, orientation },\n  width, height,\n  constructor,\n) => {\n  const scale = constructor();\n  return scale\n    .domain(domain)\n    .range(orientation === HORIZONTAL ? [0, width] : [height, 0]);\n};\n\nexport const getWidth = scale => (scale.bandwidth ? scale.bandwidth() : 0);\n\nexport const getValueDomainName = name => name || VALUE_DOMAIN;\n","import { extent } from 'd3-array';\nimport { scaleLinear, scaleBand } from 'd3-scale';\nimport { createScale, getValueDomainName } from '../../utils/scale';\nimport {\n  HORIZONTAL, VERTICAL, LINEAR, BAND, ARGUMENT_DOMAIN,\n} from '../../constants';\n\nconst isDefined = item => item !== undefined;\n\n// TODO: Property name should not contain \"axis\" part as it actually means domain.\nconst getSeriesValueDomainName = series => getValueDomainName(series.axisName);\n\nconst calculateDomainField = (items, domain, type) => (\n  type === BAND ? [...domain, ...items] : extent([...domain, ...extent(items)])\n);\n\nconst getArgument = point => point.argument;\n\nconst getValue = point => point.value;\n\nconst getCorrectAxisType = (type, points, getItem) => (\n  type || (points.length && typeof getItem(points[0]) === 'string' && BAND) || LINEAR\n);\n\nconst calculateDomains = (domains, seriesList) => {\n  seriesList.forEach((seriesItem) => {\n    const valueDomainName = getSeriesValueDomainName(seriesItem);\n    const { points } = seriesItem;\n    const argumentDomain = domains[ARGUMENT_DOMAIN];\n    const valueDomain = domains[valueDomainName];\n\n    const valueType = getCorrectAxisType(valueDomain.type, points, getValue);\n    const argumentType = getCorrectAxisType(argumentDomain.type, points, getArgument);\n\n    // TODO: This is a temporary workaround for Stack plugin.\n    // Once scales (or domains) are exposed for modification Stack will modify scale and\n    // this code will be removed.\n    const valueDomainItems = seriesItem.getValueDomain\n      ? seriesItem.getValueDomain(points) : points.map(getValue);\n    valueDomain.domain = calculateDomainField(\n      valueDomainItems,\n      valueDomain.domain,\n      valueType,\n    );\n    valueDomain.type = valueType;\n\n    argumentDomain.domain = calculateDomainField(\n      points.map(getArgument),\n      argumentDomain.domain,\n      argumentType,\n    );\n    argumentDomain.type = argumentType;\n  });\n};\n\nexport const computeExtension = (extension) => {\n  const defaultExtension = [\n    { type: LINEAR, constructor: scaleLinear },\n    { type: BAND, constructor: () => scaleBand().paddingInner(0.3).paddingOuter(0.15) },\n  ];\n  return extension.concat(defaultExtension);\n};\n\nconst collectDomains = (seriesList) => {\n  const domains = {\n    [ARGUMENT_DOMAIN]: { domain: [], orientation: HORIZONTAL },\n  };\n  seriesList.forEach((seriesItem) => {\n    const name = getSeriesValueDomainName(seriesItem);\n    const domain = domains[name] || { domain: [], orientation: VERTICAL };\n    domains[name] = domain;\n    if (seriesItem.isStartedFromZero && domain.domain.length === 0) {\n      domain.domain = [0];\n    }\n  });\n  return domains;\n};\n\nconst takeTypeFromAxesOptions = (domains, axes) => {\n  axes.forEach(({ name, type }) => {\n    const domain = domains[name];\n    if (domain) {\n      domain.type = type;\n    }\n  });\n};\n\nconst takeRestAxesOptions = (domains, axes) => {\n  axes.forEach(({\n    name, tickFormat, min, max,\n  }) => {\n    const domain = domains[name];\n    if (!domain) {\n      return;\n    }\n    domain.tickFormat = tickFormat;\n    if (domain.type !== BAND) {\n      domain.domain = [\n        isDefined(min) ? min : domain.domain[0],\n        isDefined(max) ? max : domain.domain[1],\n      ];\n    }\n  });\n};\n\nexport const computeDomains = (axes, series) => {\n  const result = collectDomains(series);\n  // Axes options are taken in two steps because *type* is required for domains calculation\n  // and other options must be applied after domains are calculated.\n  takeTypeFromAxesOptions(result, axes);\n  calculateDomains(result, series);\n  takeRestAxesOptions(result, axes);\n  return result;\n};\n\nexport const buildScales = (domains, scaleExtension, { width, height }) => {\n  const scales = {};\n  Object.entries(domains).forEach(([name, domain]) => {\n    const { constructor } = scaleExtension.find(item => item.type === domain.type);\n    scales[name] = createScale(domain, width, height, constructor);\n  });\n  return scales;\n};\n","const isEqual = (\n  { width: firstWidth, height: firstHeight },\n  { width: secondWidth, height: secondHeight },\n) => firstWidth === secondWidth && firstHeight === secondHeight;\n\nexport const bBoxes = (prevBBoxes, { bBox, placeholder }) => {\n  if (isEqual(prevBBoxes[placeholder] || {}, bBox)) return prevBBoxes;\n  return { ...prevBBoxes, [placeholder]: bBox };\n};\n","import { getWidth } from '../../utils/scale';\nimport {\n  HORIZONTAL, TOP, LEFT, MIDDLE, END, START,\n} from '../../constants';\n\nconst getTicks = scale => (scale.ticks ? scale.ticks() : scale.domain());\nconst getDominantBaseline = (orientation, position) => {\n  if (orientation === HORIZONTAL) {\n    return position === TOP ? 'baseline' : 'hanging';\n  }\n  return MIDDLE;\n};\nconst getTextAnchor = (orientation, position) => {\n  if (orientation === HORIZONTAL) {\n    return MIDDLE;\n  }\n  return position === LEFT ? END : START;\n};\n\nconst getFormat = (scale, tickFormat) => {\n  if (scale.tickFormat) {\n    return tickFormat ? tickFormat(scale) : scale.tickFormat();\n  }\n  return tick => tick;\n};\n\n// It is called for grid (which do not have labels) - how is it handled here?\nconst calculateAxisCoordinates = (\n  scale,\n  orientation,\n  position,\n  tickSize,\n  indentFromAxis,\n  tickFormat,\n) => {\n  const ticks = getTicks(scale);\n  const offset = getWidth(scale) / 2;\n  const dominantBaseline = getDominantBaseline(orientation, position);\n  const textAnchor = getTextAnchor(orientation, position);\n  const getTickCoordinates = (tick, index) => {\n    const coordinates = scale(tick) + offset;\n    if (orientation === HORIZONTAL) {\n      return {\n        dominantBaseline,\n        textAnchor,\n        x1: coordinates,\n        x2: coordinates,\n        y1: position === TOP ? -tickSize : 0,\n        y2: position === TOP ? 0 : tickSize,\n        text: getFormat(scale, tickFormat)(tick),\n        xText: coordinates,\n        yText: position === TOP ? -indentFromAxis : indentFromAxis,\n        key: index,\n      };\n    }\n    return {\n      dominantBaseline,\n      textAnchor,\n      y1: coordinates,\n      y2: coordinates,\n      x1: position === LEFT ? -tickSize : 0,\n      x2: position === LEFT ? 0 : tickSize,\n      text: getFormat(scale, tickFormat)(tick),\n      xText: position === LEFT ? -indentFromAxis : indentFromAxis,\n      yText: coordinates,\n      key: index,\n    };\n  };\n  return {\n    ticks: ticks.map(getTickCoordinates),\n  };\n};\n\nexport const axisCoordinates = (\n  domain,\n  scale,\n  position,\n  tickSize,\n  indentFromAxis,\n) => calculateAxisCoordinates(\n  scale,\n  domain.orientation,\n  position,\n  tickSize,\n  indentFromAxis,\n  // TODO: *tickFormat* belongs to axis rather then domain - take it from axis.\n  domain.tickFormat,\n);\n\nexport const axesData = (axes, axisProps) => [...axes, axisProps];\n","import {\n  symbol,\n  symbolCircle,\n  line,\n  curveMonotoneX,\n  area,\n  arc,\n  pie,\n} from 'd3-shape';\nimport { scaleOrdinal } from 'd3-scale';\nimport { ARGUMENT_DOMAIN } from '../../constants';\nimport { getWidth, getValueDomainName } from '../../utils/scale';\n\nconst getX = ({ x }) => x;\nconst getY = ({ y }) => y;\nconst getY1 = ({ y1 }) => y1;\n\nconst DEFAULT_POINT_SIZE = 7;\n\nexport const dArea = area()\n  .x(getX)\n  .y1(getY)\n  .y0(getY1);\n\nexport const dLine = line()\n  .x(getX)\n  .y(getY);\n\nexport const dSpline = line()\n  .x(getX)\n  .y(getY)\n  .curve(curveMonotoneX);\n\nexport const getPiePointTransformer = ({\n  innerRadius = 0, outerRadius = 1, argumentScale, valueScale, palette, points,\n}) => {\n  const x = Math.max(...argumentScale.range()) / 2;\n  const y = Math.max(...valueScale.range()) / 2;\n  const radius = Math.min(x, y);\n  const pieData = pie().sort(null).value(d => d.value)(points);\n  const inner = innerRadius * radius;\n  const outer = outerRadius * radius;\n  const gen = arc().innerRadius(inner).outerRadius(outer);\n  const colorScale = scaleOrdinal().range(palette);\n  return (point) => {\n    const { startAngle, endAngle } = pieData[point.index];\n    return {\n      ...point,\n      // TODO: It should be calculated in *pointComponent*.\n      d: gen.startAngle(startAngle).endAngle(endAngle)(),\n      color: point.color || colorScale(point.index),\n      x,\n      y,\n      innerRadius: inner,\n      outerRadius: outer,\n      startAngle,\n      endAngle,\n    };\n  };\n};\n\nexport const getAreaPointTransformer = ({ argumentScale, valueScale }) => {\n  const y1 = valueScale(0);\n  const offset = getWidth(argumentScale) / 2;\n  return point => ({\n    ...point,\n    x: argumentScale(point.argument) + offset,\n    y: valueScale(point.value),\n    y1,\n  });\n};\n\nexport const getBarPointTransformer = ({\n  argumentScale, valueScale, barWidth,\n}) => {\n  const y1 = valueScale(0);\n  const categoryWidth = getWidth(argumentScale);\n  const offset = categoryWidth * (1 - barWidth) / 2;\n  const width = categoryWidth * barWidth;\n  return point => ({\n    ...point,\n    x: argumentScale(point.argument) + offset,\n    y: valueScale(point.value),\n    y1,\n    width,\n  });\n};\n// Used for Bar grouping.\ngetBarPointTransformer.isBroad = true;\n\nexport const findSeriesByName = (\n  name, series,\n) => series.find(seriesItem => seriesItem.symbolName === name);\n\nexport const dBar = ({\n  x, y, y1, width,\n}) => ({\n  x, y: Math.min(y, y1), width: width || 2, height: Math.abs(y1 - y),\n});\n\nexport const pointAttributes = ({ size = DEFAULT_POINT_SIZE }) => {\n  const dPoint = symbol().size([size ** 2]).type(symbolCircle)();\n  return item => ({\n    // TODO: It should be calculated in *pointComponent*.\n    d: dPoint,\n    x: item.x,\n    y: item.y,\n  });\n};\n\nconst createNewUniqueName = name => name.replace(/\\d*$/, str => (str ? +str + 1 : 0));\n\nconst addItem = (list, item) => (list.find(obj => obj.uniqueName === item.uniqueName)\n  ? addItem(list, {\n    ...item,\n    uniqueName: createNewUniqueName(item.uniqueName),\n  })\n  : list.concat(item)\n);\n\n// TODO: Memoization is much needed here.\n// Though \"series\" list never persists, single \"series\" item most often does.\nconst createPoints = (argumentField, valueField, data) => {\n  const points = [];\n  data.forEach((dataItem, index) => {\n    const argument = dataItem[argumentField];\n    const value = dataItem[valueField];\n    if (argument !== undefined && value !== undefined) {\n      points.push({ argument, value, index });\n    }\n  });\n  return points;\n};\n\nexport const addSeries = (series, data, palette, props) => {\n  const points = createPoints(props.argumentField, props.valueField, data);\n  // It is used to generate unique series dependent attribute names for patterns.\n  // *symbolName* cannot be used as it cannot be part of DOM attribute name.\n  // TODO: Consider making *name* unique and then use it instead of *index*.\n  const index = series.length;\n  return addItem(series, {\n    ...props,\n    index,\n    points,\n    uniqueName: props.name,\n    palette, // TODO: For Pie only. Find a better place for it.\n    color: props.color || palette[index % palette.length],\n  });\n};\n\n// TODO: Memoization is much needed here by the same reason as in \"createPoints\".\n// Make \"scales\" persistent first.\nconst scalePoints = (series, scales) => {\n  const { getPointTransformer, ...rest } = series;\n  const transform = getPointTransformer({\n    ...series,\n    argumentScale: scales[ARGUMENT_DOMAIN],\n    valueScale: scales[getValueDomainName(series.axisName)],\n  });\n  return {\n    ...rest,\n    points: series.points.map(transform),\n  };\n};\n\nexport const scaleSeriesPoints = (series, scales) => series.map(\n  seriesItem => scalePoints(seriesItem, scales),\n);\n","import { stack } from 'd3-shape';\nimport { scaleBand } from 'd3-scale';\n\n// \"Stack\" plugin relies on \"data\" and \"series\" getters and\n// knowledge about \"getPointTransformer\" and \"path\" functions behavior.\n\nconst buildSeriesToStackMap = (stacks) => {\n  const result = {};\n  stacks.forEach(({ series }, i) => {\n    series.forEach((name) => {\n      result[name] = i;\n    });\n  });\n  return result;\n};\n\nconst getStackedPointTransformer = (getPointTransformer) => {\n  const wrapper = (series) => {\n    const transform = getPointTransformer(series);\n    const { valueScale } = series;\n    return (point) => {\n      const ret = transform(point);\n      ret.y1 = valueScale(point.value0);\n      return ret;\n    };\n  };\n  // Preserve static fields of original transformer.\n  Object.assign(wrapper, getPointTransformer);\n  return wrapper;\n};\n\n// TODO: Temporary - see corresponding note in *computeDomains*.\nconst getValueDomain = (points) => {\n  const items = [];\n  points.forEach((point) => {\n    items.push(point.value, point.value0);\n  });\n  return items;\n};\n\nconst collectStacks = (seriesList, seriesToStackMap) => {\n  const stacksKeys = {};\n  const seriesPositions = {};\n  seriesList.forEach(({ name, valueField }) => {\n    const stackId = seriesToStackMap[name];\n    if (stackId === undefined) {\n      return;\n    }\n\n    if (!stacksKeys[stackId]) {\n      stacksKeys[stackId] = [];\n    }\n    seriesPositions[name] = stacksKeys[stackId].length;\n    stacksKeys[stackId].push(valueField);\n  });\n  // Stack cannot consist of single series.\n  Object.keys(stacksKeys).forEach((stackId) => {\n    if (stacksKeys[stackId].length === 1) {\n      delete stacksKeys[stackId];\n    }\n  });\n  return [stacksKeys, seriesPositions];\n};\n\nconst getStackedData = (stacksKeys, dataItems, offset, order) => {\n  const result = {};\n  Object.keys(stacksKeys).forEach((stackId) => {\n    result[stackId] = stack().keys(stacksKeys[stackId]).order(order).offset(offset)(dataItems);\n  });\n  return result;\n};\n\nconst buildStackedSeries = (series, dataItems) => {\n  const points = series.points.map((point) => {\n    const [value0, value] = dataItems[point.index];\n    return { ...point, value, value0 };\n  });\n  const stackedSeries = {\n    ...series,\n    points,\n  };\n  if (series.isStartedFromZero) {\n    stackedSeries.getPointTransformer = getStackedPointTransformer(series.getPointTransformer);\n    stackedSeries.getValueDomain = getValueDomain;\n  }\n  return stackedSeries;\n};\n\nconst applyStacking = (seriesList, dataItems, seriesToStackMap, offset, order) => {\n  const [stacksKeys, seriesPositions] = collectStacks(seriesList, seriesToStackMap);\n  if (Object.keys(stacksKeys).length === 0) {\n    return seriesList;\n  }\n  const stackedData = getStackedData(stacksKeys, dataItems, offset, order);\n  return seriesList.map((seriesItem) => {\n    const stackId = seriesToStackMap[seriesItem.name];\n    const stackData = stackedData[stackId];\n    if (!stackData) {\n      return seriesItem;\n    }\n    const position = seriesPositions[seriesItem.name];\n    return buildStackedSeries(seriesItem, stackData[position]);\n  });\n};\n\nconst getGroupName = (series, i, seriesToStackMap) => {\n  const stackId = seriesToStackMap[series.name];\n  return stackId >= 0 ? String(stackId) : `group-${i}`;\n};\n\nconst getGroupedPointTransformer = (getPointTransformer, groupCount, groupOffset) => {\n  const wrapper = (series) => {\n    const transform = getPointTransformer(series);\n    const { barWidth } = series;\n    const widthCoeff = 1 / groupCount;\n    const offsetCoeff = -(1 - barWidth) / 2 + groupOffset + widthCoeff * (1 - barWidth) / 2;\n    return (point) => {\n      const ret = transform(point);\n      ret.x += (ret.width / barWidth) * offsetCoeff;\n      ret.width *= widthCoeff;\n      return ret;\n    };\n  };\n  // Preserve static fields of original transformer.\n  Object.assign(wrapper, getPointTransformer);\n  return wrapper;\n};\n\nconst applyGrouping = (seriesList, seriesToStackMap) => {\n  const groups = new Set();\n  seriesList.forEach((seriesItem, i) => {\n    if (seriesItem.getPointTransformer.isBroad) {\n      groups.add(getGroupName(seriesItem, i, seriesToStackMap));\n    }\n  });\n  // There cannot be single group.\n  if (groups.size < 2) {\n    return seriesList;\n  }\n  const scale = scaleBand().domain(Array.from(groups)).range([0, 1]);\n  return seriesList.map((seriesItem, i) => {\n    if (!seriesItem.getPointTransformer.isBroad) {\n      return seriesItem;\n    }\n    const getPointTransformer = getGroupedPointTransformer(\n      seriesItem.getPointTransformer,\n      groups.size,\n      scale(getGroupName(seriesItem, i, seriesToStackMap)),\n    );\n    return {\n      ...seriesItem,\n      getPointTransformer,\n    };\n  });\n};\n\nexport const getStackedSeries = (seriesList, dataItems, { stacks, offset, order }) => {\n  const map = buildSeriesToStackMap(stacks);\n  const stackedSeriesList = applyStacking(seriesList, dataItems, map, offset, order);\n  const groupedSeriesList = applyGrouping(stackedSeriesList, map);\n  return groupedSeriesList;\n};\n","const ANIMATIONS = Symbol('animation');\n\nconst addKeyframe = (name, def) => {\n  if (typeof document === 'undefined') {\n    return;\n  }\n  const head = document.getElementsByTagName('head')[0]; // eslint-disable-line no-undef\n  let style = Array.from(head.getElementsByTagName('style'))\n    .find(node => node.dataset[ANIMATIONS]);\n  if (!style) {\n    style = document.createElement('style'); // eslint-disable-line no-undef\n    style.type = 'text/css';\n    style.dataset[ANIMATIONS] = true;\n    head.appendChild(style);\n  }\n  const content = style.textContent;\n  if (!content.includes(name)) {\n    style.textContent += `\\n@keyframes ${name} ${def}\\n`;\n  }\n};\n\nconst getAreaAnimationName = () => {\n  const name = 'animation_transform';\n  addKeyframe(name, '{ from { transform: scaleY(0); } }');\n  return name;\n};\n\nconst getScatterAnimationName = () => {\n  const name = 'animation_scatter';\n  addKeyframe(name, '{ 0% { opacity: 0; } 50% { opacity: 0; } 100% { opacity: 1 } }');\n  return name;\n};\n\nconst getPieAnimationName = () => {\n  const name = 'animation_pie';\n  addKeyframe(name, '{ from { transform: scale(0); } }');\n  return name;\n};\n\nconst getDefaultAreaAnimationOptions = () => '1s';\n\nconst getDefaultPieAnimationOptions = ({ index }) => `${0.7 + index * 0.1}s`;\n\nexport const getAreaAnimationStyle = (scales) => {\n  const animationStyle = {\n    transformOrigin: `0px ${scales.yScale.copy().clamp(true)(0)}px`,\n  };\n  const options = getDefaultAreaAnimationOptions();\n  return {\n    animation: `${getAreaAnimationName()} ${options}`,\n    ...animationStyle,\n  };\n};\n\nexport const getPieAnimationStyle = (scales, point) => {\n  const options = getDefaultPieAnimationOptions(point);\n  return {\n    animation: `${getPieAnimationName()} ${options}`,\n  };\n};\n\nexport const getScatterAnimationStyle = () => {\n  const options = getDefaultAreaAnimationOptions();\n  return {\n    animation: `${getScatterAnimationName()} ${options}`,\n  };\n};\n\nexport const buildAnimatedStyleGetter = (\n  style, getAnimationStyle, scales, point,\n) => {\n  const animationStyle = getAnimationStyle(scales, point);\n  return {\n    ...animationStyle,\n    ...style,\n  };\n};\n","import { area } from 'd3-shape';\nimport { dArea, dLine, dSpline } from '../plugins/series/computeds';\n\nconst isPointInRect = (x, y, x1, x2, y1, y2) => x1 <= x && x <= x2 && y1 <= y && y <= y2;\n\nconst LINE_TOLERANCE = 10;\n\n// This function is called from event handlers (when DOM is available) -\n// *window.document* can be accessed safely.\nconst createContext = () => document.createElement('canvas').getContext('2d'); // eslint-disable-line no-undef\n\n// For a start using browser canvas will suffice.\n// However a better and more clean solution should be found.\n// Can't d3 perform hit testing?\nconst createCanvasAbusingHitTesterCreator = makePath => (coordinates) => {\n  const ctx = createContext();\n  const path = makePath();\n  path.context(ctx);\n  path(coordinates);\n  return ([px, py]) => {\n    const hit = ctx.isPointInPath(px, py) ? {} : null;\n    if (hit) {\n      const point = coordinates.find(({ x, y }) => isPointInRect(\n        px, py,\n        x - LINE_TOLERANCE, x + LINE_TOLERANCE, y - LINE_TOLERANCE, y + LINE_TOLERANCE,\n      ));\n      if (point) {\n        hit.point = point.index;\n      }\n    }\n    return hit;\n  };\n};\n\nexport const createAreaHitTester = createCanvasAbusingHitTesterCreator(() => {\n  const path = area();\n  path.x(dArea.x());\n  path.y1(dArea.y1());\n  path.y0(dArea.y0());\n  return path;\n});\n\nexport const createLineHitTester = createCanvasAbusingHitTesterCreator(() => {\n  const path = area();\n  const getY = dLine.y();\n  path.x(dLine.x());\n  path.y1(point => getY(point) - LINE_TOLERANCE);\n  path.y0(point => getY(point) + LINE_TOLERANCE);\n  return path;\n});\n\nexport const createSplineHitTester = createCanvasAbusingHitTesterCreator(() => {\n  const path = area();\n  const getY = dSpline.y();\n  path.x(dSpline.x());\n  path.y1(point => getY(point) - LINE_TOLERANCE);\n  path.y0(point => getY(point) + LINE_TOLERANCE);\n  path.curve(dSpline.curve());\n  return path;\n});\n\nexport const createBarHitTester = coordinates => ([px, py]) => {\n  const point = coordinates.find(({\n    x, width, y, y1,\n  }) => isPointInRect(px, py, x, x + width, Math.min(y, y1), Math.max(y, y1)));\n  return point ? { point: point.index } : null;\n};\n\n// TODO: Use actual point size here!\nexport const createScatterHitTester = coordinates => ([px, py]) => {\n  const point = coordinates.find(({\n    x, y,\n  }) => isPointInRect(px, py, x - 10, x + 10, y - 10, y + 10));\n  return point ? { point: point.index } : null;\n};\n\nconst mapAngleTod3 = (angle) => {\n  const ret = angle + Math.PI / 2;\n  return ret >= 0 ? ret : ret + Math.PI * 2;\n};\n\nexport const createPieHitTester = coordinates => ([px, py]) => {\n  const point = coordinates.find(({\n    x, y, innerRadius, outerRadius, startAngle, endAngle,\n  }) => {\n    const dx = px - x;\n    const dy = py - y;\n    const r = Math.sqrt(dx * dx + dy * dy);\n    if (r < innerRadius || r > outerRadius) {\n      return null;\n    }\n    const angle = mapAngleTod3(Math.atan2(dy, dx));\n    return startAngle <= angle && angle <= endAngle;\n  });\n  return point ? { point: point.index } : null;\n};\n\nconst buildFilter = (targets) => {\n  const result = {};\n  targets.forEach(({ series, point }) => {\n    result[series] = result[series] || { points: {} };\n    if (point >= 0) {\n      result[series].points[point] = true;\n    } else {\n      result[series].self = true;\n    }\n  });\n  return result;\n};\n\nexport const changeSeriesState = (seriesList, targets, state) => {\n  if (targets.length === 0) {\n    return seriesList;\n  }\n  const filter = buildFilter(targets);\n  let matches = 0;\n  const result = seriesList.map((seriesItem) => {\n    const obj = filter[seriesItem.name];\n    if (!obj) {\n      return seriesItem;\n    }\n    matches += 1;\n    const props = {};\n    if (obj.self) {\n      props.state = state;\n    }\n    if (Object.keys(obj.points).length) {\n      props.points = seriesItem.points.map(\n        point => (obj.points[point.index] ? { ...point, state } : point),\n      );\n    }\n    return { ...seriesItem, ...props };\n  });\n  // This is to prevent false rerenders.\n  return matches > 0 ? result : seriesList;\n};\n","const getDefaultLegendItems = series => series.map(\n  ({ uniqueName: text, color }) => ({ text, color }),\n);\n\nconst getPieLegendItems = series => series[0]\n  .points.map(({ id: text, color }) => ({ text, color }));\n\n// The function supports special case when there is single Pie series.\n// There is no commom way to tell if series is of Pie type -\n// checking `seriesComponent` function name will suffice for now.\nconst isSinglePieSeriesCase = series => (\n  series.length === 1 && series[0].seriesComponent.name === 'SliceCollection'\n);\n\nexport const getLegendItems = series => (\n  (isSinglePieSeriesCase(series) ? getPieLegendItems : getDefaultLegendItems)(series)\n);\n","// This function is called from event handlers (when DOM is available) -\n// *window* can be accessed safely.\nconst getEventCoords = (e) => {\n  const { pageXOffset, pageYOffset } = window; // eslint-disable-line no-undef\n  const { left, top } = e.currentTarget.getBoundingClientRect();\n  return [\n    e.clientX - left - pageXOffset,\n    e.clientY - top - pageYOffset,\n  ];\n};\n\nconst buildEventHandler = (seriesList, handlers) => {\n  let hitTesters = null;\n\n  const createHitTesters = () => {\n    const obj = {};\n    seriesList.forEach((seriesItem) => {\n      obj[seriesItem.symbolName] = seriesItem.createHitTester(seriesItem.points);\n    });\n    return obj;\n  };\n\n  return (e) => {\n    const location = getEventCoords(e);\n    hitTesters = hitTesters || createHitTesters();\n    const targets = [];\n    seriesList.forEach((seriesItem) => {\n      const status = hitTesters[seriesItem.symbolName](location);\n      if (status) {\n        targets.push({ series: seriesItem.name, ...status });\n      }\n    });\n    const arg = { location, targets };\n    handlers.forEach(handler => handler(arg));\n  };\n};\n\nconst buildLeaveEventHandler = handlers => (e) => {\n  const location = getEventCoords(e);\n  const arg = { location, targets: [] };\n  handlers.forEach(handler => handler(arg));\n};\n\nexport const buildEventHandlers = (seriesList, { clickHandlers, pointerMoveHandlers }) => {\n  const handlers = {};\n  if (clickHandlers.length) {\n    handlers.click = buildEventHandler(seriesList, clickHandlers);\n  }\n  if (pointerMoveHandlers.length) {\n    handlers.pointermove = buildEventHandler(seriesList, pointerMoveHandlers);\n    handlers.pointerleave = buildLeaveEventHandler(pointerMoveHandlers);\n  }\n  return handlers;\n};\n","\nconst selectTarget = targets => (targets.length > 0 ? targets[targets.length - 1] : null);\n\n// Comparing by reference is not an option as Tracker always sends new objects.\n// On the other side Tracker cannot persist references as it actually operates with simple scalars\n// and constructs objects to provide info in a slightly more suitable way.\nconst compareTargets = (target1, target2) => (\n  (target1 && target2 && target1.series === target2.series && target1.point === target2.point)\n    || (!target1 && !target2)\n);\n\nexport const processPointerMove = (targets, currentTarget, notify) => {\n  const nextTarget = selectTarget(targets);\n  if (compareTargets(currentTarget, nextTarget)) {\n    return undefined;\n  }\n  if (notify) {\n    notify(nextTarget);\n  }\n  return nextTarget;\n};\n\n// It handles the case when point is hovered and series does not contain visual points.\n// Series then knows that it is also hovered and can represent the changed state.\nexport const getHoverTargets = (hover) => {\n  if (!hover) {\n    return [];\n  }\n  return hover.point >= 0 ? [{ series: hover.series }, hover] : [hover];\n};\n"],"names":["HORIZONTAL","VERTICAL","TOP","BOTTOM","LEFT","RIGHT","MIDDLE","END","START","LINEAR","BAND","ARGUMENT_DOMAIN","VALUE_DOMAIN","HOVERED","SELECTED","createScale","width","height","constructor","domain","orientation","scale","range","getWidth","bandwidth","getValueDomainName","name","isDefined","item","undefined","getSeriesValueDomainName","series","axisName","calculateDomainField","items","type","extent","getArgument","point","argument","getValue","value","getCorrectAxisType","points","getItem","length","calculateDomains","domains","seriesList","forEach","seriesItem","valueDomainName","argumentDomain","valueDomain","valueType","argumentType","valueDomainItems","getValueDomain","map","computeExtension","extension","defaultExtension","scaleLinear","scaleBand","paddingInner","paddingOuter","concat","collectDomains","isStartedFromZero","takeTypeFromAxesOptions","axes","takeRestAxesOptions","tickFormat","min","max","computeDomains","result","buildScales","scaleExtension","scales","entries","find","isEqual","firstWidth","firstHeight","secondWidth","secondHeight","bBoxes","prevBBoxes","bBox","placeholder","getTicks","ticks","getDominantBaseline","position","getTextAnchor","getFormat","tick","calculateAxisCoordinates","tickSize","indentFromAxis","offset","dominantBaseline","textAnchor","getTickCoordinates","index","coordinates","axisCoordinates","axesData","axisProps","getX","x","getY","y","getY1","y1","DEFAULT_POINT_SIZE","dArea","area","y0","dLine","line","dSpline","curve","curveMonotoneX","getPiePointTransformer","innerRadius","outerRadius","argumentScale","valueScale","palette","Math","radius","pieData","pie","sort","d","inner","outer","gen","arc","colorScale","scaleOrdinal","startAngle","endAngle","color","getAreaPointTransformer","getBarPointTransformer","barWidth","categoryWidth","isBroad","findSeriesByName","symbolName","dBar","abs","pointAttributes","size","dPoint","symbol","symbolCircle","createNewUniqueName","replace","str","addItem","list","obj","uniqueName","createPoints","argumentField","valueField","data","dataItem","push","addSeries","props","scalePoints","getPointTransformer","rest","transform","scaleSeriesPoints","buildSeriesToStackMap","stacks","i","getStackedPointTransformer","wrapper","ret","value0","assign","collectStacks","seriesToStackMap","stacksKeys","seriesPositions","stackId","keys","getStackedData","dataItems","order","stack","buildStackedSeries","stackedSeries","applyStacking","Object","stackedData","stackData","getGroupName","String","getGroupedPointTransformer","groupCount","groupOffset","widthCoeff","offsetCoeff","applyGrouping","groups","Set","add","Array","from","getStackedSeries","stackedSeriesList","groupedSeriesList","ANIMATIONS","Symbol","addKeyframe","def","document","head","getElementsByTagName","style","node","dataset","createElement","appendChild","content","textContent","includes","getAreaAnimationName","getScatterAnimationName","getPieAnimationName","getDefaultAreaAnimationOptions","getDefaultPieAnimationOptions","getAreaAnimationStyle","animationStyle","yScale","copy","clamp","options","getPieAnimationStyle","getScatterAnimationStyle","buildAnimatedStyleGetter","getAnimationStyle","isPointInRect","x1","x2","y2","LINE_TOLERANCE","createContext","getContext","createCanvasAbusingHitTesterCreator","ctx","path","makePath","context","px","py","hit","isPointInPath","createAreaHitTester","createLineHitTester","createSplineHitTester","createBarHitTester","createScatterHitTester","mapAngleTod3","angle","PI","createPieHitTester","dx","dy","r","sqrt","atan2","buildFilter","targets","self","changeSeriesState","state","filter","matches","getDefaultLegendItems","text","getPieLegendItems","id","isSinglePieSeriesCase","seriesComponent","getLegendItems","getEventCoords","e","window","pageXOffset","pageYOffset","currentTarget","getBoundingClientRect","left","top","clientX","clientY","buildEventHandler","handlers","hitTesters","createHitTesters","createHitTester","location","status","arg","handler","buildLeaveEventHandler","buildEventHandlers","clickHandlers","pointerMoveHandlers","click","pointermove","pointerleave","selectTarget","compareTargets","target1","target2","processPointerMove","notify","nextTarget","getHoverTargets","hover"],"mappings":"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"}